1
00:00:02,670 --> 00:00:06,330
プールクエリを使って､ もう少し高度なクエリを書く時間です｡ 

2
00:00:06,480 --> 00:00:10,020
このクエリは､ クエリにブール論理を追加するために使用されます｡ 

3
00:00:10,050 --> 00:00:15,810
このクエリは､ SQLのweight lossに似ていると考えることができますが､ poolクエリは関連するスコアも扱うので､

4
00:00:15,810 --> 00:00:19,170
より高度なクエリになっています｡

5
00:00:19,530 --> 00:00:27,060
この問題に取り組む前に､ まず､ このコースの前半で取り上げた､ クエリを実行する際のコンテキストについて復習しておきたいと思います｡

6
00:00:27,390 --> 00:00:32,460
クエリは､ クエリコンテキストまたはフィルタコンテキストで実行できることを思い出すかもしれません｡ 

7
00:00:32,880 --> 00:00:37,000
この違いは､ クエリの中のプルクエリを理解する上で欠かせない｡ 

8
00:00:37,020 --> 00:00:37,680
コンテキスト

9
00:00:37,680 --> 00:00:38,160
関連性がある｡ 

10
00:00:38,160 --> 00:00:40,830
スコアが計算され､ 書類が発注されます｡ 

11
00:00:40,830 --> 00:00:46,470
しかし､ フィルタコンテキストでどのようにマジック与えられたクエリは､ ドキュメントがクエリに一致するかどうかだけ決定され､

12
00:00:46,470 --> 00:00:49,590
それがクエリに一致する方法ではないです｡

13
00:00:49,980 --> 00:00:55,590
プールクエリは両方のコンテキストで使用できますが､ ここではクエリコンテキストを使用することにします｡ 

14
00:00:55,890 --> 00:00:57,540
そのことは記憶に新しいところです｡ 

15
00:00:57,540 --> 00:00:59,610
さっそくプールクエリを使ってみましょう｡ 

16
00:00:59,940 --> 00:01:04,950
そこで､ まずプールのクエリータイプと空のオブジェクトを入力してみます｡ 

17
00:01:05,160 --> 00:01:10,230
まずやりたいのは､ パルメザンチーズを材料として含むレシピを合わせることです｡ 

18
00:01:10,230 --> 00:01:15,330
そして､ 手抜き感があるので､ 準備時間は15分以内にしてほしいです｡ 

19
00:01:15,690 --> 00:01:19,290
mustというキーの中にクエリーを指定することでそれが可能になるんだ｡ 

20
00:01:19,560 --> 00:01:23,730
そこで､ マストキーを追加してみましょう｡ これは､ ご覧のように配列です｡ 

21
00:01:24,060 --> 00:01:29,760
つまり､ この配列にはオブジェクトの配列が含まれ､ 各オブジェクトはクエリクラスとなります｡ 

22
00:01:30,120 --> 00:01:38,910
それでは､ 最初のオブジェクトを追加してみましょう｡ これは､ parmesanという用語に対する､ 原材料の開始名フィールドのマッチクエリーとなります｡

23
00:01:39,270 --> 00:01:41,400
それが制約のひとつだったんですね｡ 

24
00:01:41,550 --> 00:01:50,670
must 配列の中にもう一つクエリ句を追加して､ 準備時間分フィールドのクエリをアレンジして､

25
00:01:50,670 --> 00:01:56,550
lce キーと値として 15 を指定してみましょう｡

26
00:01:56,880 --> 00:02:01,290
つまり､ ここにあるように､ マスタリーの中でクエリ句を指定しているだけなのです｡ 

27
00:02:01,590 --> 00:02:06,750
つまり､ この配列内に追加するオブジェクトは､ これまで見てきたクエリと全く同じものです｡ 

28
00:02:07,200 --> 00:02:10,330
Msの値として配列を追加したことに注意してください｡  キーになります｡ 

29
00:02:10,350 --> 00:02:17,400
クルーをキーにしたオブジェクトを追加することもできますが､ これは同じタイプのクエリーが複数ない場合にのみ有効です｡

30
00:02:17,520 --> 00:02:19,440
ただ､ 配列で指定するのがいいんです｡ 

31
00:02:19,440 --> 00:02:21,480
だから､ そういう構文にしたんです｡ 

32
00:02:21,990 --> 00:02:24,570
さて､ では実際にどういうことなのでしょうか？

33
00:02:25,050 --> 00:02:31,110
mosqueの中に入れ子になっているクエリが一致するためには､ must keyの中のクエリが満たされなければならないことは､

34
00:02:31,110 --> 00:02:35,250
おそらく驚くにあたらないだろう｡

35
00:02:35,250 --> 00:02:40,080
しかし､ クエリが文書の関連性スコアに寄与することも重要なポイントです｡ 

36
00:02:40,590 --> 00:02:45,810
つまり､ ドキュメントはmust､ objects､ must配列内のすべてのクエリにマッチしなければなりませんが､

37
00:02:45,810 --> 00:02:49,800
それらのクエリにどれだけマッチするかでスコアリングされるのです｡

38
00:02:50,250 --> 00:02:54,000
これは､ 先に説明した様々な関連スコアに基づき行われます｡ 

39
00:02:54,570 --> 00:02:58,560
ということで､ とりあえずクエリを実行して､ 結果を見てみましょう｡ 

40
00:02:59,010 --> 00:03:07,350
そして､ そのレシピには確かにパルメザンチーズが含まれており､ 調理時間は15分以下であることが分かるはずです｡

41
00:03:09,250 --> 00:03:09,850
なるほど｡ 

42
00:03:09,880 --> 00:03:17,880
つまり､ ある文書がどの程度レンジクエリを満たしているかを計算しようとしても意味がないので､ 実際にクエリを改善することができるのです｡

43
00:03:17,890 --> 00:03:19,960
本当にイエスかノーかの質問です｡ 

44
00:03:20,260 --> 00:03:25,240
クエリをマスタリ内に保持するのではなく､ フィルタオブジェクト内に移動させればよいのです｡ 

45
00:03:25,480 --> 00:03:31,030
Elasticsearchは賢いので､ レンジクエリがマスタリ内に配置されると､ 一定のスコア1を適用するだけですが､

46
00:03:31,030 --> 00:03:36,010
フィルタオブジェクトはパフォーマンスの点で優位に立ちます｡

47
00:03:36,100 --> 00:03:43,020
filterオブジェクトは､ マッチするかしないかのクエリのためのものである｡  e. は､ どれだけマッチしているかということはないんです｡

48
00:03:43,570 --> 00:03:49,750
より正確には､ このオブジェクト内のクエリは､ クエリコンテキストではなく､ フィルタコンテキストで実行されるため､

49
00:03:49,750 --> 00:03:51,730
スコアは無視されます｡

50
00:03:52,300 --> 00:03:58,330
フィルタクルーが有利なのは､ クエリ句をキャッシュして後続のクエリに利用できる点である｡ 

51
00:03:58,660 --> 00:04:03,510
これは､ クエリ句の結果が直接クエリや文書に依存するためである｡ 

52
00:04:03,520 --> 00:04:09,340
文書がどの程度一致しているかという概念がないため､ 結果をキャッシュするのが非常に簡単です｡ 

53
00:04:10,030 --> 00:04:10,960
話はもういい｡ 

54
00:04:10,960 --> 00:04:13,120
クエリーをフィルターオブジェクトに移動してみましょう｡ 

55
00:04:13,570 --> 00:04:21,250
そこで､ このオブジェクトをここでカットして､ フィルタオブジェクトを追加してみます｡ 

56
00:04:21,250 --> 00:04:30,160
実際には配列として追加しますが､ マストキーと同じルールが適用され､ ここに貼り付けてクエリを実行します｡

57
00:04:30,160 --> 00:04:32,950
以前と全く同じマッチングが得られるはずです｡ 

58
00:04:33,340 --> 00:04:42,850
小さなことですが､ スコアがちょうど1つ低くなっているのは､ クエリーがマスタリー内にあったときのような一定のスコアが適用されなくなった結果です｡

59
00:04:43,300 --> 00:04:49,390
このクエリーは､ パルメザンチーズを含むレシピで､ 準備時間が最大15分のものにマッチします｡ 

60
00:04:49,900 --> 00:04:55,690
レシピの中にツナが含まれていて､ それが苦手なことに気づいたので､ 問い合わせを少し洗練させたい｡

61
00:04:56,080 --> 00:05:02,890
そのため､ マグロを使ったレシピを除外したいので､ 最も対象が多いものの反対という感じです｡

62
00:05:03,370 --> 00:05:06,880
これは､ オブジェクトではなく､ マストのアンダースコアで簡単に行うことができます｡ 

63
00:05:06,910 --> 00:05:09,310
構文は他のオブジェクトと同じです｡ 

64
00:05:09,310 --> 00:05:10,540
だから､ 何も目新しいことはない｡ 

65
00:05:10,990 --> 00:05:13,120
では､ それを追加してきましょう｡ 

66
00:05:13,360 --> 00:05:15,580
だから､ ナッツをアンダースコアしなければならない｡ 

67
00:05:15,700 --> 00:05:20,620
ここでも配列で指定していますが､ オブジェクトの方がいいという方は､ どうぞそうしてください｡ 

68
00:05:21,130 --> 00:05:34,720
そして､ 実際にこのクエリをコピーして貼り付け､ 値をtunaに変更して実行してみましょう｡

69
00:05:34,960 --> 00:05:38,710
ですから､ ドキュメントは先ほど追加したクエリとは一致しないはずです｡ 

70
00:05:38,710 --> 00:05:43,810
オブジェクトではなく､ 必ずアンダースコアで閉じるクエリは､ フィルタコンテキストで実行されます｡ 

71
00:05:43,810 --> 00:05:51,070
フィルタオブジェクトと同様に､ スコアリングは無視され､ すべての文書に対してゼロのスコアが返されます｡

72
00:05:51,370 --> 00:05:58,180
フィルタコンテキスト内の他のクエリと同様に､ must not オブジェクト内のクエリもキャッシュの対象として考慮されます｡

73
00:05:58,210 --> 00:06:04,480
なぜ「考えられる」と言ったかというと､ これはElasticsearchが最初に処理することなので､ クエリがキャッシュされる可能性はありますが､

74
00:06:04,480 --> 00:06:08,110
保証はないのです｡

75
00:06:08,740 --> 00:06:11,620
では､ 今クエリに追加したいことがあります｡ 

76
00:06:11,680 --> 00:06:14,680
ツナは苦手ですが､ パセリはとても好きです｡ 

77
00:06:14,680 --> 00:06:17,920
だから､ パセリを使ったレシピは上位にランクインさせたいですね｡ 

78
00:06:18,310 --> 00:06:21,370
と同じようなクエリを追加することでできるんです｡ 

79
00:06:21,370 --> 00:06:22,840
だから､ オブジェクトをアサートする｡ 

80
00:06:23,200 --> 00:06:29,590
それでは､ 他のキーと同じ構文で､ Stuartという新しいキーを追加してみましょう｡ 

81
00:06:30,010 --> 00:06:38,350
そしてまた､ このクエリをコピーして､ ペーストし､ ここに値としてパセリを挿入します｡ 

82
00:06:38,710 --> 00:06:42,700
そして､ それについてさらに話す前に､ 先に実行します｡ 

83
00:06:43,090 --> 00:06:45,640
さて､ スチュワートのオブジェはちょっと特殊です｡ 

84
00:06:45,880 --> 00:06:51,850
基本的には､ その中のクエリが一致すればスコアが上がるということですが､ 一致する必要はありません｡

85
00:06:51,850 --> 00:06:56,980
つまり､ パセリを使ったレシピは､ パセリを使わないレシピよりも高得点になりやすいのです｡ 

86
00:06:57,250 --> 00:07:01,720
これは､ 他のクエリとのマッチングに依存するため､ 保証するものではありません｡ 

87
00:07:01,720 --> 00:07:05,590
しかし､ 嗜好を定義することができるオブジェクトと考えることもできます｡ 

88
00:07:05,830 --> 00:07:10,750
パセリ入りのレシピが好きだけど､ パセリ入りである必要はない､ みたいなね｡ 

89
00:07:11,350 --> 00:07:17,260
この結果を見ると､ 最初のレシピにはパセリが食材として含まれていることがわかるはずです｡ そして実際､

90
00:07:17,260 --> 00:07:18,430
その通りです｡

91
00:07:18,850 --> 00:07:25,390
先ほども言ったように､ パセリを使ったレシピが最高得点になる保証はありませんが､ 得点はアップします｡

92
00:07:25,780 --> 00:07:33,910
このshouldオブジェクトが少し特殊だと言ったのは､ その動作がプールクエリ全体とその中に含まれる他のものに依存するからです｡

93
00:07:34,180 --> 00:07:39,970
プールクエリがクエリコンテキスト内にあり､ must や filter オブジェクトを含む場合､ 検索クエリは､

94
00:07:39,970 --> 00:07:43,480
プールクエリ全体と一致する文書に一致する必要はない｡

95
00:07:44,020 --> 00:07:50,620
この場合､ 検索クエリの目的は､ マッチングした文書の関連性スコアに影響を与えることだけである｡

96
00:07:51,070 --> 00:07:56,950
一方､ プールクエリがフィルタリングコンテキストにある場合､ あるいは､ mustやfilterオブジェクトを持たない場合､

97
00:07:56,950 --> 00:08:00,670
少なくとも1つの検索クエリがマッチしなければならない｡

98
00:08:00,970 --> 00:08:08,390
それは､ 検索クエリは文書をブーストするためのもので､ クエリの集合にマッチしているが､ それでも文書は何らかの懸念を満たすものでなければならないからである｡

99
00:08:09,300 --> 00:08:12,690
そうでなければ､ インデックス内のすべての文書がマッチングされてしまう｡ 

100
00:08:12,780 --> 00:08:18,390
実際にこの動作を制御するには､ minimum underscore should underscore matchパラメータを使います｡

101
00:08:18,390 --> 00:08:21,960
このパラメータは､ いくつの短い句がマッチしなければならないかを定義します｡

102
00:08:22,380 --> 00:08:27,330
最もシンプルな使い方は､ 数値を指定することですが､ パーセンテージを定義することも可能です｡ 

103
00:08:27,330 --> 00:08:30,990
でも､ それはちょっとややこしくなるので､ 本当に必要なことなんです｡ 

104
00:08:31,500 --> 00:08:33,180
分かりにくいと思われましたか？

105
00:08:33,210 --> 00:08:35,460
ご心配なく､ それはよくわかります｡ 

106
00:08:35,580 --> 00:08:39,420
ここで､ 私が今言ったことを理解しやすくするために､ いくつかのクエリの例を示します｡ 

107
00:08:39,810 --> 00:08:46,260
まず､ パスタとパルメザンチーズを含む文書にマッチさせたい｡ 

108
00:08:46,320 --> 00:08:49,440
つまり､ それぞれマストクエリとサーチクエリということですね｡ 

109
00:08:50,520 --> 00:08:53,340
だから､ このクエリをコピーしておく｡ 

110
00:08:54,840 --> 00:08:56,490
そして､ それに合わせて修正｡ 

111
00:08:58,090 --> 00:09:00,070
だから､ フィルターをなくせばいいんです｡ 

112
00:09:02,880 --> 00:09:05,460
そして､ must not keyも｡ 

113
00:09:06,820 --> 00:09:13,210
そして､ 食材の中にパスタという言葉を入れて問い合わせたり､ パルメザンチーズを入れたりします｡ 

114
00:09:15,470 --> 00:09:15,970
なるほど｡ 

115
00:09:15,980 --> 00:09:16,970
そして実行しよう｡ 

116
00:09:18,250 --> 00:09:22,810
つまり､ このクエリは前に書いたものと似ていますが､ もう少しシンプルなものです｡ 

117
00:09:22,960 --> 00:09:29,260
パスタを素材にしたレシピにマッチし､ パルメザンチーズを使ったレシピに関連性を持たせることができます｡ 

118
00:09:29,410 --> 00:09:33,610
次に､ mustオブジェクトを完全に削除して､ その結果を検証してみましょう｡ 

119
00:09:35,180 --> 00:09:36,770
だから､ これを解消しよう｡ 

120
00:09:38,650 --> 00:09:40,000
そして､ もう一度クエリを実行します｡ 

121
00:09:40,360 --> 00:09:44,200
同じ数のマッチングを得るのですが､ 重要な違いがあります｡ 

122
00:09:44,200 --> 00:09:49,690
mustやfilterオブジェクトがなくなったので､ 少なくとも1つのshouldクエリがマッチしなければなりません｡ 

123
00:09:49,930 --> 00:09:52,450
この場合､ クエリ句は1つだけです｡ 

124
00:09:52,450 --> 00:09:55,810
ということは､ パルメザンチーズを使ったレシピでなければならないということです｡ 

125
00:09:56,170 --> 00:10:01,840
つまり､ 必須項目を削除することで､ パルメザンチーズという成分が､ オプションで関連するスコアを上げるものから､

126
00:10:01,840 --> 00:10:04,690
必須となることを意味するのです｡

127
00:10:05,140 --> 00:10:09,760
ここで､ 先ほど削除したクエリ句をフィルターオブジェクトの中に追加するとする｡ 

128
00:10:09,970 --> 00:10:16,780
そうすると､ パスタの成分が再び必要となり､ パルメザンの成分が再びオプションとなる｡

129
00:10:17,080 --> 00:10:21,490
パルメザンチーズを使ったレシピは､ その関連スコアがアップすることになります｡ 

130
00:10:21,970 --> 00:10:26,560
最初は少し戸惑うかもしれないので､ わかりやすくしてほしいです｡ 

131
00:10:26,710 --> 00:10:32,200
とにかく､ プールクエリを使ってクエリにブーリアンロジックを追加する方法でした｡ これは､

132
00:10:32,200 --> 00:10:36,880
リレーショナルデータベースなどで見たりやったりしたことがあるでしょう｡
