1
00:00:02,340 --> 00:00:07,440
マッチクエリについては､ フルテキストクエリのセクションで取り上げましたが､ クエリが内部でどのように動作しているか､

2
00:00:07,440 --> 00:00:08,520
疑問に思われましたか？

3
00:00:08,700 --> 00:00:09,780
たぶん､ ないと思います｡ 

4
00:00:09,780 --> 00:00:15,810
しかし､ matchクエリでは､ デフォルトのブール演算子であるof orをendに変更することもできることを思い出していただければ､

5
00:00:15,810 --> 00:00:19,050
私が何を言いたいのかがわかるかもしれません｡

6
00:00:19,650 --> 00:00:25,950
複合クエリには分類されないが､ 実はマッチクエリは内部でプールクエリを構成している｡ 

7
00:00:26,520 --> 00:00:29,220
これは分析プロセスの一部として行われます｡ 

8
00:00:29,220 --> 00:00:38,340
Fields Analyzerでクエリを解析した後､ 解析の結果得られたトークンをタームクエリとしてプールクエリに追加します｡

9
00:00:38,490 --> 00:00:45,690
つまり､ matchクエリはpoolクエリの便利なラッパーに過ぎず､ 一般的なクエリの記述を簡素化するものである｡

10
00:00:46,080 --> 00:00:51,600
つまり､ アプリケーション内で最初にクエリをトークン化して､ 本当にそうであることを示すためだけにプールクエリを構築する必要がなく､

11
00:00:51,600 --> 00:00:58,170
検索クエリを直接Elasticsearchに投げるだけでよいということです｡

12
00:00:58,200 --> 00:01:04,320
いくつかのマッチクエリを取り上げ､ マッチクエリが内部で翻訳する対応するプールクエリを書いてみよう｡

13
00:01:05,130 --> 00:01:09,150
では､ まずパスタのカルボナーラのタイトルを合わせてみましょう｡ 

14
00:01:09,720 --> 00:01:14,850
そこでタイトルの「フィールズ」と「パスタ・カルボナーラ」｡ 

15
00:01:16,170 --> 00:01:17,790
そして､ それを実行するだけです｡ 

16
00:01:18,420 --> 00:01:29,340
つまり､ マッチクエリのデフォルトの演算子はorなので､ このクエリは､ マッチクエリ内の各項目に対して1つの短いクエリ節を2つ持つプールクエリに変換されることを覚えておいてください｡

17
00:01:29,550 --> 00:01:33,390
このクエリを明示的に書き出して､ 両方のクエリを確認できるようにしましょう｡ 

18
00:01:34,360 --> 00:01:37,930
だから､ これをコピーしてクエリーを調整すればいいんです｡ 

19
00:01:38,050 --> 00:01:41,260
マッチクエリを廃止し､ プールクエリに変更する｡ 

20
00:01:42,900 --> 00:01:44,460
そして､ すべての人がそうであるように｡ 

21
00:01:45,440 --> 00:01:48,260
そして､ ここにオブジェクト内の用語クエリを追加します｡ 

22
00:01:48,980 --> 00:01:53,570
fieldsはタイトルフィールドで､ 値を直接指定することにします｡ 

23
00:01:54,080 --> 00:01:56,090
だから､ 価値はパスタなんです｡ 

24
00:01:57,090 --> 00:02:03,720
そして､ カルボナーラという言葉のクエリをもうひとつ追加しなければなりません｡ 

25
00:02:04,140 --> 00:02:06,270
そして､ このクエリを実行してみましょう｡ 

26
00:02:06,540 --> 00:02:09,870
つまり､ この2つのクエリは全く同じことをするのです｡ 

27
00:02:09,900 --> 00:02:15,090
結果は同じで､ 一致した文書の関連スコアも全く同じです｡

28
00:02:15,750 --> 00:02:18,840
最初のクエリをコピーして､ ブーリアン演算子を変えてみましょう｡ 

29
00:02:18,840 --> 00:02:19,530
だから終わり｡ 

30
00:02:23,730 --> 00:02:28,710
だから､ クエリをオブジェクトとして再構築する必要があるんだ｡ 

31
00:02:28,710 --> 00:02:31,200
代わりに､ クエリーキーを指定します｡ 

32
00:02:32,070 --> 00:02:36,990
そして､ そこにクエリを貼り付け､ endという値を持つoperatorパラメータを追加します｡ 

33
00:02:37,560 --> 00:02:40,440
このクエリに相当するものが何だかわかりますか？

34
00:02:40,710 --> 00:02:45,360
各タームがマストオブジェクト内のタームクエリに変換されたプルクエリ｡ 

35
00:02:47,190 --> 00:02:50,940
だから､ ちょっとだけ入力の手間を省くために､ これをコピーしておく｡ 

36
00:02:52,170 --> 00:02:53,670
そして､ それを少し前倒しにしてみましょう｡ 

37
00:02:55,670 --> 00:03:00,800
そして､ shoulds配列の代わりにmustに変えてみる｡ 

38
00:03:00,980 --> 00:03:01,880
そして､ それだけです｡ 

39
00:03:02,330 --> 00:03:05,600
では､ まずここでこのクエリを実行してみましょう｡ 

40
00:03:06,360 --> 00:03:11,760
そして､ これを実行してみると､ もう一度､ 同じ結果が得られることがわかります｡ 

41
00:03:12,300 --> 00:03:17,130
pool query と同様に､ match query でも minimum underscore should underscore

42
00:03:17,130 --> 00:03:21,660
match パラメータを受け取り､ いくつの短文節がマッチするかを設定することができる｡

43
00:03:22,080 --> 00:03:26,640
このパラメータは､ 解析処理中にプールクエリに渡されるだけである｡ 

44
00:03:27,270 --> 00:03:29,280
では､ もう1つだけ｡ 

45
00:03:29,520 --> 00:03:34,860
マッチクエリは解析され､ タームクエリは解析されないので､ 大文字と小文字の区別などの問題がないため､

46
00:03:34,860 --> 00:03:38,910
この仕組みが不思議に思われるかもしれません｡

47
00:03:39,330 --> 00:03:41,820
いいえ､ 実はこれは問題ではありません｡ 

48
00:03:41,820 --> 00:03:47,190
解析処理の結果に基づいて､ 用語クエリを構築しているからである｡ 

49
00:03:47,520 --> 00:03:56,280
そのため､ マッチしたクエリは適切な分析プロセスを経て､ クエリを小文字にするなど､ 分析器が設定する方法でトークン化されます｡

50
00:03:56,910 --> 00:04:03,750
したがって､ 用語クエリに使用される用語は分析されており､ したがって転置インデックス内に格納されているものと一致する｡

51
00:04:04,200 --> 00:04:07,680
最後に書いた2つのクエリで簡単にテストすることができます｡ 

52
00:04:08,070 --> 00:04:12,180
マッチクエリ内のパスタという用語を大文字にして､ 何が起こるか見てみましょう｡ 

53
00:04:13,020 --> 00:04:17,460
では､ これを大文字のPに変えて､ クエリを実行してみましょう｡ 

54
00:04:18,000 --> 00:04:24,690
クエリの解析が行われ､ その過程でクエリを小文字にする処理が行われるため､ 同じ結果が得られます｡

55
00:04:24,810 --> 00:04:29,400
対応するプール・クエリについても同じようにして､ 違いがあるかどうか試してみましょう｡ 

56
00:04:30,600 --> 00:04:34,170
そこで､ これを大文字のPに変えて､ クエリを実行してみます｡ 

57
00:04:35,270 --> 00:04:37,460
現在は､ マッチングが取れなくなりました｡ 

58
00:04:37,460 --> 00:04:39,170
では､ これはどういうことなのか｡ 

59
00:04:39,410 --> 00:04:48,470
大文字の単語を含むマッチクエリを供給しても､ それはプールクエリを構成するための解析処理の結果であるということだ｡

60
00:04:48,680 --> 00:04:56,330
この例では､ 解析の結果､ pastaとcarbonaraという2つの単語が得られ､ トークン・フィルターで小文字に変換される｡

61
00:04:56,720 --> 00:05:00,650
その結果得られた用語は､ プールクエリ内の用語クエリに使用される｡ 

62
00:05:00,650 --> 00:05:06,800
つまり､ 本質的にアナライズドクエリでアナライズドデータを検索しているので､ 同じようにマッチングするわけです｡

63
00:05:07,370 --> 00:05:13,610
そこで重要なことを簡単におさらいすると､ Elasticsearchにマッチクエリを送ると､ クエリが分析され､

64
00:05:13,640 --> 00:05:20,480
分析過程で出てきた各タームについて､ プールクエリにタームクエリ句が追加されるのです｡

65
00:05:20,720 --> 00:05:26,810
boolean演算子がデフォルトのorの場合､ 用語はshortオブジェクト内の用語クエリ句として追加され､

66
00:05:26,810 --> 00:05:30,620
少なくともどちらかがマッチする必要があることを意味します｡

67
00:05:30,950 --> 00:05:36,590
booleanオペレータが終了すると､ 用語､ クエリがmustオブジェクト内に追加され､ ドキュメントがマッチするために与えられたフィールドに対してそれらすべてが存在する必要があることを意味する､

68
00:05:36,590 --> 00:05:40,400
と言われています｡

69
00:05:41,000 --> 00:05:47,990
クエリを解析しているので､ 解析プロセスの観点からの結果がタームクエリロスに使われるのである｡

70
00:05:48,020 --> 00:05:53,450
これは､ クエリが転置インデックス内に格納されているものと同じアナライザを通過したことを意味する｡ 

71
00:05:53,720 --> 00:05:58,250
しかし､ マッチクエリが1つの単語からなるクエリしか受け取らない場合はどうでしょうか｡ 

72
00:05:58,550 --> 00:06:04,550
その場合､ プールクエリを使うのはあまり意味がないので､ 代わりに単項クエリが使われる｡ 

73
00:06:04,790 --> 00:06:08,570
それは､ プールクエリの中にネストされていないタームクエリである｡ 

74
00:06:09,020 --> 00:06:11,630
そして､ これがマッチクエリの内部動作です｡ 

75
00:06:11,900 --> 00:06:15,290
また､ これで複合クエリに関するこのセクションは終わりです｡ 

76
00:06:15,650 --> 00:06:19,880
今回取り上げた以外にもいくつかの複合クエリがありますが､ 関連するスコアのチューニングについては､

77
00:06:19,880 --> 00:06:22,790
また後日紹介します｡
