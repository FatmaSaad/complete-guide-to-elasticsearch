1
00:00:02,580 --> 00:00:08,220
Explain APIを使ったクエリのデバッグ方法については､ 講座の初期に説明したのを覚えていますか？

2
00:00:08,310 --> 00:00:13,230
このAPIは､ ある文書がクエリにマッチした､ あるいはマッチしなかった理由を理解するのに役立つ｡ 

3
00:00:13,500 --> 00:00:18,750
特にプルクエリについては､ 名前付きクエリを使用することで､ 同様のことが可能です｡ 

4
00:00:18,780 --> 00:00:22,770
これにより､ 文書がどのクエリクラスにマッチしたかを確認することができる｡ 

5
00:00:23,160 --> 00:00:28,680
もちろん､ must notやfilterといったクエリについては､ すべてのドキュメントで同じ動作をするため､

6
00:00:28,680 --> 00:00:29,730
この機能は必要ない｡

7
00:00:30,000 --> 00:00:37,050
これは､ 文書がどのような短いクラスにマッチするかを見て､ 関連するスコアの意味を理解しようとするときに便利である｡

8
00:00:37,410 --> 00:00:43,320
もちろん､ より詳細な情報が必要な場合は､ 説明されているAPIを使用することも可能です｡

9
00:00:43,350 --> 00:00:49,290
つまり､ 各クエリ句にアンダースコア名というパラメータを追加して､ 名前をつけるという方法です｡

10
00:00:49,590 --> 00:00:52,020
そのため､ 少し物事を動かす必要があります｡ 

11
00:00:52,020 --> 00:00:56,820
つまり､ フィールド名を含むキーには､ クエリそのものではなく､ オブジェクトが含まれているのです｡ 

12
00:00:57,330 --> 00:01:02,400
では､ さっそく前回の講義で出てきたクエリに､ それぞれのクエリクラスに名前をつけてみましょう｡ 

13
00:01:03,390 --> 00:01:13,500
そこで､ ここではParmesanを直接指定するのではなく､ 値をオブジェクトに変更し､ 代わりにParmesanを使ったクエリキーを追加することにします｡

14
00:01:13,860 --> 00:01:19,180
そして､ ここにアンダースコアの名前キーを追加して､ 任意の名前を付けることができます｡ 

15
00:01:19,200 --> 00:01:26,130
パルメザンチーズをアンダースコアで書くと､ 結果の中ですぐにわかるようになりますね｡ 

16
00:01:26,310 --> 00:01:30,000
そして､ 他のクエリクラスについても全く同じようにします｡ 

17
00:01:30,690 --> 00:01:32,760
まず､ must not clause｡ 

18
00:01:33,330 --> 00:01:34,770
だからクエリ｡ 

19
00:01:36,030 --> 00:01:36,720
マグロです｡ 

20
00:01:37,980 --> 00:01:38,580
アンダースコア

21
00:01:38,580 --> 00:01:39,180
名前

22
00:01:39,990 --> 00:01:40,650
マグロです｡ 

23
00:01:40,650 --> 00:01:41,310
アンダースコア

24
00:01:41,310 --> 00:01:41,730
なければならない｡ 

25
00:01:41,730 --> 00:01:42,310
アンダースコア

26
00:01:42,330 --> 00:01:42,900
ない｡ 

27
00:01:43,710 --> 00:01:45,570
ここでシャツを脱ぐことに｡ 

28
00:01:47,320 --> 00:01:51,910
では､ パセリ......流石にこれは移しましょう｡ 

29
00:01:53,140 --> 00:02:00,370
そして､ ここでもスコアネームにパセリを書きます｡ 

30
00:02:02,070 --> 00:02:07,550
そして最後に､ このフィルター節内でも同じことをやってみましょう｡ 

31
00:02:07,560 --> 00:02:11,730
しかし､ これはすでにオブジェクトなので､ アンダースコアの名前キーを追加するだけでいいのです｡ 

32
00:02:12,770 --> 00:02:14,390
もちろん､ キャリアの名前であること｡ 

33
00:02:14,390 --> 00:02:15,260
そして､ それに名前をつける｡ 

34
00:02:15,260 --> 00:02:16,040
プレップ

35
00:02:16,790 --> 00:02:17,990
アンダースコア・タイム

36
00:02:17,990 --> 00:02:19,340
アンダースコア・フィルター

37
00:02:19,640 --> 00:02:22,070
では､ このクエリを実行してみましょう｡ 

38
00:02:22,460 --> 00:02:27,980
そして､ その結果には､ 各文書の結果内のマッチクエリというキーが表示されます｡ 

39
00:02:28,010 --> 00:02:30,680
では､ それを探してみよう｡ 

40
00:02:31,250 --> 00:02:36,680
一致したアンダースコアのクエリのキーは､ ドキュメントが一致したクエリ名の配列となります｡ 

41
00:02:36,890 --> 00:02:42,800
つまり､ 最初のマッチは､ ここにあるように､ 必須とフィルターの両方の粗悪な損失にマッチし､

42
00:02:42,800 --> 00:02:45,800
検索クエリにもマッチしたのです｡

43
00:02:46,130 --> 00:02:51,110
2番目のマッチまでスクロールすると､ 検索クエリではなく､ 必須のリクルートクラスのみにマッチしており､

44
00:02:51,110 --> 00:02:56,030
パセリを含むレシピに関連する後押しをしていることがわかります｡

45
00:02:56,120 --> 00:03:02,690
これは､ 1つ目のレシピはパセリが入っているから得点が高く､ 2つ目のレシピはパセリが入っていないから得点が低いということを示しています｡

46
00:03:02,990 --> 00:03:08,240
そして､ プールクエリのデバッグに名前付きクエリを使用することで､ プールクエリのどの部分が､ 与えられたドキュメントとマッチしたのか､

47
00:03:08,240 --> 00:03:10,910
いくつかの洞察を得ることができるというわけだ｡

48
00:03:10,910 --> 00:03:16,280
それを使って､ たとえばある文書が別の文書よりも高い確率でマッチングした理由を探ることができるのです｡
