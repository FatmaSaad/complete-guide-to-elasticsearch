1
00:00:02,300 --> 00:00:06,170
先ほどは､ 日付のクエリ方法など､ 範囲のクエリについて見てきました｡ 

2
00:00:06,170 --> 00:00:11,150
しかし､ ここでは､ データを照会する際に日付をどのように扱うかについて､ もう少し深く掘り下げて考えてみたいと思います｡ 

3
00:00:11,570 --> 00:00:18,470
特定の日付を指定する以外に､ 日付計算と呼ばれる相対的な日付も利用できる｡

4
00:00:18,860 --> 00:00:26,000
これはレンジクエリに限ったことではなく､ Elasticsearchの他の部分でも日付マップを使用することができます｡

5
00:00:26,000 --> 00:00:29,960
しかし､ 今回は範囲クエリの文脈で日付計算を使う方法を示します｡ 

6
00:00:30,410 --> 00:00:35,960
この目的のために､ 私はいくつかの日付の計算で修正される単純な範囲のクエリをロードしています｡ 

7
00:00:36,200 --> 00:00:41,020
その方法は､ アンカー日付からなる日付式を指定することである｡ 

8
00:00:41,030 --> 00:00:49,730
まず､ アンカーポイントとは､ 日付計算の基準としたい時点のことである｡

9
00:00:49,730 --> 00:00:49,730
e. が､ いわば出発点です｡ 

10
00:00:50,270 --> 00:00:57,650
このアンカーの日付は､ キーワード「now」と､ 範囲指定クエリ「now」にあるような日付文字列の2つの形式のうち､ どちらかを選択することができます｡

11
00:00:58,280 --> 00:01:02,280
もし､ 日付文字列を使うのであれば､ 最後にパイプ記号を2つ追加する必要があります｡ 

12
00:01:02,300 --> 00:01:07,640
これは､ 式を渡すときにElasticsearchを助けるために､ アンカーデイトの終わりを示すだけです｡ 

13
00:01:07,640 --> 00:01:11,660
だから､ 論理的とか､ プログラミング言語のようなことは関係ないんです｡ 

14
00:01:11,780 --> 00:01:13,910
では､ そのパイプを日付に追加してみましょう｡ 

15
00:01:15,450 --> 00:01:16,170
そうそう｡ 

16
00:01:16,860 --> 00:01:21,810
そこで､ この部分を明確にするために､ ちょうどここにアンカーの日付があります｡ 

17
00:01:22,050 --> 00:01:30,750
次に来るのは､ 日付や時間の単位が日､ 月､ 分などであることを利用した特殊な形式の数式である｡

18
00:01:31,080 --> 00:01:38,790
例えば､ 1日足すにはプラス1DD､ 2週間引くにはマイナス2Wと書きます｡ 

19
00:01:39,210 --> 00:01:43,350
この数式は､ 指定したアンカー日からの相対値である｡ 

20
00:01:43,890 --> 00:01:47,460
指定したデータから1年分を引いてみましょう｡ 

21
00:01:47,850 --> 00:01:52,980
そのためには､ 年号のようにYをマイナス1つ書けばいいわけです｡ 

22
00:01:53,580 --> 00:01:55,020
これを実行しよう｡ 

23
00:01:56,000 --> 00:02:00,920
その結果を見ると､ 今度は2009年に作られた製品が表示されているはずです｡ 

24
00:02:01,430 --> 00:02:05,270
では､ スクロールして､ この製品のを探してみましょう｡ 

25
00:02:07,760 --> 00:02:08,630
これでよしとしよう｡ 

26
00:02:09,170 --> 00:02:14,510
これは､ 2010年のアンカーデートを使用したため､ 日付の計算が確かに機能していることを証明しています｡ 

27
00:02:15,020 --> 00:02:20,600
そこで､ 指定したアンカー日付からの相対的な日付を含む文書をマッチングさせただけである｡ 

28
00:02:20,720 --> 00:02:24,800
しかし､ 代わりに1年と1日を引きたいとしたらどうだろう｡ 

29
00:02:25,160 --> 00:02:28,430
この式にマイナス1個のdxを付ければよいのである｡ 

30
00:02:28,430 --> 00:02:33,770
つまり､ マイナス1tは1年と1日を引くという意味です｡ 

31
00:02:34,400 --> 00:02:37,700
動作証明のためにクエリを実行してみます｡ 

32
00:02:38,390 --> 00:02:41,450
やろうと思えば､ さらに式を追加することも可能だ｡ 

33
00:02:41,930 --> 00:02:47,030
年や日を指定する方法を見ただけですが､ 他にも日付や時間の単位を指定することができます｡ 

34
00:02:47,540 --> 00:02:53,180
利用可能なすべての日付と時間の単位を見つけることができるドキュメントへのリンクを添付しています｡

35
00:02:53,600 --> 00:02:57,050
コンセプトは変わらないので､ ここですべてを紹介することはしません｡ 

36
00:02:57,050 --> 00:03:00,290
月､ 年､ 分など､ どれを使ってもよい｡ 

37
00:03:00,770 --> 00:03:05,450
しかし､ ここで紹介したいのは､ 実は日付も切り捨てることができるということです｡ 

38
00:03:05,780 --> 00:03:09,920
そのためには､ フォワードスラッシュと日付または時間単位を付加する｡ 

39
00:03:10,250 --> 00:03:18,710
例えば､ クエリで時刻を含む日付を指定する場合､ スラッシュdxを付加して時刻を真夜中に丸めることができる｡

40
00:03:18,740 --> 00:03:25,280
日付の表現で注意すべきことは､ 一般的な値は町の周辺にありますが､ 範囲クエリのコンテキストでは､

41
00:03:25,280 --> 00:03:29,990
丸めは日付が追加されるパラメータに依存するということです｡

42
00:03:30,410 --> 00:03:39,200
次の表は､ 範囲演算子の概要と丸め方向､ および日付の月単位での丸め方の例を示しています｡

43
00:03:39,650 --> 00:03:43,460
その差は､ 値を含めるか含めないかの違いである｡ 

44
00:03:43,760 --> 00:03:48,320
そのため､ greater than演算子を使う場合は､ 値が切り上げられる｡ 

45
00:03:48,680 --> 00:03:51,830
通常は､ 午前0時を意味する日単位でラウンドすることになります｡ 

46
00:03:51,830 --> 00:03:56,810
しかし､ この例は､ その方が表示しやすいので､ 四捨五入して月単位で表示するためのものです｡ 

47
00:03:57,290 --> 00:04:02,360
この場合､ 値は切り上げられる｡ これは､ 日単位で丸めるのであれば､ 最終日も含めて丸めたいので､

48
00:04:02,360 --> 00:04:10,340
理にかなっている｡ e. を含まない場合は､ 0 時の 1 ミリ秒前まで切り上げる｡

49
00:04:10,340 --> 00:04:15,080
切り捨てられているので､ 日単位で四捨五入していると実質的に日を除外してしまうことになります｡ 

50
00:04:15,800 --> 00:04:20,450
LC演算子､ LCE演算子の場合は全く逆である｡ 

51
00:04:20,660 --> 00:04:27,830
これらの例では日付のみを指定していますが､ Elasticsearchは内部で時刻の値も処理することに注意してください｡

52
00:04:28,160 --> 00:04:34,010
これは､ Elasticsearchがエポックからのミリ秒数に基づいて日付を保存・計算するためです｡

53
00:04:34,430 --> 00:04:43,820
つまり､ 切り上げるときは午前0時の1ミリ秒前に､ 切り下げるときは午前0時に設定されることになる｡

54
00:04:43,820 --> 00:04:43,820
e. はすべてゼロ｡ 

55
00:04:44,680 --> 00:04:45,130
なるほど｡ 

56
00:04:45,130 --> 00:04:51,100
さて､ レンジクエリの文脈で値がどのように丸められるのかがわかったところで､ 例を挙げてみましょう｡

57
00:04:51,640 --> 00:04:57,460
この例のクエリでは､ 日付に時間部分を指定したり､ 直近の月に丸めたりしなかったので､

58
00:04:57,460 --> 00:05:03,160
代わりに､ 式を読みやすくするために､ 1日分の減算を削除してみます｡

59
00:05:03,850 --> 00:05:10,630
小文字のmは月ではなく分を表すので､

60
00:05:10,630 --> 00:05:15,190
大文字のMを使用する｡

61
00:05:16,080 --> 00:05:17,520
そして実行しよう｡ 

62
00:05:18,000 --> 00:05:24,120
さて､ 実際にはマッチ・ドキュメントには何の変更もありませんが､ ポイントは構文を示すだけです｡

63
00:05:24,480 --> 00:05:28,290
日単位で四捨五入するなら､ スラッシュのtを書けばよかったのです｡ 

64
00:05:28,980 --> 00:05:31,080
では､ 面白いものをお見せしましょう｡ 

65
00:05:31,290 --> 00:05:35,250
丸めは必ずしも式の末尾に置く必要はない｡ 

66
00:05:35,430 --> 00:05:41,700
また､ アンカー日付の加算や減算の前に丸めを行いたい場合は､ 先頭に置くこともできます｡

67
00:05:42,000 --> 00:05:47,070
そこで､ スラッシュのmを削除して､ このように先頭に移動してみましょう｡ 

68
00:05:47,610 --> 00:05:51,090
この場合､ 1年分を差し引く前に月単位で四捨五入しているのです｡ 

69
00:05:51,390 --> 00:05:55,230
また､ GC演算子を使用しているため､ 値は切り捨てられます｡ 

70
00:05:55,440 --> 00:06:00,450
しかし､ 仮にGC演算子を使っていたとすると､ その場合､ 値は切り上げられる｡ 

71
00:06:00,870 --> 00:06:07,900
その場合､ 日付は2010年1月21日午前0時の1ミリ秒前に切り上げられる｡

72
00:06:07,920 --> 00:06:10,290
そして､ 1年分が差し引かれることになる｡ 

73
00:06:10,590 --> 00:06:13,950
つまり､ 四捨五入は1年分を引く前に行われることになる｡ 

74
00:06:14,550 --> 00:06:17,310
さて､ もうひとつだけお見せしたいものがあります｡ 

75
00:06:17,940 --> 00:06:24,000
先ほど､ アンカーの日付には､ この例のような日付と､ キーワード「now」のどちらかを含めることができると述べました｡

76
00:06:24,270 --> 00:06:29,730
そこで､ 日付の計算を現在のタイムスタンプからの相対的なものにするには､ 日付をnowに置き換えて､

77
00:06:29,730 --> 00:06:33,630
2本のパイプは不要になるので削除すればよいことになる｡

78
00:06:33,990 --> 00:06:35,670
まあ､ 実際､ そうせざるを得ないんですけどね｡ 

79
00:06:35,700 --> 00:06:37,230
または､ クエリーが機能しない｡ 

80
00:06:37,560 --> 00:06:38,700
では､ そうしましょう｡ 

81
00:06:39,090 --> 00:06:43,920
そこで､ この部分をここで削除し､ 代わりに今を挿入することにします｡ 

82
00:06:44,630 --> 00:06:46,280
そして実行しよう｡ 

83
00:06:47,160 --> 00:06:49,740
その他､ お見せしたものはすべてそのままです｡ 

84
00:06:49,740 --> 00:06:54,120
つまり､ 現在時刻を基準に日付を計算しているだけの違いなのです｡ 

85
00:06:54,540 --> 00:07:02,130
つまり､ アプリケーションからElasticsearchに現在のタイムスタンプを送る必要はなく､ Elasticsearchにこの力を任せればいいのです｡

86
00:07:02,610 --> 00:07:07,530
また､ 現在のタイムスタンプを使うために､ 実際には日付の足し算や引き算をする必要はないのです｡ 

87
00:07:07,650 --> 00:07:13,920
もし､ 現在の時刻を参照させたいだけなら､ 式にnowと入力し､ それ以外のことは省略すればよい｡

88
00:07:14,310 --> 00:07:19,230
ですから､ この部分を削除しても､ クエリーはまったく問題なく動作するのです｡ 

89
00:07:20,180 --> 00:07:23,300
そして､ これがElasticsearchで状態計算を行う方法です｡ 

90
00:07:23,330 --> 00:07:29,870
先ほども言いましたが､ これはレンジクエリに限ったことではなく､ 日付計算を使用する際の非常に一般的なコンテキストです｡

91
00:07:30,170 --> 00:07:36,380
利用可能なすべての日付と時間の単位を確認したい場合は､ この講義に添付されているリンクをチェックすることを忘れないでください｡
