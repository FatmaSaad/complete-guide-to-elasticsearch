1
00:00:02,310 --> 00:00:08,040
各文書にアンダースコアのスコアフィールドが含まれる検索結果をいくつか見てみたところです｡ 

2
00:00:08,190 --> 00:00:15,960
検索結果は､ 関連性の高い順に並べられ､ 最も関連性の高いものが検索結果内で最初に表示されることは既に述べた｡

3
00:00:16,440 --> 00:00:22,200
一致する文書を含めるだけでなく､ 関連性のある結果を人々に提供することに関心があるため､

4
00:00:22,200 --> 00:00:26,340
関連性に基づいて結果を検索できることが必要なのです｡

5
00:00:26,670 --> 00:00:32,760
これは､ 一般的にリレーショナルデータベースなどのデータベースシステムとは対照的で､ 彼らは行がどのように一致するかを判断する必要はありません返すので､

6
00:00:32,760 --> 00:00:38,580
Elasticsearchは行います｡

7
00:00:38,580 --> 00:00:41,750
このエンドは､ マッチの関連性を決定します｡ 

8
00:00:41,760 --> 00:00:51,270
そこで､ マッチの関連性を計算する前に､ Elasticsearchはいわゆるブールモデルを使って､ ドキュメントがそもそもクエリにマッチしているかどうかを判断します｡

9
00:00:51,600 --> 00:00:57,600
これはもちろん､ どうせ結果の一部にはならない文書の関連スコアを計算する必要がないようにするためである｡

10
00:00:58,290 --> 00:01:04,590
関連性は､ ご覧の通り､ アンダースコアのスコアフィールドで表現され､ 浮動小数点数を保持します｡

11
00:01:04,920 --> 00:01:10,320
ここで､ Elasticsearchが検索クエリにマッチした場合のスコアを計算する方法について､ もう少し掘り下げてみたいと思います｡

12
00:01:10,800 --> 00:01:16,860
その方法は､ 検索クエリの種類によって異なり､ 自分でアルゴリズムを変更することも可能です｡

13
00:01:16,860 --> 00:01:19,770
しかし､ その仕組みの全体像を紹介します｡ 

14
00:01:20,250 --> 00:01:28,800
Elasticsearchでは､ 最近までF slash IDFというterm frequencyの略のアルゴリズムを使用していました｡

15
00:01:28,800 --> 00:01:30,780
逆文書頻度｡ 

16
00:01:31,050 --> 00:01:35,190
ここで､ Okapi BM 25というアルゴリズムが使用されます｡ 

17
00:01:35,490 --> 00:01:41,790
このアルゴリズムは旧来のものと共通する部分が多いので､ 旧来のアルゴリズムの仕組みを説明した上で､

18
00:01:41,790 --> 00:01:45,900
BM25が追加した違いを説明します｡

19
00:01:45,990 --> 00:01:49,860
それでは､ スコアを算出する際に使用される要素について説明します｡ 

20
00:01:50,400 --> 00:01:53,070
まず､ 用語頻度と呼ばれるものがあります｡ 

21
00:01:53,370 --> 00:01:59,130
これは､ 特定の文書を検索している分野で､ 指定した用語が何回出現しているかを調べるものです｡

22
00:01:59,520 --> 00:02:04,410
用語の出現回数が多ければ多いほど､ 少なくともその用語に対する関連性が高い文書である｡ 

23
00:02:04,890 --> 00:02:11,850
たとえば､ salad 2回という用語を含むタイトルフィールドがあるとします｡

24
00:02:12,510 --> 00:02:19,320
これは､ サラダという言葉が一度しか登場しない場合や､ その分野で全く登場しない場合よりも､ 高い関連性を示しています｡

25
00:02:19,650 --> 00:02:24,330
つまり､ フィールド内にある用語の出現回数が多いほど､ 関連性スコアが高くなるわけです｡ 

26
00:02:24,930 --> 00:02:28,350
2つ目の要因は､ 逆文書頻度である｡ 

27
00:02:28,590 --> 00:02:32,280
これは､ ある用語がインデックス内に出現する頻度を意味する｡ 

28
00:02:32,730 --> 00:02:37,350
例えば､ 商品インデックスにサラダという言葉が何回出てくるか､ といった具合だ｡ 

29
00:02:37,680 --> 00:02:41,460
用語の出現頻度が高いほど､ スコアと関連性が低くなります｡ 

30
00:02:41,730 --> 00:02:46,890
ここでいう論理とは､ ある用語が多くの文書に出現する場合､ その重みは低くなるというものである｡ 

31
00:02:47,340 --> 00:02:54,600
つまり､ der, this, ifなどのように､ 何度も登場する単語はあまり意味がないのです｡

32
00:02:54,780 --> 00:03:02,280
つまり､ ある文書にその用語が含まれていて､ それがその分野の一般的な用語でなければ､ その文書が関連性があるという信号となるわけです｡

33
00:03:02,910 --> 00:03:05,850
最初の因子は､ フィールド長ノルムと呼ばれる｡ 

34
00:03:06,000 --> 00:03:08,730
これは､ 単純にフィールドの長さを指しています｡ 

35
00:03:08,760 --> 00:03:13,200
フィールドが長いほど､ フィールド内の単語が関連する可能性は低くなります｡ 

36
00:03:13,590 --> 00:03:21,120
例えば､ 50文字のタイトルに含まれるサラダという言葉は､ 5000文字の説明文に含まれるよりも重要である｡

37
00:03:21,510 --> 00:03:26,070
したがって､ 短い分野に現れる用語は､ 長い分野に現れるよりも重みがある｡ 

38
00:03:26,490 --> 00:03:33,000
用語頻度､ 逆文書頻度､ フィールド長ノルムをインデックス時間iで計算し､

39
00:03:33,000 --> 00:03:36,450
格納する｡ e. 文書が追加・更新されたとき｡ 

40
00:03:36,900 --> 00:03:42,150
これらの保存された値は､ 特定の文書に対するある単語の重みを計算するために使われる｡ 

41
00:03:42,750 --> 00:03:48,360
個々のクエリには､ タイポを考慮した用語の近接度やフシギ度など､ マッチングのスコアを計算するための他の要素を含めることができますが､

42
00:03:48,360 --> 00:03:54,000
これらはいずれもコースの後半で説明します｡

43
00:03:54,450 --> 00:03:58,170
以上が､ TTFスラッシュIDFアルゴリズムの基本でした｡ 

44
00:03:58,470 --> 00:04:05,190
もちろん､ これ以外にも理論はあるのですが､ ここではBM25のアルゴリズムがどのように比較されているかに注目しましょう｡

45
00:04:05,460 --> 00:04:11,610
そのためには､ ちょっとした文脈､ 特に前のセクションで説明したストップワードが必要である｡ 

46
00:04:12,030 --> 00:04:13,720
記憶を呼び覚ますために｡ 

47
00:04:13,740 --> 00:04:22,020
ストップワードとは､ 文書中に何度も出現し､ 検索クエリとの関連性を判断する材料にならない単語のことである｡

48
00:04:22,470 --> 00:04:25,080
では､ なぜ今ストップワードの話をするのか｡ 

49
00:04:25,230 --> 00:04:35,370
というのも､ 以前はテキストフィールドを分析する際にストップワードを削除するのが一般的で､ その理由は「どうせ関連性を計算するための手がかりにはならないから」でした｡

50
00:04:35,850 --> 00:04:41,820
その後､ ストップワードの価値は限定的ではあるが､ それなりの価値があるため､ 変更となった｡

51
00:04:42,120 --> 00:04:45,450
そのため､ ストップワードを除去することは､ もはやあまり一般的ではありません｡ 

52
00:04:45,450 --> 00:04:51,120
標準のアナライザーでストップトークンフィルタがデフォルトで無効になっているのもこのためです｡ 

53
00:04:51,630 --> 00:05:00,750
そうしないと､ ストップワードを多く含む大規模なフィールドで､ ストップワードの重みが人為的に増加することになるからだ｡

54
00:05:01,080 --> 00:05:01,890
例えば､ こんな感じです｡ 

55
00:05:02,000 --> 00:05:07,550
本のテキストを含む文書は､ 内容がFスラッシュIDFアルゴリズムでロギングされるため､

56
00:05:07,550 --> 00:05:11,750
フィールド用のストップワードがたくさんあることになる｡

57
00:05:11,780 --> 00:05:17,450
そうすると､ ストップワードが何度も出てくるので､ 必要以上にブーストされてしまうことが多いのです｡

58
00:05:18,110 --> 00:05:25,490
Beam25では､ 非線形項周波数飽和という超豪華なものを使って､ この問題を解決しています｡ 

59
00:05:25,880 --> 00:05:26,330
すごい｡ 

60
00:05:26,330 --> 00:05:28,010
すごい音だったでしょう？

61
00:05:28,430 --> 00:05:32,450
幸いなことに､ それを理解することは､ それほど複雑なことではありません｡ 

62
00:05:32,930 --> 00:05:40,160
PM25では､ 用語の出現回数によってブーストの上限を決めているということです｡

63
00:05:40,340 --> 00:05:47,780
ある言葉が5〜10回出現した場合､ 1〜2回しか出現しなかった場合よりも､ 関連性に与える影響はかなり大きくなる｡

64
00:05:47,900 --> 00:05:54,020
しかし､ 出現回数が増えると関連性のブーストはすぐに小さくなり､ 例えば1000回出現した用語のブーストは､

65
00:05:54,020 --> 00:06:00,320
30回出現した場合とほとんど同じになることを意味している｡

66
00:06:00,830 --> 00:06:02,440
図で見ることができます｡ 

67
00:06:02,450 --> 00:06:10,850
TFスラッシュのIDFアルゴリズムは､ 最初を除いてほぼ直線的ですが､ M25のラインはすぐに平らになってしまうのでしょうか｡

68
00:06:11,270 --> 00:06:19,820
つまり､ ストップワードがあっても､ 以前のアルゴリズムのように関連スコアの計算で問題が発生することはないのです｡

69
00:06:20,390 --> 00:06:27,200
次に､ PM25のアルゴリズムでも改善されている､ いわゆるフィールド長ノルムについてお話しました｡ 

70
00:06:27,230 --> 00:06:34,970
PM25のアルゴリズムは､ あるフィールドをすべての文書で同じように扱うのではなく､ 各フィールドを個別に考慮します｡

71
00:06:35,150 --> 00:06:43,670
これは､ フィールドの平均的な長さを考慮することで､ 例えば､ 短いタイトルフィールドと長いタイトルフィールドを区別することができることを意味します｡

72
00:06:44,360 --> 00:06:50,510
それとは別に､ 2つのパラメータをチューニングすることでPM25を設定することもできますが､ 今は割愛します｡

73
00:06:50,900 --> 00:06:56,210
これらの改善は微妙に思えるかもしれませんが､ 関連する採点は多くの微調整が必要なもので､ これらの改善は､

74
00:06:56,210 --> 00:07:01,640
それほど印象的でないように思えるかもしれませんが､ 実は非常に大きなものなのです｡

75
00:07:02,060 --> 00:07:12,650
つまり､ デフォルトでは､ 関連性スコアは用語の頻度を考慮して計算される､ ということを再確認してください｡

76
00:07:12,650 --> 00:07:12,650
e. その用語が特定の分野でどれくらいの頻度で出現しているか｡ 

77
00:07:12,830 --> 00:07:15,860
回数が多ければ多いほど､ 関連性の高いドキュメントになります｡ 

78
00:07:16,310 --> 00:07:22,610
逆文書頻度は､ インデックス内の特定のフィールドに対して､ 与えられた用語がどのくらいの頻度で出現するかを調べるものである｡

79
00:07:22,610 --> 00:07:24,710
だから､ インデックス・ドキュメントのすべて｡ 

80
00:07:24,980 --> 00:07:29,210
用語の出現回数が多いほど､ 関連性が低いと判断されます｡ 

81
00:07:29,570 --> 00:07:31,790
3つ目の要因は､ フィールドの長さです｡ 

82
00:07:31,820 --> 00:07:35,390
フィールドが短いほど､ その用語の意味が大きいと考えられる｡ 

83
00:07:35,780 --> 00:07:43,070
PM25のアルゴリズムはその辺を少し拡張しているので､ 今回のまとめは簡略化したものですが､ とにかく基本的な考え方はこれだけです｡

84
00:07:43,700 --> 00:07:46,850
この講演を終える前に､ もう2つ触れておきたいことがあります｡ 

85
00:07:46,880 --> 00:07:51,530
まず､ クエリ内のスコアリングに影響を与えることで関連性を変更する方法があることがわかりますが､

86
00:07:51,530 --> 00:07:56,780
Elasticsearchのスコア計算方法を変更することも可能です｡

87
00:07:57,200 --> 00:08:01,730
とはいえ､ それはかなり高度な話になるので､ そうする必要があるのは稀でしょう｡ 

88
00:08:02,060 --> 00:08:07,310
私は､ 自分が何をしているのかを本当に理解していない限り､ そのようなことに手を出すことを強くお勧めしません｡

89
00:08:07,580 --> 00:08:12,410
その理由は､ 高度であることに加えて､ しばしば実際にどこにも到達することなく､

90
00:08:12,410 --> 00:08:20,780
常に関連性を微調整している自分に気づくからです｡ 2つ目のことをお伝えする前に､ コンソール内のクエリをお見せしたいと思います｡

91
00:08:20,930 --> 00:08:26,780
すでに入力済みで､ 見たことのない構文のクエリですが､ かなりわかりやすいと思います｡

92
00:08:27,020 --> 00:08:29,810
nameフィールドにlobsterという値があるかどうかを検索しています｡ 

93
00:08:29,960 --> 00:08:34,040
私がやりたいのは､ クエリにexploundedというクエリパラメータを追加することです｡ 

94
00:08:35,100 --> 00:08:38,730
そこで､ ここにexplainクエリパラメータを追加することにします｡ 

95
00:08:39,210 --> 00:08:45,990
これは､ Elasticsearchが各マッチング・ドキュメントのスコアをどのように計算したかについての詳細な情報を返すというものです｡

96
00:08:46,020 --> 00:08:48,360
そこで､ クエリを実行すると､ どういうことかわかると思います｡ 

97
00:08:51,970 --> 00:08:56,440
そこで少し下にスクロールすると､ underscore explanationという新しいプロパティが表示されます｡ 

98
00:08:56,920 --> 00:09:01,690
構文が少し不便なので､ これらすべての意味の詳細には触れません｡ 

99
00:09:01,690 --> 00:09:05,560
でも､ 注目したいのは､ ドキュメント数について触れている部分です｡ 

100
00:09:06,040 --> 00:09:08,660
196と書いてあることに注目してください｡ 

101
00:09:08,680 --> 00:09:11,320
インデックスに5000件の文書があるにもかかわらず｡ 

102
00:09:11,530 --> 00:09:16,810
というのも､ 先ほどのフリーファクターは､ 実は1株あたりの数値なのです｡ 

103
00:09:16,900 --> 00:09:21,910
これは､ 例えば､ ある用語を含む文書の数を決定する場合､ このチャートに格納されている文書に基づいて決定されることを意味します｡

104
00:09:21,910 --> 00:09:34,010
私たちのインデックスはデフォルトで5つのチャートを持っており､ この特定のマッチの関連性チャートは196文書を含んでいます｡

105
00:09:34,030 --> 00:09:38,920
関連性はこれらの文書に基づいて判断され､ 1000の文書すべてではありません｡ 

106
00:09:39,280 --> 00:09:41,500
では､ これで何か違いがあるのでしょうか？

107
00:09:41,680 --> 00:09:47,410
それは､ 関連性を計算するための統計量がセット間で異なるからです｡ 

108
00:09:47,800 --> 00:09:52,750
カスタムルーティングを使用しない限り､ ドキュメント数はチャート全体でほぼ同じになります｡ 

109
00:09:52,750 --> 00:09:56,710
しかし､ 逆文書頻度が完全に正しいとは限らない｡ 

110
00:09:56,980 --> 00:10:02,920
それは､ その用語がインデックス内で何回出現するかは､ 特定のチャート上の文書に依存するからである｡

111
00:10:03,160 --> 00:10:08,950
あるチャートにはサラダという言葉を含む文書が1つしかなく､ 別のチャートにはそのような文書が10個含まれているとしたら､

112
00:10:08,950 --> 00:10:13,300
関連性に影響を与え､ 精度が若干低下してしまうのではないでしょうか｡

113
00:10:13,330 --> 00:10:18,580
重要である可能性は低くなりますが､ 1つのチャートに追加するドキュメントの数が多くなればなるほど､ その可能性は高くなります｡ 

114
00:10:19,030 --> 00:10:24,460
ほとんどの場合､ これは何の問題もないのですが､ 一応書いておきますね｡ 

115
00:10:24,910 --> 00:10:29,200
それを回避する方法もあるのですが､ それはもっと高度な話なので､ 今は割愛します｡ 
