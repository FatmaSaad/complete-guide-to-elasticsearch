1
00:00:02,170 --> 00:00:10,060
この講義では､ 検索クエリにマッチするごとに､ アンダースコアのソースフィールドのどの部分を返すかを制御する方法を紹介したいと思います｡

2
00:00:10,420 --> 00:00:16,450
デフォルトでは､ フィールドの全内容が返されますが､ 常にそうであることを望むとは限りません｡

3
00:00:16,600 --> 00:00:21,880
アンダースコアのソースフィールドに返されるデータを制限する動機は､ 通常､ 返されるデータの量を減らし､

4
00:00:21,880 --> 00:00:25,930
それによってネットワーク上の転送量を減らすことであるだろう｡

5
00:00:26,080 --> 00:00:29,710
ですから､ 通常はパフォーマンスを向上させることが動機となります｡ 

6
00:00:29,860 --> 00:00:35,770
小規模なアプリケーションでは違いを感じないかもしれませんが､ スループットの大きいアプリケーション､ 特に長いテキストフィールドを持つアプリケーションでは､

7
00:00:35,800 --> 00:00:41,020
間違いなくチューニングする価値のあるものです｡

8
00:00:41,530 --> 00:00:46,600
また､ アンダースコアのソースフィールドが全く必要ない場合は､ 完全に無効にすることができます｡ 

9
00:00:46,990 --> 00:00:56,470
これは､ 単にElasticsearchを使用してドキュメントのIDを検索し､ 他のデータストアからアイテムを取得するために使用したい場合に便利です｡

10
00:00:56,800 --> 00:00:58,810
その方法を､ まず見てみましょう｡ 

11
00:00:59,080 --> 00:01:06,790
ということで､ あらかじめ簡単なマッチクエリを入れておき､ あとはunderscore sourceというパラメータを追加してfalseと言っただけです｡

12
00:01:07,180 --> 00:01:12,430
そこで､ クエリというかリクエストボディのトップレベルでこれを行うことにします｡ 

13
00:01:12,730 --> 00:01:17,980
そこで､ ここではソースにアンダースコアをつけ､ その値としてfalseを指定しています｡ 

14
00:01:18,400 --> 00:01:20,980
では､ クエリを実行し､ どのように見えるか見てみましょう｡ 

15
00:01:21,190 --> 00:01:25,750
そして､ 結果内でもわかるように､ マッチングにアンダースコアのソースキーはない｡ 

16
00:01:26,380 --> 00:01:30,260
また､ 返したい1つのフィールドの名前を指定することもできる｡ 

17
00:01:30,280 --> 00:01:32,730
あるいは､ フィールド名の配列｡ 

18
00:01:32,740 --> 00:01:34,270
では､ それを試してみましょう｡ 

19
00:01:35,440 --> 00:01:39,610
まずは1つのフィールドで試してみて､ 作成されたフィールドを使ってみることにします｡ 

20
00:01:40,150 --> 00:01:41,110
走らせてみよう｡ 

21
00:01:41,620 --> 00:01:44,740
そして今､ 作成されたフィールドだけが返ってくることがお分かりいただけたと思います｡ 

22
00:01:45,430 --> 00:01:50,230
オブジェクトとネストされたプロパティの場合､ フィールドのキーパスを指定することができる｡ 

23
00:01:50,230 --> 00:01:55,900
ですから､ もし､ name フィールドを ingredients オブジェクトに含めたいだけなら､ enuarts dot name

24
00:01:55,900 --> 00:01:57,760
と書いて指定すればいいのです｡

25
00:01:57,760 --> 00:02:02,140
では､ その食材のドットネームのようなものをやってみましょう｡ 

26
00:02:02,140 --> 00:02:04,060
では､ 実行してみましょう｡ 

27
00:02:05,230 --> 00:02:10,120
そして､ name プロパティは ingredients 配列の中の各オブジェクトに対してのみ返されることがわかります｡ 

28
00:02:10,720 --> 00:02:15,880
また､ ワイルドカードパターンを利用して､ オブジェクト内のすべてのキーにマッチさせることも可能です｡ 

29
00:02:15,880 --> 00:02:23,020
つまり､ ここにアスタリスクを追加すれば､ 成分配列に格納されているオブジェクトのすべてのプロパティにマッチするようになるわけです｡

30
00:02:23,650 --> 00:02:24,520
走らせてみよう｡ 

31
00:02:25,370 --> 00:02:27,800
そして今､ 私たちはその見返りとして､ すべての財産を手に入れることができるのです｡ 

32
00:02:28,310 --> 00:02:32,030
先ほども言ったように､ フィールド名の配列を指定することも可能です｡ 

33
00:02:32,030 --> 00:02:37,400
ingredientsオブジェクト内のすべてのキーと､ servingsオブジェクト全体を含めてみましょう｡ 

34
00:02:37,790 --> 00:02:51,350
ここでは､ 文字列の配列を定義して､ まず食材のドットアスタリスクを指定し､ 次にサービングフィールドを指定します｡

35
00:02:53,070 --> 00:02:53,400
なるほど｡ 

36
00:02:53,430 --> 00:02:54,420
では､ 実行してみましょう｡ 

37
00:02:55,460 --> 00:03:00,470
そして､ その結果をチェックして､ 全成分被験者を取り戻すのです｡ 

38
00:03:01,490 --> 00:03:04,730
そして､ その見返りとして貯蓄オブジェクトもすべて手に入れることができるのです｡ 

39
00:03:05,480 --> 00:03:11,060
最後になりますが､ underscoreのソースパラメータをincludesとexcludeのキーを持つオブジェクトに変更することで､

40
00:03:11,060 --> 00:03:13,340
完全な制御を行うことができます｡

41
00:03:13,490 --> 00:03:19,160
仮に､ nameフィールドを除くすべてのキーをsubstructureオブジェクトに含めるとする｡ 

42
00:03:19,190 --> 00:03:20,450
それを定義しよう｡ 

43
00:03:20,750 --> 00:03:29,720
そこで､ すでに持っていたものを取り除き､ 代わりにアンダースコアのソース・パラメータ用のオブジェクトをincludesプロパティで追加してみましょう｡

44
00:03:30,380 --> 00:03:32,840
ここではすべてsを付けています｡ 

45
00:03:35,730 --> 00:03:43,980
ここでは､ すべてのフィールドを含むように ingredients ドットアスタリスクを指定し､ excludes パラメータを追加して､

46
00:03:43,980 --> 00:03:48,030
その名前の食材を除外することにします｡

47
00:03:50,020 --> 00:03:51,250
走らせてみよう｡ 

48
00:03:52,270 --> 00:03:57,880
そして今､ nameプロパティが､ 成分フィールド内の各オブジェクトに対して返されなくなったことを確認できます｡

49
00:03:58,540 --> 00:04:08,140
この例では､ 食材オブジェクトの中に2つのキーしかないので､ あまり意味がありませんが､ 多くのキーを持つオブジェクトに有効であることは想像がつくと思います｡

50
00:04:08,680 --> 00:04:12,700
つまり､ 検索クエリから返されるデータの量を制限することができるわけです｡ 

51
00:04:12,910 --> 00:04:18,010
リレーショナルデータベースの経験があれば､ アンダースコアのソースフィールドをフィルタリングすることは､

52
00:04:18,010 --> 00:04:25,150
クエリがselectsとfromキーワードの間にどのカラムを返すかを指定することと同じだと考えることができる｡
