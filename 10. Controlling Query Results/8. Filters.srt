1
00:00:02,490 --> 00:00:07,080
この講義では､ 皆さんが覚えていることを願いながら､ フィルターについてお話します｡ 

2
00:00:07,110 --> 00:00:12,630
クエリーは､ クエリーコンテキストとフィルターコンテキストの2つのコンテキストで実行することができます｡ 

3
00:00:12,810 --> 00:00:17,910
違いは､ クエリコンテキストでクエリを実行し､ 関連性に影響を与え､ クエリをフィルタリングすることです｡ 

4
00:00:17,910 --> 00:00:27,990
文書がクエリのコンテキストにマッチしなければならないこととは別に､ クエリは「文書がどの程度フィルタにマッチするか」という質問にも答える｡

5
00:00:27,990 --> 00:00:30,660
一方､ 私はイエスかノーかの質問だけです｡ 

6
00:00:30,660 --> 00:00:42,000
そのため､ 数値や日付の範囲､ 用語のクエリ､ ステータス・フィールドなどのキーワード・フィールドにマッチするフィルタが一般的に使用されることになります｡

7
00:00:42,660 --> 00:00:44,490
これを見て､ 何か思い出しませんか？

8
00:00:44,490 --> 00:00:49,830
実際にプールクエリを操作しているとき､ より具体的には､ must underscore not objectsにクエリを追加しているときに､

9
00:00:49,830 --> 00:00:51,600
このようなことがありました｡

10
00:00:52,290 --> 00:00:55,170
これらのクエリーは､ フィルターコンテキストで実行されました｡ 

11
00:00:55,200 --> 00:01:02,520
ここで､ must underscore not objectsの中のクエリの逆をやってみよう｡ つまり､ ドキュメントがマッチしなければならないクエリを追加するのである｡

12
00:01:02,910 --> 00:01:06,360
実はこのために､ またプールクエリを使おうと思っています｡ 

13
00:01:06,750 --> 00:01:12,420
以前のバージョンのElasticsearchでは､ フィルタはリクエストボディのトップレベルで指定されていましたが､

14
00:01:12,420 --> 00:01:14,280
現在ではそのようなことはありません｡

15
00:01:14,850 --> 00:01:20,910
その代わり､ filter という名前のパラメータを様々なクエリ､ 特��プールクエリに追加することができる｡ 

16
00:01:21,570 --> 00:01:28,410
そこで､ タイトルフィールドにパスタという言葉が含まれるレシピを単純にマッチングさせるクエリを事前に用意しました｡

17
00:01:29,130 --> 00:01:33,120
私が怠け者であることはもうご存知だと思いますが､ だから早く物事を終わらせたいのです｡ 

18
00:01:33,600 --> 00:01:39,330
そこで､ レシピの準備時間が15分以内であることを条件とするフィルタを適用することにします｡ 

19
00:01:39,900 --> 00:01:43,260
filterパラメータ内にレンジクエリを追加することでそれを行うことにする｡ 

20
00:01:43,260 --> 00:01:45,030
では､ その様子をご覧ください｡ 

21
00:01:45,540 --> 00:01:52,500
そこで､ このオブジェクトの中で最も多い配列と同じレベルで､ カンマを追加してフィルタキーを指定し､

22
00:01:52,500 --> 00:01:59,280
プールクエリ内の他のキーと同じ理由で配列として追加してみます｡

23
00:02:00,130 --> 00:02:02,230
そこで､ ここではクエリ句を追加してみます｡ 

24
00:02:02,260 --> 00:02:05,410
オブジェクトのものなので､ レンジクエリを使用します｡ 

25
00:02:05,410 --> 00:02:13,690
これもオブジェクトとして定義し､ フィールドはpreparation､ underscore time､ underscore

26
00:02:13,690 --> 00:02:15,910
minutesとします｡

27
00:02:16,600 --> 00:02:18,400
そして､ これも配列である｡ 

28
00:02:18,910 --> 00:02:19,890
特に目新しいことはありません｡ 

29
00:02:19,900 --> 00:02:22,000
これは単なる標準的なレンジクエリです｡ 

30
00:02:22,750 --> 00:02:27,670
つまり､ LC15は15以下という意味です｡ 

31
00:02:30,630 --> 00:02:41,190
このレンジクエリをフィルタパラメータに追加した理由は､ Elastic Searchはこのクエリを関連スコアの算出に使用しないからです｡

32
00:02:41,880 --> 00:02:45,660
そのため､ マッチクエリは関連性に影響を与え､ クエリの手配を難しくしている｡ 

33
00:02:46,020 --> 00:02:51,390
クエリはfilterパラメータ内に追加しましたが､ ちょっとした変更でmust underscore,

34
00:02:51,390 --> 00:02:53,970
notパラメータに追加することも可能でした｡

35
00:02:54,390 --> 00:03:00,570
その場合､ 準備時間が15以上のレシピに一致するように範囲クエリを変更すればいいんです｡

36
00:03:00,780 --> 00:03:04,780
この両方のパラメータ内でクエリロスが発生するため､ 同じことである｡ 

37
00:03:04,800 --> 00:03:06,510
私はフィルターの文脈で走ります｡ 

38
00:03:07,310 --> 00:03:08,960
そして､ これがフィルターの追加方法です｡ 

39
00:03:09,050 --> 00:03:12,140
では､ なぜプールのクエリの話をするときに､ そのことに触れなかったのでしょうか？

40
00:03:12,230 --> 00:03:17,810
なぜなら､ この例ではプール・クエリを使用していますが､ フィルタはプール・クエリに固有のものではないためです｡ 

41
00:03:18,500 --> 00:03:23,090
また､ フィルターは集約や他のクエリで使用することもできます（後で説明します）｡ 

42
00:03:23,480 --> 00:03:30,110
とはいえ､ プールクエリは非常に柔軟でよく使うクエリなので､ 一般的にはフィルタを追加することになるでしょう｡

43
00:03:30,800 --> 00:03:35,330
最後に､ そもそもなぜフィルターを使いたいのか､ その理由を思い出してみてください｡ 

44
00:03:35,360 --> 00:03:39,560
フィルターが関連性に影響を与えないことはすでにお話ししましたので､ それはそれとして｡ 

45
00:03:39,560 --> 00:03:41,690
しかし､ フィルターの方が効率的でもあります｡ 

46
00:03:42,200 --> 00:03:47,600
これは､ Elasticsearchが頻繁に使用されるフィルターを自動的にキャッシュするためで､ 関連するスコアを計算する必要がない場合には､

47
00:03:47,600 --> 00:03:51,620
計算時間を少し節約することもできます｡
