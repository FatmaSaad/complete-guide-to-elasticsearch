1
00:00:02,220 --> 00:00:07,290
これまで､ さまざまなクエリの書き方やページネーションの扱い方を見てきましたが､ 結果をうまくソートする方法については､

2
00:00:07,290 --> 00:00:10,170
これまで見てきませんでした｡

3
00:00:10,410 --> 00:00:15,420
Elasticsearchでは結果のソートは非常に簡単で､ リレーショナルデータベースのorder

4
00:00:15,420 --> 00:00:18,240
by節で行をソートするのとほぼ同じです｡

5
00:00:18,600 --> 00:00:22,710
だから､ ご存知の通り､ 私は怠け者で､ それは料理も同じです｡ 

6
00:00:22,920 --> 00:00:26,340
ですから､ 一番時間のかからないレシピを探したいと思っています｡ 

7
00:00:26,340 --> 00:00:32,280
そこで､ 準備､ アンダースコア時間､ アンダースコア分､ フィールドの順番で結果を並べたいのです｡

8
00:00:32,610 --> 00:00:35,920
すでに､ すべての文書にマッチするクエリを準備しています｡ 

9
00:00:35,940 --> 00:00:40,830
アンダースコアのソースメタルフィールドからフィールドを返さないのですが､ その理由は後ほど説明します｡ 

10
00:00:41,280 --> 00:00:45,450
まず､ sortパラメータでヒットの並べ方を定義します｡ 

11
00:00:45,480 --> 00:00:51,690
デフォルトのソート順は昇順なので､ あとはソートしたいフィールドの名前を指定するだけです｡

12
00:00:52,050 --> 00:00:53,280
では､ そうしましょう｡ 

13
00:00:53,310 --> 00:00:55,650
ここではクエリキーの下にやってみます｡ 

14
00:00:55,830 --> 00:00:56,940
だからソート｡ 

15
00:00:57,510 --> 00:01:00,120
そして､ ご覧の通り､ 配列になるはずです｡ 

16
00:01:00,150 --> 00:01:05,280
まず､ 文字列の配列という最も単純な構文から始めたいので､

17
00:01:05,280 --> 00:01:08,280
これを取り除くだけでしょう｡

18
00:01:08,460 --> 00:01:11,970
そこで､ 準備時間分のフィールドに文字列を追加することにします｡ 

19
00:01:12,120 --> 00:01:18,210
では､ ここにフィールド名を入力して､ 実行し､ 結果を見てみましょう｡ 

20
00:01:18,240 --> 00:01:20,880
sourceという新しいキーがあることに注目してください｡ 

21
00:01:21,240 --> 00:01:25,380
このキーには､ 結果がソートされた値の配列が含まれる｡ 

22
00:01:25,680 --> 00:01:29,640
この場合､ それは「操作時間分」フィールドの値です｡ 

23
00:01:29,940 --> 00:01:36,450
それが､ アンダースコアのソースメタルフィールドを結果から除外した理由です｡ この新しい配列内の値を見ることができるのです｡

24
00:01:37,050 --> 00:01:42,570
次に､ 最新のレシピを見つけたいので､ ソート順を指定する方法を紹介したいと思います｡ つまり､

25
00:01:42,570 --> 00:01:45,660
作成されたフィールドで降順にソートするのです｡

26
00:01:46,050 --> 00:01:52,050
そこで､ 既存のクエリをコピーして､ ここにペーストし､ 適宜調整することにします｡ 

27
00:01:52,470 --> 00:01:56,340
ここでアンダースコアのソースパラメータも更新しておきます｡ 

28
00:01:57,140 --> 00:01:58,990
だから､ クリエイティブな分野も含めて｡ 

29
00:01:59,000 --> 00:02:00,500
その理由は､ すぐにわかるでしょう｡ 

30
00:02:00,770 --> 00:02:02,900
そして､ ここに降りてみましょう｡ 

31
00:02:02,930 --> 00:02:08,030
太陽電池の中にすでにあったものを取り除き､ 文字列の代わりにオブジェクトを入力します｡ 

32
00:02:08,540 --> 00:02:15,680
このオブジェクトの中に､ 作成するフィールドの名前をキーとして追加し､ 値には､ スキャン用のESIまたはスキャン用のDSCを入力できるように､

33
00:02:15,680 --> 00:02:21,980
求める方向性を入力します｡

34
00:02:22,850 --> 00:02:23,810
走らせてみよう｡ 

35
00:02:24,530 --> 00:02:28,220
そして､ その結果､ 最新のレシピが最初に表示されるようになりました｡ 

36
00:02:28,670 --> 00:02:33,620
アンダースコアのソースメソッドフィールドの中にクリエイティブフィールドを入れたのは､ 日付フィールドの場合､

37
00:02:33,620 --> 00:02:36,830
ソートキーに数字が含まれるからです｡

38
00:02:37,160 --> 00:02:40,730
この数値は､ エポックからのミリ秒を表す｡ 

39
00:02:40,730 --> 00:02:44,180
つまり､ 基本的にはUnixのタイムスタンプに1000を掛けたものです｡ 

40
00:02:44,390 --> 00:02:50,360
これは､ Elasticsearchが内部的に日付に使用する表現で､ 今回はソートのために使用します｡ 

41
00:02:50,510 --> 00:02:54,620
ただ､ 次に読みやすいように､ 日付を入れたかったんです｡ 

42
00:02:54,620 --> 00:02:59,510
SQLや他の多くの技術にあるように､ 複数のフィールドでソートしてみましょう｡ 

43
00:02:59,510 --> 00:03:05,600
これは確かに可能なのですが､ sortパラメータに配列を指定したことで､ すでにそれがバレてしまったのでしょう｡

44
00:03:05,900 --> 00:03:07,640
ちなみに､ そんなことはしなくていいんです｡ 

45
00:03:07,640 --> 00:03:14,570
単一のフィールドで昇順に並べ替えたいだけなら､ sourceパラメータにフィールド名を直接指定すればよい｡

46
00:03:14,840 --> 00:03:17,480
ただ､ 個人的には配列を使うのが好きです｡ 

47
00:03:17,900 --> 00:03:21,260
とにかく､ クエリのコピーを作って､ 別のフィールドでソートしてみましょう｡ 

48
00:03:24,770 --> 00:03:29,470
これから行うのは､ 最初の2つのクエリでソートした2つのフィールドを結合することです｡ 

49
00:03:29,480 --> 00:03:38,470
そこで､ 結果を解釈しやすくするために､ 準備時間をスキャン順に､ 作成されたタイムスタンプを降順に並べて開始することを考えます｡

50
00:03:38,480 --> 00:03:41,330
この2つのフィールドをアンダースコアのソースマターフィールドに追加してみます｡ 

51
00:03:41,720 --> 00:03:44,420
では､ それを最初の文字列としてやってみましょう｡ 

52
00:03:44,930 --> 00:03:53,390
そこで､ これを取り除き､ フィールド名を含む文字列の配列として､ ここに配列を追加することにします｡

53
00:03:53,750 --> 00:03:58,430
だから､ まず準備時間分､ それから作成する｡ 

54
00:03:59,300 --> 00:04:02,690
そして､ この下にあるパラメータに取りかかりましょう｡ 

55
00:04:02,990 --> 00:04:09,440
そこで､ 準備時間（分）でソートしたいので､ まず､ すでにあったものの上にオブジェクトを追加する必要があります｡

56
00:04:10,040 --> 00:04:22,790
つまり､ オブジェクトは同じ構造で､ 順序は走査になります｡ これは明示的に定義する必要はありませんが､

57
00:04:22,790 --> 00:04:25,160
私の好みです｡

58
00:04:26,090 --> 00:04:27,800
さっそく実行してみましょう｡ 

59
00:04:27,980 --> 00:04:33,410
そのため､ 複数の文書が同じ作成時刻を持つ場合､ 作成時刻順にソートされるため､

60
00:04:33,590 --> 00:04:37,160
2番目のソート順が有効になることがわかります｡

61
00:04:37,490 --> 00:04:43,220
そこで､ 少し下にスクロールしてみると､ 準備時間15分のレシピがたくさん出てきます｡ 

62
00:04:44,250 --> 00:04:47,520
日付を見ると､ 最新のものが先に表示されていることがわかる｡ 

63
00:04:47,520 --> 00:04:51,720
つまり､ これは実質的に､ 私たちが指定した2番目のソート順を実行したものです｡ 

64
00:04:52,050 --> 00:04:57,750
また､ 特筆すべきは､ on scoreスコアという特殊なフィールドを使ってスコアでソートできることです｡ 

65
00:04:58,050 --> 00:05:04,350
スコアによるソートはデフォルトの動作なので､ これはカスタムのソート順を指定する場合にのみ意味を持つ｡

66
00:05:04,950 --> 00:05:07,670
以上が､ Elasticsearchでのソートの基本でした｡ 

67
00:05:07,680 --> 00:05:09,250
結構簡単だったでしょう？

68
00:05:09,270 --> 00:05:11,250
しかし､ 仕分けでできることはそれだけではありません｡ 

69
00:05:11,250 --> 00:05:15,570
続けて､ ソートに関する他のツールボックスについて見てみましょう｡ 
