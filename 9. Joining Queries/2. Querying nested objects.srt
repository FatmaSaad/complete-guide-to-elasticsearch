1
1

00:00:02,440  -->  00:00:04,890
The first way of joining data that we will look at,
2

2

00:00:04,890  -->  00:00:07,550
is by using a query named nested.
3

3

00:00:07,550  -->  00:00:08,780
When we looked at mapping,
4

4

00:00:08,780  -->  00:00:11,830
I talked a bit about a field data type named nested,
5

5

00:00:11,830  -->  00:00:14,730
which is used together with the nested query.
6

6

00:00:14,730  -->  00:00:16,970
Just to briefly refresh your memory,
7

7

00:00:16,970  -->  00:00:19,390
this type is used for arrays of objects
8

8

00:00:19,390  -->  00:00:21,310
where you want to maintain the relationships
9

9

00:00:21,310  -->  00:00:23,130
between object properties,
10

10

00:00:23,130  -->  00:00:25,890
meaning many-to-one relationships.
11

11

00:00:25,890  -->  00:00:28,730
If a field is just mapped as an array of objects,
12

12

00:00:28,730  -->  00:00:30,680
an object is not independent,
13

13

00:00:30,680  -->  00:00:33,170
because all of the object properties are mixed together
14

14

00:00:33,170  -->  00:00:35,020
when stored by Elasticsearch.
15

15

00:00:35,020  -->  00:00:38,100
I'll get back to the problems with this in a moment.
16

16

00:00:38,100  -->  00:00:40,740
First, let's add a new index and some test data
17

17

00:00:40,740  -->  00:00:43,140
so that we have something to work with.
18

18

00:00:43,140  -->  00:00:45,310
I've added three queries in advance for this,
19

19

00:00:45,310  -->  00:00:47,250
which you can find in the GitHub repository
20

20

00:00:47,250  -->  00:00:48,970
if you're following along.
21

21

00:00:48,970  -->  00:00:50,370
I added these in advance,
22

22

00:00:50,370  -->  00:00:53,430
because they don't contain anything you haven't seen before.
23

23

00:00:53,430  -->  00:00:56,490
Let's go ahead and run these queries one by one.
24

24

00:00:56,490  -->  00:00:59,650
The first query creates a new index named department,
25

25

00:00:59,650  -->  00:01:01,990
which contains a mapping for two fields,
26

26

00:01:01,990  -->  00:01:03,950
name and employees.
27

27

00:01:03,950  -->  00:01:06,310
The employees field is of the type nested,
28

28

00:01:06,310  -->  00:01:08,630
as it will hold an array of objects.
29

29

00:01:08,630  -->  00:01:10,990
I haven't mapped out the properties of the objects,
30

30

00:01:10,990  -->  00:01:13,280
as I will let Elasticsearch's dynamic mapping
31

31

00:01:13,280  -->  00:01:14,910
handle this for us.
32

32

00:01:14,910  -->  00:01:18,100
So, let's run the first query to add the index.
33

33

00:01:18,100  -->  00:01:18,933
There we go.
34

34

00:01:20,890  -->  00:01:24,400
The next query adds a document to the newly created index.
35

35

00:01:24,400  -->  00:01:25,380
More specifically,
36

36

00:01:25,380  -->  00:01:27,950
a document representing a development department
37

37

00:01:27,950  -->  00:01:30,350
and the number of employees.
38

38

00:01:30,350  -->  00:01:32,970
Each employee object contains four fields,
39

39

00:01:32,970  -->  00:01:36,070
name, age, gender, and position.
40

40

00:01:36,070  -->  00:01:40,490
So let's go ahead and run this query, like so.
41

41

00:01:40,490  -->  00:01:42,870
And let's scroll down a bit.
42

42

00:01:42,870  -->  00:01:45,270
The third query simply adds another department,
43

43

00:01:45,270  -->  00:01:47,973
namely a human resources and marketing department.
44

44

00:01:48,990  -->  00:01:50,903
So let's run this one as well.
45

45

00:01:52,390  -->  00:01:54,430
Now with some test data at hand,
46

46

00:01:54,430  -->  00:01:56,450
let's try to query the nested field,
47

47

00:01:56,450  -->  00:01:58,290
being the employees field.
48

48

00:01:58,290  -->  00:02:00,440
Suppose that I want to find out which departments
49

49

00:02:00,440  -->  00:02:01,920
have female interns,
50

50

00:02:01,920  -->  00:02:04,270
which I can do by looking for a value of intern
51

51

00:02:04,270  -->  00:02:05,830
within the position field,
52

52

00:02:05,830  -->  00:02:08,950
and the term F within the gender field.
53

53

00:02:08,950  -->  00:02:10,300
Since that's two queries,
54

54

00:02:10,300  -->  00:02:12,860
I will wrap them within a bool query.
55

55

00:02:12,860  -->  00:02:15,060
So let's do just that.
56

56

00:02:15,060  -->  00:02:18,220
So I'll write bool as the query type.
57

57

00:02:18,220  -->  00:02:19,673
Then I'll add a must clause.
58

58

00:02:21,130  -->  00:02:23,920
And in here I'll add a match query
59

59

00:02:23,920  -->  00:02:27,290
and specify the path of the field that I want to search.
60

60

00:02:27,290  -->  00:02:29,480
Since it's a property of a nested object,
61

61

00:02:29,480  -->  00:02:33,173
I'll write employees.position.
62

62

00:02:34,150  -->  00:02:36,743
And as the value to search for, I'll write intern.
63

63

00:02:37,670  -->  00:02:40,253
Let's add another query to the must array.
64

64

00:02:41,661  -->  00:02:43,023
A term query this time.
65

65

00:02:44,097  -->  00:02:49,094
And the path will be employees.gender.
66

66

00:02:49,840  -->  00:02:51,220
And I'll use the keyword mapping
67

67

00:02:51,220  -->  00:02:53,990
because I'm using term level query.
68

68

00:02:53,990  -->  00:02:56,193
And the value will just be a capital F.
69

69

00:02:57,180  -->  00:03:00,473
Let's go ahead and run it and see what happens.
70

70

00:03:01,660  -->  00:03:04,920
So running this query, we get no matches.
71

71

00:03:04,920  -->  00:03:08,190
That's because nested fields cannot be queried this way.
72

72

00:03:08,190  -->  00:03:09,820
Instead, they must be queried
73

73

00:03:09,820  -->  00:03:13,410
using a specialized query type named nested.
74

74

00:03:13,410  -->  00:03:16,350
The nested query consists of two parts,
75

75

00:03:16,350  -->  00:03:18,900
a path to the field containing the objects,
76

76

00:03:18,900  -->  00:03:21,630
and the query that should be run against them.
77

77

00:03:21,630  -->  00:03:23,010
Let's begin to type out the query
78

78

00:03:23,010  -->  00:03:25,320
by making a copy of the query that we just wrote
79

79

00:03:25,320  -->  00:03:26,270
and then adjust it.
80

80

00:03:29,670  -->  00:03:32,703
So let's paste it in down here.
81

81

00:03:34,910  -->  00:03:38,600
And actually I will just get rid of all of this
82

82

00:03:40,470  -->  00:03:42,393
and add the nested query.
83

83

00:03:43,730  -->  00:03:46,740
And the path will be employees
84

84

00:03:46,740  -->  00:03:49,540
being the field containing the objects.
85

85

00:03:49,540  -->  00:03:53,600
And then I'll just take the bool query from before,
86

86

00:03:53,600  -->  00:03:57,613
copy it, and paste it in within this query object like so.
87

87

00:04:03,570  -->  00:04:05,863
All right, so let's try to run this query.
88

88

00:04:08,930  -->  00:04:11,510
Running this query, both departments are now matched
89

89

00:04:11,510  -->  00:04:15,210
because we get two total matches in the search results.
90

90

00:04:15,210  -->  00:04:17,810
This happens because the association between the objects
91

91

00:04:17,810  -->  00:04:19,700
is now maintained.
92

92

00:04:19,700  -->  00:04:21,240
So couldn't we have done this
93

93

00:04:21,240  -->  00:04:23,180
with a normal array of objects,
94

94

00:04:23,180  -->  00:04:25,620
i.e. without the nested type?
95

95

00:04:25,620  -->  00:04:27,090
No, we couldn't.
96

96

00:04:27,090  -->  00:04:29,010
The reason is that the association
97

97

00:04:29,010  -->  00:04:32,550
between each of the object properties would be lost.
98

98

00:04:32,550  -->  00:04:35,560
This means that we wouldn't be able to answer the question:
99

99

00:04:35,560  -->  00:04:37,510
which departments have employees
100

100

00:04:37,510  -->  00:04:39,870
that are both interns and female?
101

101

00:04:39,870  -->  00:04:41,560
We would simply not be able to query
102

102

00:04:41,560  -->  00:04:43,680
more than one field on the same object,
103

103

00:04:43,680  -->  00:04:45,500
because the values are all mixed together
104

104

00:04:45,500  -->  00:04:47,350
when stored internally.
105

105

00:04:47,350  -->  00:04:49,830
Maybe you remember me showing you an example of this
106

106

00:04:49,830  -->  00:04:53,450
when discussing the nested type when talking about mapping.
107

107

00:04:53,450  -->  00:04:55,720
Anyways, that was how to use the nested query
108

108

00:04:55,720  -->  00:04:57,720
for querying nested objects.
109

109

00:04:57,720  -->  00:04:59,830
This query type is used in combination
110

110

00:04:59,830  -->  00:05:01,670
with the nested field data type,
111

111

00:05:01,670  -->  00:05:04,980
and enables you to query each object independently.
112

112

00:05:04,980  -->  00:05:07,530
More specifically, you can query each object
113

113

00:05:07,530  -->  00:05:09,950
as if it was an independent document,
114

114

00:05:09,950  -->  00:05:13,090
which is actually how the objects are stored internally.
115

115

00:05:13,090  -->  00:05:14,580
A problem with this approach,
116

116

00:05:14,580  -->  00:05:16,070
is that each employee is stored
117

117

00:05:16,070  -->  00:05:18,550
within that department document.
118

118

00:05:18,550  -->  00:05:20,150
This increases the complexity
119

119

00:05:20,150  -->  00:05:22,220
of keeping the employees updated,
120

120

00:05:22,220  -->  00:05:24,150
such as if they change their title,
121

121

00:05:24,150  -->  00:05:24,983
address,
122

122

00:05:24,983  -->  00:05:27,070
or whatever the case might be.
123

123

00:05:27,070  -->  00:05:30,340
Wouldn't it be better if an employee was a document itself,
124

124

00:05:30,340  -->  00:05:32,720
and that we had a way of establishing a relationship
125

125

00:05:32,720  -->  00:05:36,290
between the department document and the employee document?
126

126

00:05:36,290  -->  00:05:38,820
Kind of the same thing as you would do with a foreign key
127

127

00:05:38,820  -->  00:05:41,110
in a relational database.
128

128

00:05:41,110  -->  00:05:42,480
We can actually do this
129

129

00:05:42,480  -->  00:05:44,450
by using something called a join field,
130

130

00:05:44,450  -->  00:05:46,790
which we'll take a look at in a moment.
131

131

00:05:46,790  -->  00:05:48,940
But first, I want to show you a neat feature
132

132

00:05:48,940  -->  00:05:50,433
called inner hits.
