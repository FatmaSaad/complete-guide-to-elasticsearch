1
00:00:02,210 --> 00:00:04,760
先ほど､ ネストしたオブジェクトを作成する方法を説明しました｡ 

2
00:00:04,790 --> 00:00:09,650
具体的には､ ある条件に合致する従業員と部門をマッチングさせる方法をご覧いただきました｡ 

3
00:00:09,920 --> 00:00:11,180
かなり便利ですね｡ 

4
00:00:11,180 --> 00:00:13,670
しかし､ どの従業員にコストがかかるかを知りたい場合はどうすればいいのでしょうか｡ 

5
00:00:13,670 --> 00:00:19,070
前回の講義の検索結果を照合する部署には､ そのための情報は入っていませんでしたが､

6
00:00:19,070 --> 00:00:24,050
幸いなことに､ この情報を手に入れるのはとても簡単なことなのです｡

7
00:00:24,290 --> 00:00:27,410
それを､ インナーヒットという機能を使って行っています｡ 

8
00:00:27,500 --> 00:00:31,570
後で見るように､ hitはjoinデータ型でも使用することができます｡ 

9
00:00:31,580 --> 00:00:37,910
そこで､ ネストされたフィールドのコンテキストでインナーヒットを使用する場合､ その機能をネストされたインナーヒットと呼ぶことにしている｡

10
00:00:38,270 --> 00:00:44,540
前回の講義で出てきたクエリを使って､ ネストされたインナーヒットを含めるようにElasticsearchに指示する方法を見てみましょう｡

11
00:00:44,690 --> 00:00:50,340
最も単純な形では､ inner underscore hits というオプションをクエリに追加するだけである｡ 

12
00:00:50,360 --> 00:00:51,380
それだけです｡ 

13
00:00:51,710 --> 00:00:54,020
それを実行して､ 結果を確認してみましょう｡ 

14
00:00:54,290 --> 00:00:59,840
そこで､ このネストされたオブジェクトの中にオプションを追加することにします｡ 

15
00:01:00,050 --> 00:01:11,150
だから､ インナーアンダースコアのヒット､ おっとっとのヒット､ そして値として空のオブジェクトを指定すればいいのです｡ 

16
00:01:11,480 --> 00:01:16,940
クエリを実行する前に､ 部門のソース文書が返されないようにだけしておきます｡

17
00:01:16,970 --> 00:01:21,030
それは､ かなりの量のデータを見ることになるので､ 結果を見やすくするためです｡ 

18
00:01:21,050 --> 00:01:26,390
そうでない場合は､ もちろん今まで通りマッチング部門にアクセスすることができます｡

19
00:01:26,750 --> 00:01:30,440
そこで､ ここでアンダースコアのソースを設定することにします｡ 

20
00:01:30,440 --> 00:01:31,460
だから嘘｡ 

21
00:01:31,730 --> 00:01:33,890
そして､ クエリを実行することができるようになりました｡ 

22
00:01:35,020 --> 00:01:35,380
ようなものです｡ 

23
00:01:35,380 --> 00:01:39,970
その結果､ inner underscore hitsという名前のキーができました｡ 

24
00:01:40,210 --> 00:01:46,450
このキーの中に､ 検索クエリで定義したパスに一致するemployeesというキーが見つかります｡

25
00:01:46,780 --> 00:01:52,120
必要であれば､ 内側のアンダースコアのヒットオブジェクトにnameオプションを指定することで設定することができる｡ 

26
00:01:52,570 --> 00:01:56,290
残りの結果は､ ほとんどの場合､ 見慣れたものになるはずです｡ 

27
00:01:56,590 --> 00:02:01,750
隠された主題の中で､ ある部門に対して何個のネストされたオブジェクトがマッチしたかを見ることができる｡ 

28
00:02:02,140 --> 00:02:07,120
ここでは､ IDが1である1つの部門を扱っていることを忘れないでください｡ 

29
00:02:07,540 --> 00:02:10,810
この部門には､ 条件に合致する社員が1人いた｡ 

30
00:02:11,020 --> 00:02:18,550
ネストされたヒット・サブジェクト（ネストされたクルーにマッチした従業員の配列）の中から､ その特定の従業員を見つけることができるのです｡

31
00:02:18,880 --> 00:02:22,930
この場合､ Julie Powellという従業員が条件に一致しました｡ 

32
00:02:23,470 --> 00:02:27,880
私たちがアンダースコアのソースキー内の従業員オブジェクトにアクセスできることは別として｡ 

33
00:02:27,910 --> 00:02:31,300
アンダースコアのネストしたオブジェクトもあることに注目してください｡ 

34
00:02:31,600 --> 00:02:36,820
このオブジェクトは､ ヒットしたオブジェクトがどのネストされたオブジェクトから来たかを示すフィールドキーを持っています｡ 

35
00:02:37,000 --> 00:02:43,500
この場合､ クエリで検索するのは1種類のネストされたオブジェクトだけなので､ 定義したパスに等しくなります｡

36
00:02:43,510 --> 00:02:47,020
しかし､ より複雑なクエリでは､ 必ずしもそうとは限りません｡ 

37
00:02:47,350 --> 00:02:54,100
少し下にスクロールすると､ クエリーにマッチした他の部門と､ ネストされたフィールドにマッチした従業員を見つけることができます｡

38
00:02:54,790 --> 00:02:57,370
この部門については､ 2人の社員がマッチングしました｡ 

39
00:02:57,580 --> 00:03:00,460
ネストされたインナーヒットは､ 本当にそれだけなんです｡ 

40
00:03:00,550 --> 00:03:10,690
Elasticsearchを始めてみるとわかりますが､ これらを返すのは超簡単で､ どのネストしたオブジェクトがマッチするドキュメントのコストになるかを知るための強力な方法です｡

41
00:03:10,990 --> 00:03:15,250
これは､ あなたの特定のユースケースによって､ あなたに関係があるかもしれませんし､ ないかもしれません｡ 

42
00:03:15,670 --> 00:03:19,180
この講演を終える前に､ 2つのことを手短に述べたいと思います｡ 

43
00:03:19,330 --> 00:03:24,400
まず､ デフォルトでは､ 内側のヒットが関連するスコアでソートされていることです｡ 

44
00:03:24,640 --> 00:03:30,400
ほとんどの場合はそれで問題ありませんが､ 必要であれば､ 内側のアンダースコア・ヒット・オブジェクトの中でソート・オプションを指定することで､

45
00:03:30,430 --> 00:03:33,550
内側のヒットをソートすることができます｡

46
00:03:33,880 --> 00:03:37,930
このようなことは決して必要ないでしょうから､ これ以上深入りしないことにします｡ 

47
00:03:38,440 --> 00:03:44,710
2つ目は､ インナーヒットがいくつかの機能に対応していること､ まだご覧になっていない機能もあることです｡

48
00:03:45,040 --> 00:03:50,020
これには､ ハイライトソースのフィルタリング､ スクリプトフィールド､ Explain APIなどがあります｡ 

49
00:03:50,590 --> 00:03:55,700
後者は､ なぜマッチングしたのか､ なぜキャッチされたのかを理解するために使用されます｡ 

50
00:03:55,720 --> 00:03:58,180
それを踏まえて､ 次の講義に進みましょう｡ 
