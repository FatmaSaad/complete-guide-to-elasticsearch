1
00:00:02,340 --> 00:00:09,120
親文書を基準にして子文書を取得する方法を見たので､ 今度はその逆をやってみましょう｡

2
00:00:09,210 --> 00:00:13,590
3つの親ドキュメントを､ その子ドキュメントに置かれた基準に基づいて作成する｡ 

3
00:00:13,830 --> 00:00:18,330
論理的には､ これを可能にするクエリは､ has underscored childという名前になっている｡ 

4
00:00:18,360 --> 00:00:19,710
実際に見てみましょう｡ 

5
00:00:20,100 --> 00:00:24,920
まず､ has underscore childのキーがクエリ名なので､ has underscore

6
00:00:24,930 --> 00:00:28,770
childと空のオブジェクトを追加してみます｡

7
00:00:29,340 --> 00:00:35,340
このオブジェクトの中で､ まず､ オプション名タイプの子文書の関係タイプを定義する必要がある｡

8
00:00:35,610 --> 00:00:38,190
この例では､ 値はemployeeになる予定です｡ 

9
00:00:38,190 --> 00:00:39,510
では､ それを打ち出してみましょう｡ 

10
00:00:40,170 --> 00:00:43,020
だから､ タイプも社員も｡ 

11
00:00:43,830 --> 00:00:53,610
次に､ 空のクエリーオブジェクトを追加しましょう｡ これは､ 子文書の制約を定義する場所です｡

12
00:00:53,610 --> 00:00:53,610
e. という感じです｡ 

13
00:00:53,910 --> 00:01:02,550
そこで､ 今やりたいことは､ Hが50以上の社員とマッチングさせ､ 男性の場合は該当するスコアを上げることです｡

14
00:01:03,000 --> 00:01:10,500
この特別なクエリの理由は､ 前回の講義と比較して少し高度なクエリをお見せすること以外には特にありません｡

15
00:01:10,650 --> 00:01:12,960
では､ さっそく打ち込んでみましょう｡ 

16
00:01:13,440 --> 00:01:15,730
だから､ それはプルクエリの仕事なんです｡ 

17
00:01:15,750 --> 00:01:17,070
だから､ それを追加しよう｡ 

18
00:01:17,490 --> 00:01:20,250
そしてまず､ 閉めなければならない｡ 

19
00:01:20,970 --> 00:01:28,080
そして､ この中に範囲クエリを追加して､ Hを制約するのではなく､ Hを検索するようにするつもりです｡

20
00:01:28,380 --> 00:01:30,510
だから､ フィールドはHという名前になっている｡ 

21
00:01:31,680 --> 00:01:38,190
そして､ LCAのオプションを廃止して､ これだけを残し､ 50に設定しましょう｡ 

22
00:01:38,670 --> 00:01:45,780
では､ その条件クエリで節を追加してみましょう｡ 

23
00:01:46,800 --> 00:01:48,930
ここで少し構文を変えてみます｡ 

24
00:01:49,830 --> 00:01:58,470
フィールドは性別で､ 用語レベルのクエリなのでキーワードマッピングを使用し､ maleの略であるmを指定します｡

25
00:01:59,040 --> 00:01:59,490
わかりました｡ 

26
00:01:59,490 --> 00:02:00,070
それだけです｡ 

27
00:02:00,090 --> 00:02:01,650
それでは､ クエリを実行してみましょう｡ 

28
00:02:03,350 --> 00:02:10,130
結果を見ると､ 開発部門は52歳の社員がいるため､ マッチングしていることがわかります｡

29
00:02:10,580 --> 00:02:14,920
年齢を60歳に変更すると､ 部門が一致しなくなったことが分かる｡ 

30
00:02:14,930 --> 00:02:16,190
では､ それを試してみましょう｡ 

31
00:02:18,150 --> 00:02:19,050
これでよしとしよう｡ 

32
00:02:20,050 --> 00:02:22,510
そして実際､ 部門が一致しなくなった｡ 

33
00:02:22,780 --> 00:02:24,730
この変更をもう一度元に戻します｡ 

34
00:02:26,380 --> 00:02:26,800
なるほど｡ 

35
00:02:26,800 --> 00:02:35,470
つまり､ Hessのアンダースコアの子クエリについて簡単に説明すると､ ある基準に合致する子ドキュメントを含む親ドキュメントを照合しているのです｡

36
00:02:35,830 --> 00:02:41,590
この条件には､ これまでに学習したどのようなクエリでも使用でき､ 最大限の柔軟性を持たせることができます｡ 

37
00:02:42,160 --> 00:02:46,120
has underscored childクエリについて､ もう2つ触れておきたいことがあります｡ 

38
00:02:46,270 --> 00:02:53,590
まず､ Hessのアンダースコアの親クエリと同様に､ マッチした子文書の関連スコアをクエリに含めるようにします｡

39
00:02:53,920 --> 00:02:59,050
Hessのアンダースコアの親クエリとは異なり､ スコアモードではオプションにscoreという名前がついています｡ 

40
00:02:59,050 --> 00:03:01,040
しかも､ 単なるブール値ではありません｡ 

41
00:03:01,060 --> 00:03:07,330
その名の通り､ 5つのスコアモードが用意されているので､ 早速､ それぞれのモードを見ていこう｡

42
00:03:07,870 --> 00:03:14,560
minとmaxモードは､ マッチする子文書の最低スコアと最高スコアをそれぞれ取得し､

43
00:03:14,560 --> 00:03:17,830
親文書の関連スコアにマッピングする｡

44
00:03:18,250 --> 00:03:27,580
一方､ sumとAVGモードは､ すべての子文書､ 関連するスコアを含み､ それぞれ合計と誤差を計算します｡

45
00:03:28,030 --> 00:03:33,250
その結果得られた数値を､ 親文書の関連スコアに集計している｡ 

46
00:03:33,640 --> 00:03:40,780
最後に､ 子文書の関連スコアを全く考慮しない､ Noneというスコアモードがあります｡

47
00:03:41,170 --> 00:03:47,320
これはデフォルトの動作なので､ 値を明示的にnonに設定するか､ 単に完全に省くかのどちらかです｡

48
00:03:48,130 --> 00:03:51,240
早速､ クエリにスコアとスコアモードオプションを追加してみましょう｡ 

49
00:03:51,250 --> 00:03:54,370
一応､ 例として､ モードをsomeにしておきます｡ 

50
00:03:55,430 --> 00:04:01,970
そこで､ ここにスコアモードのオプションscoreを追加し､ 値としてsomeを指定してみましょう｡ 

51
00:04:02,360 --> 00:04:04,190
そして､ クエリを実行してみましょう｡ 

52
00:04:06,070 --> 00:04:10,300
マッチドキュメントの関連スコアが1つでなくなったことに注目してください｡ 

53
00:04:10,570 --> 00:04:18,700
マッチした子文書の合計がスコアに集約されたので､ スコアが約3分の1になっただけです｡

54
00:04:19,030 --> 00:04:24,370
この方法は､ 単に条件に一致する子文書を持つ親文書を調べるだけでなく､

55
00:04:24,370 --> 00:04:30,010
子文書の一致度を考慮したい場合に有効である｡

56
00:04:30,580 --> 00:04:37,030
当然ながら､ 合計スコアリングモードを使用する場合､ マッチする子文書の数も関連スコアに影響を与える可能性がある｡

57
00:04:37,450 --> 00:04:43,000
どのようなデータを取り出すかによって､ スコアモードを活用するシーンは様々です｡

58
00:04:43,540 --> 00:04:54,460
次に､ Hessのアンダースコアの子クエリでは､ 親ドキュメントが検索結果に含まれるためにマッチしなければならない子の数の最小値と最大値を指定することもできます｡

59
00:04:54,730 --> 00:04:57,310
それは､ スコア上のminを足すだけで可能です｡ 

60
00:04:57,310 --> 00:05:00,160
ChildrenとMax underscore childrenのオプション｡ 

61
00:05:00,160 --> 00:05:01,630
では､ さっそくやってみましょう｡ 

62
00:05:02,290 --> 00:05:09,550
そこで､ score childrenオプションのminを2､ maxを2に設定することにします｡ 

63
00:05:09,550 --> 00:05:13,930
では､ 5つとし､ クエリを実行して結果を確認してみましょう｡ 

64
00:05:15,110 --> 00:05:17,460
現在は､ マッチングが取れなくなりました｡ 

65
00:05:17,480 --> 00:05:20,800
それは､ 子供の最低人数を2人に設定しているからです｡ 

66
00:05:20,810 --> 00:05:28,150
しかし､ 前にマッチした部門には､ このクエリで指定したクルーにマッチする子文書が1つしかありません｡

67
00:05:28,160 --> 00:05:32,360
今回は両方を指定しましたが､ もちろんどちらか一方を省いてもかまいません｡ 

68
00:05:32,360 --> 00:05:32,780
だから

69
00:05:33,380 --> 00:05:39,110
最後に､ hasアンダースコアの子クエリも､ 親クエリのhasがソートをサポートしているのと同じように､

70
00:05:39,110 --> 00:05:44,630
子クエリで親文書のソートをサポートしていることを手短に書いておきたい｡

71
00:05:44,990 --> 00:05:48,920
そのためにはスクリプトが必要なので､ 例のリンクを添付しておきます｡ 

72
00:05:48,920 --> 00:05:51,950
というわけで､ まだスクリプトを扱っていないのでこの講義｡ 

73
00:05:52,460 --> 00:05:54,050
そして､ 今回の講義はこれで終わりです｡ 

74
00:05:54,050 --> 00:05:55,430
次回作でお会いしましょう｡ 
