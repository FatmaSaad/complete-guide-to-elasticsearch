1
00:00:02,290 --> 00:00:08,440
今までは1レベルの関係しか扱っていませんでしたが､ 今までの例の文脈では､

2
00:00:08,440 --> 00:00:15,100
いわゆるマルチレベルの関係やネストされた関係も可能です｡

3
00:00:15,130 --> 00:00:19,990
会社には部門があり､ その部門に社員がいる｡ 

4
00:00:20,560 --> 00:00:27,430
しかし､ 既存のインデックスのマッピングを更新する必要がないように､ この講義のために新しいインデックスを作成するつもりです｡

5
00:00:27,520 --> 00:00:35,350
先ほどのリレーションと､ ある会社に属するサプライヤー・リレーションを含んでいます｡

6
00:00:35,740 --> 00:00:39,250
あれは本当にマルチレベルの関係とは関係ないんです｡ 

7
00:00:39,250 --> 00:00:46,150
しかしそれは､ このセクションの冒頭で述べた､ 1つのリレーションが複数のリレーションタイプを含んでいる例を示すだけである｡

8
00:00:46,690 --> 00:00:50,290
それでは､ さっそくインデックスとマッピングを作成してみましょう｡ 

9
00:00:50,710 --> 00:00:57,400
クエリの大部分はあらかじめ用意しておいたので､ あとはリレーションズ・オブジェクトに値を入れるだけです｡

10
00:00:57,760 --> 00:01:03,460
まず､ 会社関係の型を定義する必要があります｡ この型は､ 部門と供給者の両方の関係型を含むことになり､

11
00:01:03,460 --> 00:01:07,300
したがって､ 値は配列になるわけです｡

12
00:01:08,020 --> 00:01:10,210
そこで､ companyというキーを追加してみましょう｡ 

13
00:01:10,510 --> 00:01:16,150
おっと会社で､ 値が文字列の配列であるとして､ 配列｡ 

14
00:01:16,900 --> 00:01:20,800
だから､ まず部門､ そしてサプライヤー｡ 

15
00:01:21,970 --> 00:01:27,700
先ほども同じようなことが書かれていましたが､ その時は値として1つのリレーションタイプしか指定していませんでした｡ 

16
00:01:28,430 --> 00:01:28,880
わかりました｡ 

17
00:01:28,880 --> 00:01:34,280
ですから､ あとは従業員が部門の子であることを定義すればよいのです｡ 

18
00:01:34,310 --> 00:01:41,210
そのためには､ すでに定義した会社関係の型の子と一致する､ 別のキー名departmentを追加すればよい｡

19
00:01:42,110 --> 00:01:43,520
では､ そうしましょう｡ 

20
00:01:44,210 --> 00:01:47,600
区画と文字列値｡ 

21
00:01:48,270 --> 00:01:52,890
というわけで､ キーが上記のcompanyリレーションの子と一致することがおわかりいただけると幸いです｡ 

22
00:01:53,640 --> 00:01:57,440
この値は､ 前に見たのと全く同じように､ リレーションの型になります｡ 

23
00:01:57,450 --> 00:02:00,240
この場合､ 社員になるわけですね｡ 

24
00:02:01,330 --> 00:02:01,750
わかりました｡ 

25
00:02:01,750 --> 00:02:06,640
最初は少しわかりにくいかもしれませんので､ この機能の内容をおさらいしておきましょう｡ 

26
00:02:06,940 --> 00:02:12,910
部門と供給関係の両方の親リレーションである会社リレーションがあります｡ 

27
00:02:13,060 --> 00:02:16,720
そのため､ 企業には複数の部門やサプライヤーが存在することがあります｡ 

28
00:02:17,260 --> 00:02:24,040
今､ 私たちは､ 会社が複数の従業員を持つことができると定義していますが､ これは､ これまでとは別のレベルの関係を追加するものです｡

29
00:02:24,550 --> 00:02:30,430
これは､ リレーション・サブジェクトのキーに既存のリレーション・タイプ の名前を指定し､ あとは今までと同じように子リレーション・タイプを定義するだけで

30
00:02:30,430 --> 00:02:34,660
す｡

31
00:02:35,290 --> 00:02:42,340
これで､ 先ほどの図にあった､ そして今画面でご覧になっている3つの構造にマッチしたリレーションができあがりました｡

32
00:02:43,030 --> 00:02:48,310
では､ このクエリを実行してみましょう｡ 新しいリレーションにドキュメントを追加する方法を紹介します｡ 

33
00:02:49,900 --> 00:02:50,320
わかりました｡ 

34
00:02:50,320 --> 00:02:52,450
これでインデックスが作成されたわけです｡ 

35
00:02:53,140 --> 00:02:56,200
この下にいくつか問い合わせがあるので､ スクロールさせてください｡ 

36
00:02:56,590 --> 00:03:02,230
ということで､ 会社や部署を追加するクエリは､ 前回の講義で見たクエリと全く同じなので､

37
00:03:02,230 --> 00:03:04,840
あらかじめ用意しておきました｡

38
00:03:05,230 --> 00:03:07,270
まずはこの2つのクエリを実行してみましょう｡ 

39
00:03:11,860 --> 00:03:12,820
わかりました｡ 

40
00:03:12,970 --> 00:03:16,990
これで､ 従業員の追加という重要な部分に集中することができます｡ 

41
00:03:17,440 --> 00:03:23,080
このキャリアも､ ルーティングのクエリパラメータと親のオプションを除いて､ あらかじめ用意しておきました｡

42
00:03:23,500 --> 00:03:27,580
これはタイピングの手間を省くためで､ あとはまったく同じです｡ 

43
00:03:27,580 --> 00:03:33,100
そして実際､ 親オプションも同様で､ 所属する部署のIDが含まれているはずです｡ 

44
00:03:33,280 --> 00:03:34,870
この場合はそうだろう｡ 

45
00:03:34,870 --> 00:03:37,180
では､ さっそく記入してみましょう｡ 

46
00:03:37,600 --> 00:03:40,900
そこで､ ここに降りてきて､ 親オプションを2つに設定します｡ 

47
00:03:41,590 --> 00:03:48,070
新しいのはルーティングクエリーパラメーターで､ これはもはや親ドキュメントのIDであってはならないからです｡ 

48
00:03:48,220 --> 00:03:52,120
私たちのマッピングでは､ 社員は会社の孫にあたります｡ 

49
00:03:52,270 --> 00:04:00,370
ここで必要なのは､ 文書の祖父母である部署が所属する会社のIDを指定することです｡

50
00:04:00,730 --> 00:04:05,920
この例では､ 会社のIDが1なので､ それを値として入力しましょう｡ 

51
00:04:07,710 --> 00:04:08,040
ようなものです｡ 

52
00:04:08,040 --> 00:04:15,210
つまり､ ドキュメントを正しいシャードにルーティングする必要があるため､ 先ほどと同じ理由です｡

53
00:04:15,390 --> 00:04:23,640
しかし､ 複数レベルのリレーションを使用する場合､ ドキュメント階層の最上位にあるドキュメントを含むシャードにルートを設定する必要があります｡

54
00:04:24,440 --> 00:04:24,800
わかりました｡ 

55
00:04:24,800 --> 00:04:26,840
そして､ このクエリも実行してみましょう｡ 

56
00:04:28,190 --> 00:04:28,640
わかりました｡ 

57
00:04:28,640 --> 00:04:35,600
さて､ 多階層関係の文脈で文書をインデックス化する方法はわかりましたが､ 検索についてはどうでしょうか｡

58
00:04:35,960 --> 00:04:38,670
その答えはいたってシンプルです｡ 

59
00:04:38,690 --> 00:04:44,330
すでにご覧になったのと同じように､ i.で行うのです｡  e. を､ これまでの講義で見た手がかり､ つまり､ has

60
00:04:44,330 --> 00:04:50,210
underscored parents, has underscored children, parent underscore ID クエリを使うことで､

61
00:04:50,240 --> 00:04:51,440
実現できます｡

62
00:04:51,740 --> 00:04:59,480
2つの型の関係を操作するだけなので､ 多段関係の文脈でも何ら変わりなく機能する｡

63
00:04:59,900 --> 00:05:06,440
クエリーは､ これらのタイプがどの階層に配置されているかには関係ないので､ 全く同じように動作します｡

64
00:05:06,890 --> 00:05:14,200
とはいえ､ 複数の関係レベルで一致する文書を制限したい場合は､ クエリをネストする必要があるかもしれない｡

65
00:05:14,210 --> 00:05:17,270
では､ どのようにすればいいのか､ 例を挙げてみましょう｡ 

66
00:05:17,750 --> 00:05:25,490
例に入る前に､ 次のクエリが機能することを実際に証明できるように､ いくつかのドキュメントを手早く追加したいと思います｡

67
00:05:25,760 --> 00:05:30,620
もう少し下にクエリがあるので､ スクロールしてみます｡ 

68
00:05:34,260 --> 00:05:43,170
そこで､ すでに用意したいくつかのクエリを実行し､ John Doeという従業員を持つマーケティング部門を持つ新しい会社を追加するだけにします｡

69
00:05:43,350 --> 00:05:45,480
だから､ これを自由に走らせよう｡ 

70
00:05:50,990 --> 00:05:51,410
素晴らしい｡ 

71
00:05:51,440 --> 00:05:53,540
これで少しはデータが増えましたね｡ 

72
00:05:53,690 --> 00:06:02,490
従業員型は会社型の孫にあたるので､ John Doeという従業員がいる会社を取得したいとします｡

73
00:06:02,510 --> 00:06:09,200
間に部署型を挟んでいるので､ Hessのアンダースコアの子クエリを使うだけでなく､ もう少し工夫が必要です｡

74
00:06:09,620 --> 00:06:17,120
つまり､ より明確に言えば､ John Doeという従業員を持つ部署が少なくとも1つある会社を見つけたいのです｡

75
00:06:17,450 --> 00:06:19,490
さっそくそのクエリを作ってみましょう｡ 

76
00:06:20,150 --> 00:06:25,460
まず､ 部門タイプにヘスのアンダースコアの子クエリを使用します｡ なぜなら､ 与えられたクエリに一致する部門を持つ企業を見つけたいからです｡

77
00:06:25,460 --> 00:06:30,950
クエリはすぐに定義されます｡

78
00:06:31,700 --> 00:06:34,580
では､ さっそくクエリーを打ち込んでみましょう｡ 

79
00:06:35,600 --> 00:06:36,710
だから､ 得る｡ 

80
00:06:37,480 --> 00:06:45,910
会社や検索APIをいつものようにクエリオブジェクトとHaskellクエリで｡ 

81
00:06:45,910 --> 00:06:49,210
だから､ 型は部門になるんです｡ 

82
00:06:50,920 --> 00:06:53,470
そして､ 次はクエリオブジェクトの作成に取りかかりましょう｡ 

83
00:06:54,010 --> 00:06:57,700
そこで今度は､ 部門に対する制約を定義する必要があります｡ 

84
00:06:58,000 --> 00:07:03,190
あるいは実は部門そのものに制約をかけたいのではなく､

85
00:07:03,190 --> 00:07:04,990
社員との関係です｡

86
00:07:05,200 --> 00:07:12,910
そこで､ 従業員を含む部門をマッチングさせたいのですが､ これがまたHessのアンダースコアの子クエリにぴったりなのです｡

87
00:07:13,450 --> 00:07:24,640
そこで､ Hessのアンダースコアの子��エリをhasのアンダースコアの子クエリにネストさせることにします｡

88
00:07:24,670 --> 00:07:27,820
先に打ち込んでおいて､ その後に説明しましょう｡ 

89
00:07:28,270 --> 00:07:31,000
そこで､ ここにもう一つHaskellのクエリを追加することにする｡ 

90
00:07:31,630 --> 00:07:39,640
これから従業員のドキュメントタイプやリレーションタイプに制約を加えるので､ タイプを従業員に設定することにします｡

91
00:07:40,630 --> 00:07:46,060
この新しいクエリーオブジェクトの中で､ 先ほど述べたように､ マッチングさせたい従業員に制約を追加することができます｡

92
00:07:46,390 --> 00:07:52,390
今回は､ John Doeという社員名を検索するだけなので､ queryという用語とキーワードマッピングを使ってみます｡

93
00:07:53,140 --> 00:07:55,540
では､ ここに用語クエリを追加してみましょう｡ 

94
00:07:56,110 --> 00:08:02,710
そこで､ フィールドはnameで､ キーワードマッピングを使って､ John Doeを値として指定することにします｡ 

95
00:08:03,280 --> 00:08:04,330
そして､ それだけです｡ 

96
00:08:04,450 --> 00:08:11,980
このクエリを実行する前に､ このクエリが何をするのか､ ちょっとだけおさらいしておきましょう｡ 少しわかりにくいかもしれませんね｡

97
00:08:12,430 --> 00:08:18,820
最初のHessアンダースコアの子クエリは､ クエリに一致する部門を含むすべての会社を検索します｡ 

98
00:08:19,240 --> 00:08:25,930
この場合､ このクエリはアンダースコアの子クエリであり､ John Doeという名前の従業員を見つけることができます｡

99
00:08:26,290 --> 00:08:33,190
したがって､ 最内部にアンダースコアがある場合､ 子クエリは少なくとも1つのドキュメントiを返します｡  e. 従業員の部門が一番外側のアンダースコア付きの子クエリに含まれ､

100
00:08:33,190 --> 00:08:40,120
その結果､ 会社が含まれるようになります｡

101
00:08:40,360 --> 00:08:41,980
ご理解いただけると幸いです｡ 

102
00:08:42,370 --> 00:08:44,860
試しにクエリを実行し､ 結果を確認してみましょう｡ 

103
00:08:47,840 --> 00:08:53,780
このように､ 会社というのは､ 先ほど追加した会社よりもずっと具体的なものなのです｡ 

104
00:08:53,960 --> 00:09:00,620
1社目は､ John Doeという従業員が働いている部署がないため､ マッチングされない｡

105
00:09:00,980 --> 00:09:04,010
名前を私の名前に変えてみて､ どうなるか見てみましょう｡ 

106
00:09:09,890 --> 00:09:12,920
これで､ 代わりに他社がマッチングしていることがわかる｡ 

107
00:09:13,040 --> 00:09:17,770
そして､ 名前を何かインチキに変えても､ どの会社もマッチングしていないと見るべきでしょう｡ 

108
00:09:17,780 --> 00:09:18,920
では､ そうしましょう｡ 

109
00:09:20,730 --> 00:09:23,010
そして実際､ 今はどの企業もマッチしていない｡ 

110
00:09:23,700 --> 00:09:25,230
よし､ これでいいんだ｡ 

111
00:09:25,260 --> 00:09:29,220
これが､ 多値関係の定義と問い合わせの両方の方法である｡ 

112
00:09:29,460 --> 00:09:36,310
今､ 多値関係のクエリの例を見たが､ 既に見たクルーズを好きなように使うことができる｡

113
00:09:36,330 --> 00:09:41,160
どのようなデータを扱うか､ どのようなデータを取り出したいかによります｡ 
