1

00:00:02,719  -->  00:00:07,990
We have now covered some basic things about
mapping in Elasticsearch, so let’s now get

2

00:00:07,990  -->  00:00:10,280
started actually creating some mapping!

3

00:00:11,320  -->  00:00:16,059
You can add field mappings both when creating
an index and afterwards.

4

00:00:16,640  -->  00:00:21,400
Let’s start out defining the mapping when
creating a new index, since that’s typically

5

00:00:21,410  -->  00:00:24,439
the first way that you will interact with
mapping.

6

00:00:24,440  -->  00:00:28,700
We do that by defining the mappings within
a “mappings” key when we add a new index,

7

00:00:28,720  -->  00:00:30,040
so let’s type that out.

8

00:00:40,560  -->  00:00:44,380
All field mappings should be defined within
a “properties” key.

9

00:00:44,390  -->  00:00:49,410
That’s the case for fields at every level
of the hierarchy, including nested objects

10

00:00:49,410  -->  00:00:51,470
as you have already seen.

11

00:00:51,470  -->  00:00:52,880
So let’s add the “properties” key.

12

00:00:55,100  -->  00:00:58,500
Great, so now we are ready to define the field
mappings.

13

00:00:58,900  -->  00:01:03,980
We do that by specifying the field names as
keys and add objects as the values.

14

00:01:04,560  -->  00:01:09,940
I’ll add four fields; “rating,” “content,”
“product_id,” and “author.”

15

00:01:27,320  -->  00:01:32,200
The “author” field is going to be an object,
so that one is a bit special.

16

00:01:32,200  -->  00:01:36,890
For the three other fields, we simply define
their data type with a “type” key, so

17

00:01:36,890  -->  00:01:38,060
let’s type that out.

18

00:02:05,360  -->  00:02:09,920
In place of “float,” “text,” and “integer,”
you can of course use any of the data types

19

00:02:09,920  -->  00:02:11,180
that you saw earlier.

20

00:02:12,280  -->  00:02:15,480
The “author” field is a bit special because
it’s an object.

21

00:02:15,490  -->  00:02:19,590
That’s why we need to add a “properties”
key again, just like we did at the root level

22

00:02:19,590  -->  00:02:21,070
of the mapping.

23

00:02:21,070  -->  00:02:26,280
This tells Elasticsearch that it is dealing
with an object containing mappings for its keys.

24

00:02:30,040  -->  00:02:34,440
Within this “properties” key, we define
mappings exactly as we did at the root level

25

00:02:34,450  -->  00:02:35,760
of the mapping.

26

00:02:35,760  -->  00:02:41,400
In this case I will define three mappings;
“first_name,” “last_name,” and “email.”

27

00:03:06,840  -->  00:03:10,780
If you wanted to, you could nest objects even
further than this.

28

00:03:11,600  -->  00:03:16,260
As you know, “keyword” fields are used
for filtering and aggregations, and for exact

29

00:03:16,260  -->  00:03:17,260
matches.

30

00:03:17,260  -->  00:03:21,670
That’s why I chose the “keyword” data
type for the nested “email” field.

31

00:03:21,670  -->  00:03:26,230
When choosing between the “text” and “keyword”
data types, it’s important to consider how

32

00:03:26,230  -->  00:03:28,440
the field will be queried.

33

00:03:28,440  -->  00:03:31,810
Will we need to perform a full-text search
on the e-mail address?

34

00:03:31,810  -->  00:03:33,060
Probably not.

35

00:03:33,480  -->  00:03:38,460
Instead, it’s much more likely that we will
be searching for all reviews left by a user

36

00:03:38,470  -->  00:03:41,200
containing a specific e-mail address.

37

00:03:41,200  -->  00:03:46,290
Or perhaps performing aggregations on the
e-mail address to see how many reviews a given

38

00:03:46,290  -->  00:03:48,140
user has written.

39

00:03:48,380  -->  00:03:53,140
An alternative to the e-mail address could
be to store the user’s ID as a number.

40

00:03:54,300  -->  00:03:59,360
Alright, we are done with the mapping now,
so let’s run the query to create the index.

41

00:04:01,420  -->  00:04:04,780
The index has now been created with the mapping
that we defined.

42

00:04:05,080  -->  00:04:07,780
Let’s index a document into the index.

43

00:04:07,780  -->  00:04:11,300
To save some time, I will just paste in the
query to do so.

44

00:04:14,300  -->  00:04:19,160
Before running the query, I will just change
the e-mail address to an object, just to show

45

00:04:19,160  -->  00:04:22,280
that Elasticsearch will then refuse to index
the document.

46

00:04:29,700  -->  00:04:35,080
Indeed Elasticsearch refuses the document
because one of the supplied values is invalid

47

00:04:35,080  -->  00:04:36,680
compared to the field’s mapping.

48

00:04:37,560  -->  00:04:42,580
The reason I supplied an object and not an
integer, for instance, is that the integer

49

00:04:42,580  -->  00:04:47,500
would just be coerced into a string, and Elasticsearch
would index the document as normal.

50

00:04:48,160  -->  00:04:51,880
That’s the default behavior since we didn’t
disable coercion.

51

00:04:52,880  -->  00:04:55,820
I’ll just revert the change and run the
query again.

52

00:05:00,060  -->  00:05:04,280
The document has now been indexed correctly
and is therefore searchable.

53

00:05:05,400  -->  00:05:10,920
That’s really the basics of explicitly adding
mappings, at least when creating a new index.

54

00:05:11,360  -->  00:05:16,200
Before wrapping up this lecture, I just want
to mention that there is no naming convention

55

00:05:16,200  -->  00:05:17,280
for field names.

56

00:05:17,980  -->  00:05:21,900
As long as you are consistent, you can name
your fields however you want.

57

00:05:22,660  -->  00:05:29,280
That being said, though, camelCase and snake_case
seem to be the most widely used for JSON,

58

00:05:29,580  -->  00:05:31,780
so I would recommend using one of those.
