1

00:00:02,560  -->  00:00:07,340
It may come as a surprise to you that a field
may actually be mapped in multiple ways.

2

00:00:08,180  -->  00:00:12,840
For instance, a “text” field may be mapped
as a “keyword” field at the same time.

3

00:00:13,360  -->  00:00:15,040
That’s what we will look at in this lecture.

4

00:00:16,400  -->  00:00:21,320
I have a simple query prepared, which creates
a throwaway index with two fields; “description”

5

00:00:21,620  -->  00:00:23,800
and “ingredients.”

6

00:00:24,920  -->  00:00:30,760
As a quick reminder, remember how every field
in Elasticsearch may store zero or more values

7

00:00:30,820  -->  00:00:31,740
by default.

8

00:00:32,180  -->  00:00:35,800
That’s why we haven’t defined that the
“ingredients” field will contain multiple

9

00:00:35,960  -->  00:00:40,360
values; we simply specify an array of values
when indexing documents.

10

00:00:41,600  -->  00:00:47,460
Imagine that we have a blog full of food recipes,
and we want users to be able to search through them.

11

00:00:48,360  -->  00:00:53,680
Suppose that a user searches for “spaghetti,”
in which case we want to search for that value

12

00:00:53,900  -->  00:00:58,280
in both the recipe description, but also within
the ingredients.

13

00:00:58,820  -->  00:01:01,680
We can do that just fine with the two text
fields.

14

00:01:02,100  -->  00:01:06,940
“text” fields are used for performing
full-text searches that do not require exact

15

00:01:06,940  -->  00:01:11,860
matches, so this data type is often used together
with raw user input.

16

00:01:12,840  -->  00:01:19,280
Suppose that besides providing search functionality
to end users, we want an index page that lists

17

00:01:19,280  -->  00:01:22,180
all ingredients and how many recipes use them.

18

00:01:22,700  -->  00:01:26,740
That’s a job for aggregations, which we
will look at later in the course.

19

00:01:27,660  -->  00:01:33,200
For reasons that I won’t get into right now, we 
cannot run aggregations on “text” fields.

20

00:01:34,280  -->  00:01:37,160
Instead, we need to use the “keyword”
data type.

21

00:01:38,120  -->  00:01:43,200
To be clear, aggregations can also be run
on dates and numbers, but that won’t help

22

00:01:43,240  -->  00:01:44,700
us in this example.

23

00:01:45,820  -->  00:01:51,380
The point of the matter is that to run aggregations
on text values, we need to use the “keyword”

24

00:01:51,380  -->  00:01:52,260
data type.

25

00:01:53,600  -->  00:01:59,060
Since we also need the “text” data type, we basically need two mappings for the “ingredients” field.

26

00:01:59,720  -->  00:02:03,660
You probably guessed it - we can add another
mapping to the field.

27

00:02:04,560  -->  00:02:09,640
We do that by specifying a “fields” mapping
parameter containing other mappings for a field.

28

00:02:10,060  -->  00:02:12,700
Let’s type that out before going into more
detail.

29

00:02:30,120  -->  00:02:34,480
Alright, so what I just did was to add an
additional mapping to the “ingredients”

30

00:02:34,600  -->  00:02:36,020
field named “keyword.”

31

00:02:37,340  -->  00:02:42,780
At first it might seem confusing that both
the name and data type is set to “keyword.”

32

00:02:43,680  -->  00:02:48,520
This is just a matter of convention; you can
name the mapping anything you want, but I

33

00:02:48,600  -->  00:02:51,460
recommend that you name it “keyword” as
in this case.

34

00:02:52,240  -->  00:02:55,980
You will see how this makes sense in a moment
when I show you how to query this particular

35

00:02:55,980  -->  00:02:56,900
mapping.

36

00:02:59,080  -->  00:03:01,160
First, let’s index a document.

37

00:03:01,400  -->  00:03:06,280
To save some typing, I have prepared the query
in advance, since it contains nothing that

38

00:03:06,380  -->  00:03:07,620
you haven’t seen before.

39

00:03:08,240  -->  00:03:12,780
Notice how there is no sign of the “keyword”
mapping when indexing documents; we simply

40

00:03:12,780  -->  00:03:17,840
specify the field in the same way as we would
if there was no additional field mapping.

41

00:03:18,480  -->  00:03:19,620
Let’s run the query.

42

00:03:23,080  -->  00:03:27,300
Okay, so what actually happened behind the
scenes when indexing the document?

43

00:03:28,160  -->  00:03:33,540
As you know, “text” fields are analyzed,
so an inverted index was populated with the

44

00:03:33,600  -->  00:03:36,040
terms that were emitted by the analyzer.

45

00:03:36,700  -->  00:03:38,440
That was done for each “text” field.

46

00:03:38,980  -->  00:03:39,900
Nothing new here.

47

00:03:40,680  -->  00:03:45,680
However, since we have an additional mapping
for the “ingredients” field, another inverted

48

00:03:45,680  -->  00:03:50,340
index was created for the field, this time
using the “keyword” analyzer.

49

00:03:50,980  -->  00:03:56,620
It therefore contains the unmodified values,
meaning that the terms have not been lowercased.

50

00:03:57,740  -->  00:04:03,380
This inverted index is optimized for exact
matches, and we can use it for aggregations

51

00:04:03,380  -->  00:04:04,720
and sorting as well.

52

00:04:05,580  -->  00:04:10,680
Had we made use of stemming, for instance,
the differences between the two mappings would

53

00:04:10,680  -->  00:04:13,200
be more apparent, but I am sure you get the
idea.

54

00:04:16,580  -->  00:04:20,680
If we run a “match_all” search query,
we will see that the “ingredients” field

55

00:04:20,680  -->  00:04:23,320
within the results looks exactly as normal.

56

00:04:27,180  -->  00:04:31,900
We can query the field exactly as normal with
a “match” query, which is the main query

57

00:04:31,900  -->  00:04:33,520
used for full-text searches.

58

00:04:36,440  -->  00:04:41,120
To search for exact values, we need to use
something called a term level query.

59

00:04:41,640  -->  00:04:46,380
Don’t worry about these queries for now, as we 
will get back to all of them later in the course.

60

00:04:47,020  -->  00:04:52,040
All you need to know is that the “term”
query requires an exact match for the target field.

61

00:04:52,760  -->  00:04:57,160
When doing exact matches on text values, we
should query a “keyword” mapping.

62

00:04:58,020  -->  00:05:01,280
We will take a closer look at why that is
the case a bit later in the course.

63

00:05:02,200  -->  00:05:07,300
To query the “keyword” mapping, we specify
the field name, a dot, followed by the name

64

00:05:07,300  -->  00:05:09,800
of the mapping — “keyword” in this case.

65

00:05:10,800  -->  00:05:15,800
Unlike the query we just ran, this one will
query the inverted index containing the raw

66

00:05:15,800  -->  00:05:20,860
string values supplied at index time - i.e.
values that were not analyzed.

67

00:05:24,280  -->  00:05:27,040
Running the query, we can see that it works
as well.

68

00:05:28,180  -->  00:05:30,980
That’s how you can define multiple mappings
for a field.

69

00:05:31,540  -->  00:05:35,880
This is useful in situations where you need
to query a field in different ways.

70

00:05:36,400  -->  00:05:41,200
In this lecture we saw that with a “text”
field that also contained a “keyword” mapping.

71

00:05:42,340  -->  00:05:46,820
This allows us to use the “text” mapping
for full-text searches and the “keyword”

72

00:05:47,020  -->  00:05:48,740
mapping for aggregations and sorting.

73

00:05:50,040  -->  00:05:54,420
This is probably the most common use case
of multi-fields, but it is definitely not

74

00:05:54,500  -->  00:05:55,580
the only one.

75

00:05:56,400  -->  00:06:00,480
You have much more control of how values are
indexed than just the data type, because you

76

00:06:00,620  -->  00:06:03,260
can change mapping parameters as well.

77

00:06:04,460  -->  00:06:09,680
An example could be to configure synonyms
or stemming in different ways for a single field.

78

00:06:10,320  -->  00:06:15,680
Or having an additional mapping for the “description”
field that is optimized for auto-completion

79

00:06:15,680  -->  00:06:17,840
and “search-as-you-type” functionality.

80

00:06:18,780  -->  00:06:24,540
Anyway, the use cases for multi-fields are
many, so this is an incredibly powerful feature.

81

00:06:25,660  -->  00:06:30,200
Lastly, I will just get rid of this temporary
index since we don’t need it anymore.

82

00:06:33,040  -->  00:06:34,360
I will see you in the next lecture!
