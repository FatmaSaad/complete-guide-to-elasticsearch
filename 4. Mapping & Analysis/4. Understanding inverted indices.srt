1

00:00:02,590  -->  00:00:08,290
Alright, now that you know the basics of text
analysis in Elasticsearch, let’s take a

2

00:00:08,290  -->  00:00:12,280
look at what actually happens with the result,
being the tokens.

3

00:00:13,300  -->  00:00:17,440
A couple of different data structures are
used to store field values.

4

00:00:18,200  -->  00:00:22,360
The data structure that is used for a field
depends on its data type.

5

00:00:23,240  -->  00:00:28,600
The reason Elasticsearch uses more than one
data structure, is to ensure efficient data

6

00:00:28,600  -->  00:00:31,060
retrieval for different access patterns.

7

00:00:32,100  -->  00:00:37,620
For example, searching for a given term is
handled differently than aggregating data.

8

00:00:38,540  -->  00:00:43,940
Actually these data structures are all handled
by Apache Lucene and not Elasticsearch.

9

00:00:44,640  -->  00:00:49,480
I will get back to some of the data structures
later, because I want to focus on one in this

10

00:00:49,480  -->  00:00:53,180
lecture; namely one called an inverted index.

11

00:00:54,680  -->  00:01:00,680
An inverted index is essentially a mapping
between terms and which documents contain them.

12

00:01:01,560  -->  00:01:06,580
Note that by “term,” I am referring to
the tokens that are emitted by the analyzer.

13

00:01:07,520  -->  00:01:13,560
Generally speaking, the “token” terminology
is only used in the context of analyzers,

14

00:01:14,000  -->  00:01:16,980
so you will mostly hear me say “terms.”

15

00:01:17,820  -->  00:01:22,619
Anyway, let’s take the example from the
previous lecture and see how that would be

16

00:01:22,620  -->  00:01:24,760
stored within an inverted index.

17

00:01:26,460  -->  00:01:32,560
As you can see, each unique term is placed
in the index together with information about

18

00:01:32,560  -->  00:01:34,920
which documents contain the term.

19

00:01:35,820  -->  00:01:40,859
This is stored as document IDs internally
but illustrated differently on the diagram

20

00:01:40,860  -->  00:01:41,980
for simplicity.

21

00:01:43,000  -->  00:01:45,740
Notice how the terms are sorted alphabetically.

22

00:01:46,980  -->  00:01:53,200
This example is for an index with a single
document, so that’s of course not very exciting,

23

00:01:53,200  -->  00:01:55,640
as each term only appears in one document.

24

00:01:56,400  -->  00:02:01,480
Let’s index a couple of more documents into
it and see what the inverted index then looks like.

25

00:02:02,960  -->  00:02:06,400
This made the inverted index just slightly
more interesting.

26

00:02:07,220  -->  00:02:12,400
If you want to have a closer look at it, then
I encourage you to pause the video for a moment.

27

00:02:13,620  -->  00:02:18,660
I’m sure you can imagine how this index
would grow as more documents are indexed.

28

00:02:19,300  -->  00:02:24,720
What makes an inverted index so powerful is
how efficient it is to look up a term and

29

00:02:24,720  -->  00:02:27,800
find the documents in which the term appears.

30

00:02:28,680  -->  00:02:31,980
Suppose that we perform a search for the term
“ducks.”

31

00:02:32,720  -->  00:02:38,000
Figuring out which documents contain that
term is just a matter of performing a simple

32

00:02:38,000  -->  00:02:40,240
lookup in the inverted index.

33

00:02:41,180  -->  00:02:45,880
Doing that, we can see that documents #1 and
#3 contain the term.

34

00:02:46,700  -->  00:02:51,500
That makes the process of searching for a
term super simple and efficient.

35

00:02:51,500  -->  00:02:52,640
Simple stuff, right?

36

00:02:53,600  -->  00:02:59,200
The reason the index is called an inverted
index is just that the more logical mapping

37

00:02:59,200  -->  00:03:04,420
would be to have a mapping from documents
to the terms they contain, i.e. the other

38

00:03:04,420  -->  00:03:05,420
way around.

39

00:03:06,000  -->  00:03:10,999
That doesn’t provide the fast lookups that
we need, so that’s why the relationship

40

00:03:11,000  -->  00:03:11,920
is inverted.

41

00:03:12,920  -->  00:03:17,880
That’s all there is to the terminology,
so it sounds more fancy than it really is.

42

00:03:18,840  -->  00:03:24,060
It should be said, though, that the inverted
index you saw was a slight simplification.

43

00:03:24,720  -->  00:03:30,440
The inverted indices that are stored within
Apache Lucene contain a bit more information,

44

00:03:30,440  -->  00:03:33,220
such as data that is used for relevance scoring.

45

00:03:33,960  -->  00:03:38,680
As you can imagine, we don’t just want to
get the documents back that contain a given

46

00:03:38,680  -->  00:03:42,879
term; we also want them to be ranked by how
well they match.

47

00:03:43,520  -->  00:03:47,120
That’s a topic for later in the course,
so we will get to that.

48

00:03:48,260  -->  00:03:52,000
Now you know the basics of what an inverted
index is.

49

00:03:52,520  -->  00:03:57,659
The examples that I showed you were just for
a couple of sentences assumed to belong to

50

00:03:57,660  -->  00:03:58,780
the same field.

51

00:03:59,580  -->  00:04:04,680
What happens if we index documents containing
a number of different fields as you see on

52

00:04:04,680  -->  00:04:05,720
your screen now?

53

00:04:06,360  -->  00:04:10,960
Are all the values stored within the same
inverted index, or what happens?

54

00:04:11,800  -->  00:04:17,400
An inverted index is actually created for
each text field, meaning that we will have

55

00:04:17,410  -->  00:04:22,460
two inverted indices in this example; one
for the “name” field, and one for the

56

00:04:22,460  -->  00:04:23,620
“description” field.

57

00:04:24,640  -->  00:04:30,040
The text is analyzed and stored in the same
way as you just saw, so the key thing here

58

00:04:30,040  -->  00:04:35,640
is to understand that an inverted index exists
within the scope of a field.

59

00:04:36,760  -->  00:04:40,920
You can see the two inverted indices that
would be created on your screen now.

60

00:04:41,580  -->  00:04:44,680
Go ahead and pause the video if you want to
take a closer look at it.

61

00:04:46,040  -->  00:04:50,740
But why did I say that there will be one inverted
index per text field?

62

00:04:51,340  -->  00:04:56,060
That’s because fields with other data types
use different data structures.

63

00:04:56,580  -->  00:05:04,139
For example, numeric, date, and geospatial
fields are all stored as BKD trees, because

64

00:05:04,140  -->  00:05:09,080
this data structure is very efficient for
geospatial and numeric range queries.

65

00:05:10,260  -->  00:05:15,580
Dates are included because dates are actually
stored as “long” values internally, but

66

00:05:15,580  -->  00:05:18,140
I will get back to that in a couple of lectures.

67

00:05:19,380  -->  00:05:24,280
Alright, let’s take a short moment to recap
on what we covered in this lecture, because

68

00:05:24,280  -->  00:05:25,720
it’s super important.

69

00:05:26,700  -->  00:05:32,620
When text fields are analyzed, the resulting
terms are placed into an inverted index.

70

00:05:33,300  -->  00:05:38,960
This happens for every “text” field, so
each field has a dedicated inverted index.

71

00:05:39,720  -->  00:05:45,600
An inverted index is a sorted mapping of the
unique terms from all documents containing

72

00:05:45,600  -->  00:05:50,640
a value for a given field, to which documents
contain those terms.

73

00:05:51,460  -->  00:05:56,980
Inverted indices are created and maintained
by Apache Lucene, which Elasticsearch builds

74

00:05:56,980  -->  00:05:57,780
on top of.

75

00:05:58,660  -->  00:06:04,540
Having an inverted index, it is super efficient
to run a query that asks the question: “Which

76

00:06:04,540  -->  00:06:07,220
documents contain the term X?”

77

00:06:07,900  -->  00:06:12,940
An inverted index contains more information
than this mapping, but we will get to that

78

00:06:12,940  -->  00:06:14,060
later in the course.

79

00:06:15,160  -->  00:06:21,780
Inverted indices is one of the data structures
that Elasticsearch uses, but other data structures

80

00:06:21,780  -->  00:06:23,060
are used as well.

81

00:06:23,560  -->  00:06:29,520
For example, numeric values and geospatial
data is stored within BKD trees.

82

00:06:30,180  -->  00:06:35,120
We will get to some of the data structures
later in the course, but for now the important

83

00:06:35,130  -->  00:06:39,020
thing is to understand the basics of what
an inverted index is.
