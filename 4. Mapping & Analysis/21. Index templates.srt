1

00:00:02,580  -->  00:00:06,240
In this lecture we will look at something
called index templates.

2

00:00:07,060  -->  00:00:09,740
Perhaps you can guess what it is based on
the name.

3

00:00:10,460  -->  00:00:16,720
An index template defines settings and/or mappings for indices that match one or more patterns.

4

00:00:17,580  -->  00:00:23,020
A pattern is a wildcard expression that is
matched against an index name whenever a new

5

00:00:23,020  -->  00:00:28,000
index is created, and so index templates only
apply to new indices.

6

00:00:28,900  -->  00:00:33,440
Let me show you what an index template looks
like, and then I will get back to when they are useful.

7

00:00:35,020  -->  00:00:40,240
To save some typing, I have already prepared
part of the query to add a new index template.

8

00:00:41,080  -->  00:00:45,600
Specifically, I have already defined the mappings
for a couple of fields, because that part

9

00:00:45,680  -->  00:00:48,680
doesn’t contain anything you haven’t seen
before.

10

00:00:49,260  -->  00:00:52,020
Well, almost, but I will get back to that.

11

00:00:53,220  -->  00:00:59,620
We can add a new index template by using the Index Template API together with the PUT HTTP verb.

12

00:01:00,660  -->  00:01:05,320
The request path is “_template” followed
by the name of the index template.

13

00:01:06,760  -->  00:01:11,060
I have named the template “access-logs”
because it’s going to define mappings for

14

00:01:11,060  -->  00:01:13,880
indices storing HTTP access logs.

15

00:01:14,560  -->  00:01:19,640
There is one important part missing, though;
the index patterns that define which indices

16

00:01:19,660  -->  00:01:21,660
this template should be applied to.

17

00:01:22,520  -->  00:01:28,420
Those should be defined within an “index_patterns”
parameter consisting of an array of strings.

18

00:01:36,540  -->  00:01:42,180
As mentioned a moment ago, index patterns
are essentially index names where parts of

19

00:01:42,180  -->  00:01:43,940
them may be wildcards.

20

00:01:44,740  -->  00:01:49,600
You don’t have to use wildcards, so you
can perfectly fine just specify the exact

21

00:01:49,600  -->  00:01:54,800
index names, but that probably defeats the
purpose of using an index template.

22

00:01:55,880  -->  00:02:00,720
In this case I will specify an index pattern
with an asterisk wildcard at the end.

23

00:02:10,720  -->  00:02:12,760
So what’s the point of this pattern?

24

00:02:13,720  -->  00:02:19,060
Elasticsearch is often used to store time
series data, which can be a lot of different

25

00:02:19,060  -->  00:02:22,560
things, just as long as the entries are sorted
chronologically.

26

00:02:23,580  -->  00:02:29,900
Typically an equal amount of time will occur between each data point, but that is not a requirement.

27

00:02:31,040  -->  00:02:36,240
For example, we could capture and store the
hardware usage of servers every minute, or

28

00:02:36,240  -->  00:02:37,700
perhaps every second.

29

00:02:38,580  -->  00:02:42,220
Or we could ping an API endpoint to store
uptime information.

30

00:02:43,600  -->  00:02:47,400
This is actually what Metricbeat and Heartbeat
does, respectively.

31

00:02:48,200  -->  00:02:53,540
In fact, they also utilize index patterns
to apply mappings and index settings.

32

00:02:54,960  -->  00:02:58,760
So why did I include a wildcard at the end
of the index pattern?

33

00:02:59,440  -->  00:03:03,740
Because time series data is often divided
into multiple indices.

34

00:03:04,340  -->  00:03:10,920
How many depends on the data volume, so it could be per year, month, week, or day, for  instance.

35

00:03:12,200  -->  00:03:16,780
A common approach is to create one index per
day for large data volumes.

36

00:03:17,400  -->  00:03:19,440
Think millions of entries per day.

37

00:03:20,260  -->  00:03:24,080
For fewer entries, you could get away with
far fewer indices.

38

00:03:24,880  -->  00:03:29,600
There are numerous reasons for doing this,
but I don’t want to get into details now.

39

00:03:30,420  -->  00:03:34,040
For monthly indices, the index names could
look like this.

40

00:03:35,700  -->  00:03:38,640
For daily indices, a common pattern is the
following.

41

00:03:40,540  -->  00:03:43,840
Those index names are all matched by our pattern.

42

00:03:44,420  -->  00:03:49,819
This means that if we create a new index for
tomorrow’s access logs, the mappings that

43

00:03:49,820  -->  00:03:52,500
we have defined will automatically be created.

44

00:03:53,060  -->  00:03:54,100
Pretty cool, right?

45

00:03:55,460  -->  00:04:01,380
Apart from specifying mappings, an index template
can also contain index settings.

46

00:04:01,780  -->  00:04:04,580
Let’s specify the number of shards, first
of all.

47

00:04:05,200  -->  00:04:09,820
The format is the same as you saw earlier
in the course, so let me just type that out.

48

00:04:17,340  -->  00:04:21,900
Just as you have seen before, we could also
define the number of replica shards here if

49

00:04:21,900  -->  00:04:22,960
we wanted to.

50

00:04:23,460  -->  00:04:26,300
Instead, I am going to disable type coercion.

51

00:04:27,460  -->  00:04:32,400
Disabling it at the index level means that
every field inherits the setting and uses

52

00:04:32,400  -->  00:04:34,040
it unless it is overridden.

53

00:04:44,060  -->  00:04:47,220
Alright, let’s run the query to add the
index template.

54

00:04:50,180  -->  00:04:54,920
Now that the index template has been added,
let’s create a new index that matches the

55

00:04:54,940  -->  00:04:56,920
index pattern of the template.

56

00:04:57,500  -->  00:05:03,360
Specifically, an index to contain access logs
for the 1st of January, 2020.

57

00:05:14,320  -->  00:05:19,540
Let’s inspect the index to ensure that both
the mapping and settings were applied as expected.

58

00:05:20,140  -->  00:05:22,980
For that, we can simply specify the index
name and use

59

00:05:22,980  -->  00:05:24,540
the “GET” HTTP verb.

60

00:05:33,320  -->  00:05:37,780
Within the results, we indeed see both the
mapping and the settings that we specified

61

00:05:37,780  -->  00:05:39,440
within the index template.

62

00:05:39,640  -->  00:05:40,380
Awesome!

63

00:05:41,260  -->  00:05:45,080
Alright, just a few more things to mention
before ending this lecture.

64

00:05:46,160  -->  00:05:52,360
If a new index matches the pattern of an index template, those settings and mappings will be used.

65

00:05:52,940  -->  00:05:58,600
However, if the request to create the new
index also specifies settings or mappings,

66

00:05:58,600  -->  00:06:00,280
the two will be merged together.

67

00:06:01,100  -->  00:06:07,120
In case of duplicates, the configuration from
the create index request will take precedence

68

00:06:07,120  -->  00:06:10,520
and override the value specified within the
index template.

69

00:06:11,300  -->  00:06:16,320
You can see that on the example diagram where
the index template specifies that indices

70

00:06:16,320  -->  00:06:19,180
should have two shards and two replica shards.

71

00:06:20,160  -->  00:06:25,320
When creating an index, the “number_of_shards”
setting is present with a value of three.

72

00:06:26,100  -->  00:06:29,780
This is merged together with the settings
from the index template.

73

00:06:30,780  -->  00:06:35,420
Since there is a duplicate entry, the setting
from the index template is overriden.

74

00:06:36,220  -->  00:06:39,820
The result is therefore three shards and two
replica shards.

75

00:06:41,540  -->  00:06:45,180
A new index may also match more than one index
template.

76

00:06:45,900  -->  00:06:51,300
Index templates can be created with an “order”
parameter which is simply an integer value

77

00:06:51,300  -->  00:06:54,080
representing the priority of the template.

78

00:06:55,160  -->  00:07:00,380
This is used to control which settings take
precedence in cases where an index matches

79

00:07:00,380  -->  00:07:01,840
multiple templates.

80

00:07:03,220  -->  00:07:07,080
Index templates can be updated with new mappings
and settings.

81

00:07:07,600  -->  00:07:14,080
To do this, simply use the same API as when creating the template and send the full new configuration.

82

00:07:14,940  -->  00:07:21,520
This only affects new indices; existing indices
that matched the index template are left untouched.

83

00:07:22,580  -->  00:07:27,900
An index template can be retrieved and deleted
by using the same endpoint with the “GET”

84

00:07:27,900  -->  00:07:30,540
and “DELETE” HTTP verbs, respectively.

85

00:07:32,100  -->  00:07:36,160
Lastly, you might have wondered why I named
the fields the way I did.

86

00:07:36,900  -->  00:07:42,180
Those field names were definitely not the
shortest and simplest ones that I could have chosen.

87

00:07:42,940  -->  00:07:47,180
That’s due to something called the Elastic
Common Schema, which we will take a look at

88

00:07:47,180  -->  00:07:49,540
in the next lecture, so I will see you there!
