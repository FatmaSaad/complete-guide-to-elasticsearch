1

00:00:02,600  -->  00:00:07,240
A bit earlier you saw how to add new field
mappings to an existing index.

2

00:00:07,660  -->  00:00:10,700
But what about updating an existing field
mapping?

3

00:00:11,440  -->  00:00:16,220
The “reviews” index currently contains
a “product_id” field of the type “long.”

4

00:00:17,060  -->  00:00:23,100
That data type has served us well, but for
whatever reason our product IDs may now contain

5

00:00:23,100  -->  00:00:25,160
letters, so we need to change it.

6

00:00:26,500  -->  00:00:30,800
We won’t be performing full-text searches
on the field, so the “text” data type

7

00:00:30,800  -->  00:00:32,080
doesn’t make sense.

8

00:00:32,780  -->  00:00:38,120
Instead, we will use the field for filtering,
i.e. to find the reviews for a given product.

9

00:00:39,560  -->  00:00:43,580
That narrows the data type down to “keyword,”
which is the one we will use.

10

00:00:45,160  -->  00:00:48,100
So how do we actually change the field’s
mapping?

11

00:00:48,620  -->  00:00:53,280
Can we just use the same query that we used
to add a new field mapping to an existing

12

00:00:53,280  -->  00:00:54,060
index?

13

00:00:54,320  -->  00:00:57,160
I have it typed out already, so let’s try.

14

00:00:59,500  -->  00:01:04,500
As you can see, we get an error stating that
the provided data type is different from the

15

00:01:04,500  -->  00:01:05,500
existing one.

16

00:01:06,240  -->  00:01:10,980
The reason is that in general, we cannot update
field mappings in Elasticsearch.

17

00:01:12,160  -->  00:01:17,180
We can add new field mappings as we did earlier,
but once you have added a field mapping, you

18

00:01:17,180  -->  00:01:19,100
are pretty much stuck with it.

19

00:01:19,720  -->  00:01:24,940
There is one exception, though; some mapping
parameters can be updated, but only a few

20

00:01:24,940  -->  00:01:25,840
of them.

21

00:01:27,120  -->  00:01:29,600
Consider the second query on your screen now.

22

00:01:30,140  -->  00:01:34,700
It contains the current mapping for the “email”
field that is nested within the “author”

23

00:01:34,700  -->  00:01:35,200
field.

24

00:01:35,700  -->  00:01:40,820
I will add one of the parameters that can
be added to existing field mappings; namely

25

00:01:40,820  -->  00:01:43,320
the “ignore_above” parameter.

26

00:01:44,380  -->  00:01:49,400
This parameter ignores strings longer than
the specified value such that they will not

27

00:01:49,400  -->  00:01:50,680
be indexed or stored.

28

00:02:04,040  -->  00:02:08,980
As you can see, we were indeed able to modify
the field mapping to include this parameter.

29

00:02:09,500  -->  00:02:13,800
Chances are, though, that you will not be
able to update a field mapping once you have

30

00:02:13,800  -->  00:02:14,660
created it.

31

00:02:15,600  -->  00:02:19,800
There are a number of reasons for that, with
one of the main ones being that documents

32

00:02:19,800  -->  00:02:22,960
might already have been indexed with the existing
field mapping.

33

00:02:24,180  -->  00:02:28,900
If we could just change the mapping, we would
have to reindex any existing documents.

34

00:02:29,780  -->  00:02:34,500
For instance, changing a “text” field
to a “keyword” field is not possible,

35

00:02:34,500  -->  00:02:37,000
because values have already been analyzed.

36

00:02:37,880  -->  00:02:42,580
Our failed attempt to change the “long”
data type to “keyword” also didn’t work.

37

00:02:44,020  -->  00:02:48,140
Remember how numeric values are indexed into
a BKD tree.

38

00:02:48,900  -->  00:02:53,440
Switching to the “keyword” data type would
require that data structure to be converted

39

00:02:53,440  -->  00:02:59,340
to an inverted index, which is essentially
the same as reindexing all of the field’s values.

40

00:03:00,280  -->  00:03:04,800
If you have indexed many millions of documents,
that is going to take a while.

41

00:03:05,700  -->  00:03:10,580
Even if we haven’t indexed any documents
since adding a field mapping, we are still

42

00:03:10,580  -->  00:03:12,060
not allowed to update it.

43

00:03:12,620  -->  00:03:17,320
On top of that, you also cannot remove a field
mapping once you have added it.

44

00:03:18,000  -->  00:03:23,680
While that may sound strange, remember that
the mapping will not be used if a field value

45

00:03:23,680  -->  00:03:29,400
is not supplied when indexing a document,
so we can simply ignore the field moving forward.

46

00:03:30,360  -->  00:03:35,680
If we want to reclaim the storage space used
by the field, we could use the Update By Query

47

00:03:35,680  -->  00:03:40,080
API and remove the field from each matching
document with a script.

48

00:03:41,600  -->  00:03:46,860
There are all kinds of challenges involved
with updating existing field mappings, some

49

00:03:46,860  -->  00:03:49,900
of which don’t even have to do with changing
the data type.

50

00:03:50,940  -->  00:03:55,580
Changing a field mapping almost always requires
documents to be reindexed.

51

00:03:56,060  -->  00:04:01,020
That’s why Elasticsearch protects us by
simply not allowing existing mappings to be

52

00:04:01,020  -->  00:04:04,280
updated - except for a small number of parameters.

53

00:04:05,740  -->  00:04:11,220
So if we cannot update the data type for our
“product_id” field, then what do we do?

54

00:04:12,440  -->  00:04:18,299
We create a new index with the updated mapping
and reindex any existing documents into it.

55

00:04:18,420  -->  00:04:20,580
Let’s see how to do that in the next lecture.
