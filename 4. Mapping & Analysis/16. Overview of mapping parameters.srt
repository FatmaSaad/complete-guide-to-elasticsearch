1

00:00:03,080  -->  00:00:08,300
You have seen how to add a simple mapping
to an index, specifying fields and their data types.

2

00:00:08,820  -->  00:00:14,000
Apart from specifying a field’s data type,
there are also some parameters available that

3

00:00:14,020  -->  00:00:17,160
configure the behavior of fields in various
ways.

4

00:00:18,520  -->  00:00:23,060
In this lecture I will give you an overview
of some of the most important parameters.

5

00:00:23,600  -->  00:00:28,640
Please note that this is not an exhaustive
list of parameters, so there are other ones

6

00:00:28,640  -->  00:00:29,960
available as well.

7

00:00:31,220  -->  00:00:34,640
Most of them are either rarely used or quite
advanced, though.

8

00:00:35,420  -->  00:00:39,360
I will come back to a couple more parameters
throughout the rest of this section when the

9

00:00:39,360  -->  00:00:40,260
time is right.

10

00:00:41,000  -->  00:00:42,880
With that said, let’s get started!

11

00:00:44,800  -->  00:00:47,620
The first parameter is the one named “format.”

12

00:00:47,880  -->  00:00:52,760
This parameter is used to specify a date format
when you want to index dates that are not

13

00:00:52,760  -->  00:00:54,660
formatted in the default format.

14

00:00:55,360  -->  00:00:58,860
I recommend that you use the default date
format whenever possible.

15

00:00:59,420  -->  00:01:05,480
In particular the ISO 8601 format is an extremely
common format that should be supported by

16

00:01:05,680  -->  00:01:07,600
almost all systems.

17

00:01:08,480  -->  00:01:13,140
It might not always be possible to format
dates in one of the default formats, though;

18

00:01:13,660  -->  00:01:18,320
perhaps you are integrating with a legacy
system that’s just not feasible to change.

19

00:01:19,080  -->  00:01:24,440
Oftentimes you will have an event processing
pipeline such as Logstash that can reformat

20

00:01:24,580  -->  00:01:27,680
data, but that might not always be the case.

21

00:01:28,400  -->  00:01:33,700
That’s just to say that sometimes it might
be necessary to use non-standard date formats.

22

00:01:35,160  -->  00:01:39,640
We can completely customize the date format
by specifying a format that is compatible

23

00:01:39,640  -->  00:01:41,700
with Java’s DateFormatter class.

24

00:01:42,520  -->  00:01:46,040
Alternatively there are a number of built-in
formats available.

25

00:01:46,900  -->  00:01:51,540
Two of them are actually used within the default
format that Elasticsearch uses.

26

00:01:52,820  -->  00:01:57,640
There is a rather long list of other built-in
formats that we can conveniently use instead

27

00:01:57,740  -->  00:01:59,600
of building our own pattern.

28

00:02:00,320  -->  00:02:05,280
An example could be if we wanted to specify
a UNIX timestamp instead of the number of

29

00:02:05,280  -->  00:02:11,280
milliseconds since the epoch, in which case
we could use the “epoch_seconds” format.

30

00:02:12,340  -->  00:02:17,600
I have attached a link to the documentation in case
you want to check which formats are available.

31

00:02:18,800  -->  00:02:21,560
Alright, so that’s the “format” parameter.

32

00:02:22,980  -->  00:02:27,880
The next parameter is actually one that you
have seen before; namely the “properties”

33

00:02:27,960  -->  00:02:28,860
parameter.

34

00:02:29,620  -->  00:02:34,220
We use it both at the top level when defining
mappings, and for nested fields.

35

00:02:34,560  -->  00:02:39,100
To be clear, nested fields can be for both
fields of the “object” and “nested”

36

00:02:39,300  -->  00:02:42,720
data types, which you can see examples of
on your screen.

37

00:02:44,220  -->  00:02:49,000
Remember that even though I just mentioned
an “object” data type, there is no such

38

00:02:49,000  -->  00:02:55,310
data type in Elasticsearch; instead, “object”
fields are mapped implicitly by using the

39

00:02:55,310  -->  00:02:58,120
“properties” parameter instead of specifying
a type.

40

00:02:59,140  -->  00:03:03,600
I won’t spend any more time on this parameter,
because you have already seen it in action,

41

00:03:03,920  -->  00:03:06,060
and there is really nothing more to it.

42

00:03:07,600  -->  00:03:11,940
Next up is the “coerce” parameter, which
should also be familiar to you.

43

00:03:12,420  -->  00:03:17,000
Although you haven’t seen the parameter
before, we have covered the concept of coercion.

44

00:03:18,340  -->  00:03:21,640
The parameter lets you enable or disable type
coercion.

45

00:03:22,360  -->  00:03:26,160
It’s enabled by default, but that might
not always be desirable.

46

00:03:27,340  -->  00:03:32,320
Whether or not you want it to be enabled is
really a matter of preference and how strict

47

00:03:32,320  -->  00:03:35,320
you want Elasticsearch to be when indexing
documents.

48

00:03:36,160  -->  00:03:40,200
You can see an example of how to disable coercion
on your screen now.

49

00:03:41,180  -->  00:03:45,380
If we were to supply a string value for the
“amount” field, Elasticsearch would reject

50

00:03:45,520  -->  00:03:46,800
the document.

51

00:03:48,120  -->  00:03:52,620
It’s also possible to configure coercion
at the index level so you don’t have to

52

00:03:52,620  -->  00:03:55,580
specify the “coercion” parameter for every
field.

53

00:03:56,560  -->  00:04:01,600
Since coercion is enabled by default, it only
really makes sense to disable it at the index

54

00:04:01,700  -->  00:04:02,460
level.

55

00:04:04,080  -->  00:04:09,240
Fields inherit this index level setting, but
you can still overwrite it if you want to.

56

00:04:10,220  -->  00:04:15,320
In the example to the right, coercion is disabled
at the index level, but the “amount” field

57

00:04:15,520  -->  00:04:18,860
overwrites this and enables coercion for that
field.

58

00:04:20,120  -->  00:04:24,620
Typically you will have fields that don’t
specify the “coerce” parameter and thereby

59

00:04:24,720  -->  00:04:26,760
use the index level setting implicitly.

60

00:04:27,540  -->  00:04:31,800
I just didn’t include such fields to keep
the example short, but I’m sure you get

61

00:04:31,900  -->  00:04:32,760
the point.

62

00:04:34,520  -->  00:04:38,080
Next is a parameter named “doc_values.”

63

00:04:38,760  -->  00:04:42,400
This one requires us to dive a bit deeper
into Apache Lucene.

64

00:04:43,420  -->  00:04:48,180
I told you what an inverted index is and how
that is used to efficiently resolve which

65

00:04:48,180  -->  00:04:50,100
documents contain a given term.

66

00:04:50,900  -->  00:04:54,940
I also told you that this is not the only
data structure used for fields.

67

00:04:56,060  -->  00:05:01,080
That’s because there is no single data structure
that efficiently serves all purposes.

68

00:05:01,920  -->  00:05:07,200
For instance, while an inverted index is excellent
for searching for terms, it doesn’t perform

69

00:05:07,360  -->  00:05:09,240
well for most other use cases.

70

00:05:10,540  -->  00:05:15,680
There is more to queries than simply searching
for data; perhaps we want to sort the results

71

00:05:15,920  -->  00:05:18,940
alphabetically, or to aggregate values.

72

00:05:19,560  -->  00:05:24,060
These are two examples of when an inverted
index does not perform well, because the access

73

00:05:24,280  -->  00:05:25,600
pattern is different.

74

00:05:26,980  -->  00:05:31,819
Instead of looking up terms and finding the
documents that contain them, we need to look

75

00:05:31,820  -->  00:05:34,680
up the document and find its terms for a field.

76

00:05:35,940  -->  00:05:41,980
This is what the “doc values” data structure
is; pretty much the opposite of an inverted index.

77

00:05:42,940  -->  00:05:49,100
Besides being used for sorting and aggregations,
this data structure is also used when accessing

78

00:05:49,100  -->  00:05:51,180
field values from within scripts.

79

00:05:51,960  -->  00:05:57,300
To be clear, the “doc values” data structure
is not a replacement for an inverted index,

80

00:05:57,640  -->  00:06:02,420
but rather an addition to it, meaning that
both data structures will be maintained for

81

00:06:02,640  -->  00:06:04,460
a field at the same time.

82

00:06:05,580  -->  00:06:10,020
Elasticsearch will then query the appropriate
data structure depending on the query.

83

00:06:11,640  -->  00:06:14,800
Why am I telling you about this data structure
now?

84

00:06:15,580  -->  00:06:19,600
Because you have the option of disabling it
with the “doc_values” mapping parameter.

85

00:06:20,240  -->  00:06:22,720
But why and when would you do this?

86

00:06:23,780  -->  00:06:28,580
The main reason for doing this would be to
save disk space, because this data structure

87

00:06:28,760  -->  00:06:31,660
would then not be built and stored on disk.

88

00:06:32,500  -->  00:06:39,100
Storing data in multiple data structures effectively
duplicates data with the purpose of fast retrieval,

89

00:06:39,560  -->  00:06:42,460
so disk space is traded for speed.

90

00:06:43,660  -->  00:06:48,760
A side benefit of that would be increased
indexing speed, because there is naturally

91

00:06:48,860  -->  00:06:52,980
a small overhead of building this data structure
when indexing documents.

92

00:06:53,820  -->  00:06:56,720
So when would you want to disable doc values?

93

00:06:57,600  -->  00:07:02,249
If you know that you won’t need to use a
field for sorting, aggregations, and scripting,

94

00:07:02,249  -->  00:07:07,300
you can disable doc values and save the disk
space required to store this data structure.

95

00:07:08,220  -->  00:07:13,420
For small indices, it might not matter much,
but if you are storing hundreds of millions

96

00:07:13,420  -->  00:07:16,660
of documents, there will be a significant
difference.

97

00:07:17,980  -->  00:07:22,860
It’s important to note that if you disable
doc values, you cannot change this without

98

00:07:22,960  -->  00:07:25,060
reindexing all of your data.

99

00:07:25,740  -->  00:07:29,220
This actually applies to many mapping parameters
as you will see soon.

100

00:07:30,620  -->  00:07:35,339
This means that you really have to consider
which kinds of queries you run against your

101

00:07:35,340  -->  00:07:39,680
data and try to anticipate how you will query
your data in the future.

102

00:07:40,380  -->  00:07:45,240
This is also why you should consider this
an advanced parameter, and you should probably

103

00:07:45,240  -->  00:07:47,940
not use it unless you have a reason for doing
so.

104

00:07:49,180  -->  00:07:53,720
Typically that would be if you are storing
a large number of documents, or if you anticipate

105

00:07:53,920  -->  00:07:54,920
that you will.

106

00:07:56,000  -->  00:08:00,780
Before continuing, here is how doc values
can be disabled within a field’s mapping.

107

00:08:03,920  -->  00:08:06,880
Next up, we have a parameter named “norms.”

108

00:08:07,440  -->  00:08:12,260
We haven’t covered what norms are yet, so
I will just give you a quick introduction here.

109

00:08:13,200  -->  00:08:20,160
Norms refers to the storage of various normalization
factors that are used to compute relevance scores.

110

00:08:21,460  -->  00:08:26,280
We haven’t gotten into search queries yet,
but oftentimes we will want to not just apply

111

00:08:26,280  -->  00:08:31,920
a filter to documents, but also rank them
based on how well they match a given query.

112

00:08:32,900  -->  00:08:35,600
Think of search results on Google, for instance.

113

00:08:36,620  -->  00:08:41,880
The results on page five are naturally not
as relevant as the ones on the first page.

114

00:08:42,520  -->  00:08:47,160
That’s because they are sorted based on
relevance, and the same is done for some queries

115

00:08:47,160  -->  00:08:48,540
in Elasticsearch.

116

00:08:49,680  -->  00:08:55,640
Part of what enables Elasticsearch to calculate
relevance scores for documents, is these norms.

117

00:08:56,300  -->  00:09:00,420
As with many other things, they are stored
within Apache Lucene, but that’s besides

118

00:09:00,420  -->  00:09:01,380
the point.

119

00:09:02,560  -->  00:09:07,740
What the “norms” mapping parameter enables
us to do, is to disable these norms.

120

00:09:08,620  -->  00:09:09,240
Why?

121

00:09:09,520  -->  00:09:13,740
Because they take up quite a lot of disk space,
just like doc values do.

122

00:09:14,760  -->  00:09:21,420
Not storing norms saves disk space, but also
removes the ability to use a field for relevance scoring.

123

00:09:22,480  -->  00:09:27,340
That’s why you should only disable norms
for fields that you won’t use for relevance scoring.

124

00:09:28,120  -->  00:09:33,140
For example, you might have a “tags” field
for products as you saw earlier in the course.

125

00:09:33,920  -->  00:09:38,440
Such a field would almost always be used for
either filtering or aggregations.

126

00:09:39,200  -->  00:09:44,520
We can use the field for these use cases just
fine, because they don’t involve relevance scoring.

127

00:09:45,780  -->  00:09:50,480
In such a scenario, it makes perfect sense
to not store the norms at all, because they

128

00:09:50,640  -->  00:09:52,880
are just a waste of disk space.

129

00:09:53,920  -->  00:09:58,580
A “name” field for a product, however,
would almost always be used for relevance

130

00:09:58,580  -->  00:10:03,140
scoring because we would probably be performing
full-text searches on the field.

131

00:10:04,600  -->  00:10:10,080
So if you know that you will only use a field
for filtering and aggregations, then you can

132

00:10:10,080  -->  00:10:12,360
save disk space by disabling norms.

133

00:10:12,820  -->  00:10:14,480
I hope that makes sense.

134

00:10:15,720  -->  00:10:20,640
It’s also possible to ignore a field in
terms of indexing, by setting the “index”

135

00:10:20,720  -->  00:10:21,740
parameter to “false.”

136

00:10:22,280  -->  00:10:27,320
By doing so, the field values are not indexed
at all, and the field therefore cannot be

137

00:10:27,320  -->  00:10:28,840
used within search queries.

138

00:10:29,620  -->  00:10:34,440
It’s important to note that the field value
will still be stored within the “_source”

139

00:10:34,440  -->  00:10:38,760
object; it just won’t be part of the data
structures used for searching.

140

00:10:39,920  -->  00:10:44,860
This parameter is useful if you have a field
that you don’t need to search, but you still

141

00:10:44,860  -->  00:10:48,320
want to store the field as part of the “_source”
object.

142

00:10:49,120  -->  00:10:54,560
Not indexing a field naturally saves disk
space and slightly increases the rate at which

143

00:10:54,720  -->  00:10:56,480
documents can be indexed.

144

00:10:58,100  -->  00:11:03,300
This parameter is often used for time series
data where you have numeric fields that you

145

00:11:03,520  -->  00:11:06,840
won’t use for filtering, but rather for
aggregations.

146

00:11:08,220  -->  00:11:13,300
Even if you disable indexing for a field,
you can still use it for aggregations.

147

00:11:13,800  -->  00:11:17,940
That’s because those work a bit differently,
but I don’t want to get into that right now.

148

00:11:19,440  -->  00:11:22,000
Just two more parameters, so hang in there!

149

00:11:23,420  -->  00:11:28,300
In a previous lecture, we talked about how
missing field values are handled, i.e. if

150

00:11:28,300  -->  00:11:31,240
a field is left out when indexing a document.

151

00:11:31,860  -->  00:11:35,180
But what if we include the field and supply
NULL as the value?

152

00:11:36,500  -->  00:11:41,860
NULL values are ignored in Elasticsearch,
meaning that they cannot be indexed or searched.

153

00:11:42,780  -->  00:11:46,640
The same applies to an empty array, or an
array of NULL values.

154

00:11:47,840  -->  00:11:52,800
If you want to be able to search for NULL
values, then you can use the “null_value”

155

00:11:52,980  -->  00:11:56,880
parameter to replace NULL values with a value
of your choice.

156

00:11:57,840  -->  00:12:02,820
Whenever Elasticsearch encounters a NULL value
for the field, it will index the value specified

157

00:12:03,060  -->  00:12:07,200
by the parameter instead, thereby making this
value searchable.

158

00:12:08,240  -->  00:12:10,980
There are a couple of things to note about
this parameter.

159

00:12:11,760  -->  00:12:16,640
First, it only works for explicit NULL values,
meaning that providing an empty array does

160

00:12:16,880  -->  00:12:20,000
not cause Elasticsearch to perform the replacement.

161

00:12:20,920  -->  00:12:25,820
Secondly, the value that you define must be
of the same data type as the field’s data

162

00:12:26,000  -->  00:12:26,760
type.

163

00:12:27,820  -->  00:12:32,280
If the field is an integer, then you must
supply an integer value to the parameter.

164

00:12:33,780  -->  00:12:38,880
Lastly, the parameter influences how data
is indexed, meaning the data structures that

165

00:12:38,880  -->  00:12:40,420
are used for searches.

166

00:12:41,200  -->  00:12:45,560
The “_source” object is therefore not
affected, and will contain the value that

167

00:12:45,580  -->  00:12:48,360
was supplied when indexing the document, i.e.

168

00:12:48,460  -->  00:12:48,960
NULL.

169

00:12:50,700  -->  00:12:53,100
Time for the last parameter - I promise!

170

00:12:54,220  -->  00:12:58,880
Suppose that we have the name of a person
stored as two fields; “first_name” and

171

00:12:59,000  -->  00:13:00,120
“last_name.”

172

00:13:00,800  -->  00:13:05,860
While we can query one or both of these fields
just fine, we might also want to index the

173

00:13:05,960  -->  00:13:09,480
full name into a third field, perhaps named
“full_name.”

174

00:13:10,840  -->  00:13:13,880
That’s possible with the “copy_to” parameter.

175

00:13:14,780  -->  00:13:18,640
The value for the parameter should be the
name of the field to which the field value

176

00:13:18,860  -->  00:13:19,960
should be copied.

177

00:13:21,300  -->  00:13:26,020
So by adding the parameter to both the “first_name”
and “last_name” fields, Elasticsearch

178

00:13:26,220  -->  00:13:28,820
will copy both values into the “full_name”
field.

179

00:13:30,460  -->  00:13:33,380
Notice how I said that values will be copied.

180

00:13:34,020  -->  00:13:39,000
That’s because it’s not the tokens or
terms yielded by the analyzer that are copied;

181

00:13:39,480  -->  00:13:42,080
instead, it’s the values that were supplied.

182

00:13:43,260  -->  00:13:47,100
These values are then analyzed with the analyzer
of the target field.

183

00:13:48,520  -->  00:13:54,240
One important thing to note is that the copied
values will not be part of the “_source” object.

184

00:13:54,960  -->  00:14:00,440
In this example it means that the “full_name”
field is not part of the “_source” object,

185

00:14:00,800  -->  00:14:02,600
since the values are only indexed.

186

00:14:03,920  -->  00:14:08,340
The exception to that is if you specify a
value for the “full_name” field when you

187

00:14:08,440  -->  00:14:12,600
index the document, but that’s not a very
common thing to do at all.

188

00:14:14,040  -->  00:14:16,420
Alright, that’s the end of this overview.

189

00:14:16,760  -->  00:14:21,780
As I mentioned at the beginning of the lecture,
we didn’t cover all mapping parameters here.

190

00:14:22,480  -->  00:14:26,520
We will get back to a couple more important
ones throughout the remainder of this section.

191

00:14:27,320  -->  00:14:31,820
The chances that you will use the rest are
pretty slim, so I will leave you to explore

192

00:14:31,920  -->  00:14:34,600
those within the documentation if you want
to.
