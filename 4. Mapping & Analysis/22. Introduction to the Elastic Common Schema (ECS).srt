Transcript
I mentioned something called the Elastic Common Schema (abbreviated ECS) in the previous lecture.

So, what is it?

ECS is a specification that defines a set of common fields, including their names and

how they should be mapped in Elasticsearch.

ECS came to life as the number of products within the Elastic Stack grew.

Values were ingested into Elasticsearch using different field names depending on the source,

and so there was no cohesion between the mappings.

This was both confusing and inconvenient.

For instance, a Kibana dashboard needed to know which particular web server was being

used because the field names were different - at least when using Filebeat modules.

There was really no standard, and so the fields were often named something along the lines

of “apache2.access.url” or “nginx.access.url.”

This was inconvenient because the data consumer — such as Kibana — needed to know the

event source implementation.

However, once access logs are parsed, it makes no difference if the web server that generated

them is named Apache or nginx.

Changing the web server would cause all kinds of trouble all the way through the ingestion

pipeline because the field names would then be different.

Therefore we want to keep the field names the same so that Kibana doesn’t need to

know if events come from an Apache or nginx web server.

Realistically, you don’t change a web server that often, but it is a dependency nonetheless.

It’s pretty common to ingest data from a number of sources at the same time, though.

For instance, we might want to collect data from a number of different services such as

a Postgres database, Kafka, nginx, and perhaps a Redis cluster.

We would probably process an event once per minute, and we would need to store this timestamp

within a field.

Instead of having each service potentially name this field differently, the ECS specification

states that it should be named @timestamp.

This means that no matter which kind of event you are dealing with, this should be the name

of when the event originated.

This makes it easier when consuming data — perhaps through Kibana — because the name of the

timestamp field is the same regardless of the event source.

Note that the @timestamp field is used for events; you might still have a field named

“created_at” for products, for instance.

ECS was created to overcome the challenges of having different field names for the same things.

Naturally, ECS is not just related to web server logs.

In fact, ECS is not intended to support a fixed set of use cases.

It defines a lot of common fields in various groups, such as network fields, geolocation

fields, operating system fields, etc.

These groups are referred to as field sets.

If we take a look at the documentation, you can see all of the field sets at the right-hand

side of the page if we expand the “ECS Field Reference” menu item.

All of these field sets total hundreds of fields covering many different kinds of fields.

In ECS terminology, documents are referred to as events.

That’s because ECS includes fields for most event types that are generated by a lot of

different technologies.

If you want to store data such as employees, companies, products, orders, etc., then ECS

does not provide fields for this.

That’s because those are specific to your use case, so there is no standard for them.

ECS is mostly useful if you are storing standard events such as web server logs, operating

system metrics, geospatial data, etc.

In that case you should try to structure your data using ECS, because then you can utilize

Kibana dashboards without having to reconfigure field names, for instance.

That being said, you will often be using Filebeat or Metricbeat for this, which structure data

according to ECS automatically.

For instance, if you ingest web server logs with Filebeat, you won’t have to deal with

ECS at all, because it has already been handled for you.

ECS is therefore mostly useful when building custom implementations that don’t involve

other Elastic Stack products.

This means that you typically won’t actively deal with ECS, but it’s good to be aware

of it and that it is being used across the Elastic Stack.

For custom implementations, it’s not a big deal if you don’t make use of ECS fields

to be honest; consider it a best practice and recommendation.

For most use cases, you won’t have to actively deal with ECS, so the purpose of this lecture

is mainly just to tell you what ECS is about.

I have attached the link to the documentation if you want to explore ECS and the fields that it provides.

