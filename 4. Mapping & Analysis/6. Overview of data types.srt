1

00:00:03,120  -->  00:00:08,860
Before we really get into mapping, I want to quickly give you an overview of the available data types.

2

00:00:09,440  -->  00:00:13,580
There are quite a few of them, so I will just
highlight the most important ones.

3

00:00:15,020  -->  00:00:19,160
On your screen, you can see some of the basic
Elasticsearch data types.

4

00:00:19,740  -->  00:00:25,660
You probably recognize some of them from various
programming languages, | but either way, their

5

00:00:25,660  -->  00:00:27,760
uses should be pretty obvious.

6

00:00:29,440  -->  00:00:35,160
Apart from these, there are a number of more
specialized data types, such as an “ip”

7

00:00:35,160  -->  00:00:37,740
data type for storing IP addresses.

8

00:00:38,380  -->  00:00:44,220
Some of the specialized data types are related
to specific Elasticsearch features, such as

9

00:00:44,220  -->  00:00:47,320
for auto-completion or geospatial searches.

10

00:00:48,380  -->  00:00:53,020
Instead of talking about all of them now,
I will introduce them throughout the course

11

00:00:53,020  -->  00:00:54,500
as they become relevant.

12

00:00:55,100  -->  00:01:01,100
That being said, I do encourage you to check
out the list of data types within the documentation,

13

00:01:01,100  -->  00:01:03,440
just so you know which ones are available.

14

00:01:04,540  -->  00:01:09,000
There are some pretty cool ones for specific
use cases that I won’t have time to cover

15

00:01:09,000  -->  00:01:10,080
in this course.

16

00:01:10,600  -->  00:01:12,460
I’ve attached the link to this lecture.

17

00:01:13,320  -->  00:01:18,360
Instead of spending time on covering these
basic data types extensively, let’s move

18

00:01:18,360  -->  00:01:21,400
on to some data types that are a bit more
complex.

19

00:01:23,160  -->  00:01:25,820
First, we have the “object” data type.

20

00:01:26,360  -->  00:01:30,420
This data type essentially just covers any
JSON object.

21

00:01:30,860  -->  00:01:35,020
Each document that we index into Elasticsearch
is a JSON object.

22

00:01:35,820  -->  00:01:40,180
This document may then contain a field with
an object as its value.

23

00:01:41,260  -->  00:01:46,760
This object may then contain an inner object
itself, forming an object hierarchy.

24

00:01:47,300  -->  00:01:50,160
In other words, you can nest objects.

25

00:01:51,300  -->  00:01:57,360
The way this is mapped, is that a “properties”
key is added for objects instead of specifying

26

00:01:57,360  -->  00:01:59,900
the “type” key as with other data types.

27

00:02:00,820  -->  00:02:04,880
The type is therefore not just set to “object”
as you might have expected.

28

00:02:05,940  -->  00:02:10,260
“properties” is actually a mapping parameter,
but we will get to that soon.

29

00:02:11,100  -->  00:02:15,400
We then define the keys that the object contains
within this “properties” key.

30

00:02:16,300  -->  00:02:20,500
The same is the case if this inner object
contains an inner object itself.

31

00:02:21,360  -->  00:02:25,020
Notice how we also did this for the fields
at the root level of the mapping.

32

00:02:25,920  -->  00:02:31,740
Don’t worry if you find this syntax confusing
at first; it does take a bit of time to get used to.

33

00:02:32,880  -->  00:02:38,680
Even though we just define objects as regular
JSON objects when we index documents, that’s

34

00:02:38,680  -->  00:02:41,560
actually not how the objects are stored internally.

35

00:02:42,520  -->  00:02:48,960
As you know, Elasticsearch is built on top
of Apache Lucene, which does not support objects.

36

00:02:49,640  -->  00:02:54,600
That’s why Elasticsearch transforms inner
objects to a format that is compatible with

37

00:02:54,600  -->  00:02:57,780
Lucene, as part of indexing operations.

38

00:02:58,760  -->  00:03:03,920
The reason for that is to ensure that we can
index any document that is valid according

39

00:03:03,920  -->  00:03:05,820
to the JSON specification.

40

00:03:06,500  -->  00:03:11,240
This makes Elasticsearch easier to use, because
we don’t need to structure documents in

41

00:03:11,280  -->  00:03:15,680
any special way to ensure that they can be
indexed into Apache Lucene.

42

00:03:16,940  -->  00:03:20,700
The way the objects are stored internally,
is that they are flattened.

43

00:03:21,260  -->  00:03:27,460
Each level in the hierarchy is denoted with
a dot, such that there are no longer any objects,

44

00:03:27,480  -->  00:03:29,480
but the hierarchy is maintained.

45

00:03:30,680  -->  00:03:36,360
This way, object fields can now be stored
within Apache Lucene, and we can still query

46

00:03:36,360  -->  00:03:41,100
fields as if they were objects by using a
dot notation syntax.

47

00:03:42,300  -->  00:03:47,700
That’s great, but what happens if we try
to index an array of objects?

48

00:03:48,020  -->  00:03:49,840
How are the objects flattened then?

49

00:03:50,600  -->  00:03:53,480
Wouldn’t the result be duplicate field names?

50

00:03:54,160  -->  00:03:57,060
The answer to the last question is yes.

51

00:03:57,800  -->  00:04:03,100
What happens is that the values are grouped
by field name and indexed as an array.

52

00:04:04,060  -->  00:04:08,620
If you run a search query against one of the
fields, it will search through all of the

53

00:04:08,620  -->  00:04:10,120
values within the array.

54

00:04:10,800  -->  00:04:15,860
That’s pretty nice in some situations, but
it can cause trouble in others.

55

00:04:15,860  -->  00:04:17,460
Let’s look at an example.

56

00:04:18,580  -->  00:04:23,220
Suppose that we want to search for products
that have a review left by a person named

57

00:04:23,220  -->  00:04:26,080
John Doe, with a rating of at least 4.

58

00:04:27,120  -->  00:04:32,280
The query is pretty simple, but since we haven’t
gotten to search queries yet, the one you

59

00:04:32,280  -->  00:04:34,320
will see is just a pseudo query.

60

00:04:35,360  -->  00:04:39,960
What will happen, is that the product will
match, even though the review left by John

61

00:04:39,960  -->  00:04:43,020
Doe actually has a rating of 3.5.

62

00:04:44,180  -->  00:04:49,620
The reason is that the field values were all
mixed together when the document was indexed,

63

00:04:49,620  -->  00:04:53,040
so the relationship between the object keys
was lost.

64

00:04:54,040  -->  00:04:59,100
When this happens, Elasticsearch doesn’t
know that there is a relationship between

65

00:04:59,100  -->  00:05:01,160
“John Doe” and 3.5.

66

00:05:02,300  -->  00:05:08,600
What we intended to do, was to match products
containing a review written by John Doe and

67

00:05:08,600  -->  00:05:10,500
with a rating of at least 4.

68

00:05:11,000  -->  00:05:15,980
What actually happened was that we matched
products containing a review written by John

69

00:05:15,980  -->  00:05:18,820
Doe or with a rating of at least 4.

70

00:05:19,720  -->  00:05:25,420
This essentially means that the boolean AND
was effectively turned into a boolean OR due

71

00:05:25,420  -->  00:05:27,500
to how the values are stored internally.

72

00:05:28,320  -->  00:05:33,780
That’s probably not what we want, and it’s
definitely not the behavior that you would

73

00:05:34,980  -->  00:05:40,480
To solve this, there is a data type called
“nested,” which is a specialized version

74

00:05:40,480  -->  00:05:42,180
of the “object” data type.

75

00:05:42,980  -->  00:05:48,920
The purpose of it is to maintain the relationship
between object values when an array of objects

76

00:05:48,920  -->  00:05:49,880
is indexed.

77

00:05:50,880  -->  00:05:57,180
Using this data type enables us to query objects
independently, meaning that the object values

78

00:05:57,180  -->  00:05:59,920
are not mixed together as you saw a moment
ago.

79

00:06:01,100  -->  00:06:06,400
To utilize this data type, we must use a specific
query, which you will see later in the course.

80

00:06:07,520  -->  00:06:11,320
On your screen you can see an example of using
this data type.

81

00:06:12,040  -->  00:06:16,960
The data type is simply set to “nested”
in the same way as for other data types.

82

00:06:18,440  -->  00:06:23,580
Using the pseudo query from before, it would
only match products containing a review written

83

00:06:23,580  -->  00:06:27,480
by John Doe and with a rating greater than
or equal to 4.

84

00:06:28,300  -->  00:06:34,060
That’s because the objects are stored independently
and the query then behaves how we probably

85

00:06:34,060  -->  00:06:36,360
have expected it to in the first place.

86

00:06:37,420  -->  00:06:41,640
Unlike before, the product is therefore not
matched by the query.

87

00:06:42,780  -->  00:06:49,240
I mentioned that Apache Lucene has no concept
of objects, so how are these objects stored?

88

00:06:50,220  -->  00:06:53,160
They are actually stored as hidden documents.

89

00:06:53,460  -->  00:06:58,180
And yes, by documents, I mean documents just
like the ones we indexed.

90

00:06:59,140  -->  00:07:04,580
The difference is that these documents won’t
show up in search results unless we query

91

00:07:04,580  -->  00:07:05,680
them directly.

92

00:07:06,740  -->  00:07:12,680
Suppose that we index a product containing
ten reviews, each being a nested object.

93

00:07:13,240  -->  00:07:18,900
This would cause 11 documents to be indexed
into Lucene; one for the product, and one

94

00:07:18,900  -->  00:07:20,000
for each review.

95

00:07:21,380  -->  00:07:25,160
The last data type I want to talk about is
the one named “keyword.”

96

00:07:26,040  -->  00:07:31,120
This data type should be used for fields on
which you want to search for exact values.

97

00:07:31,980  -->  00:07:37,700
Since only exact searching is supported, this
data type is used for filtering, sorting,

98

00:07:37,700  -->  00:07:39,280
and aggregating documents.

99

00:07:40,020  -->  00:07:45,180
An example would be to have a “status”
field for news articles and search for all

100

00:07:45,180  -->  00:07:48,420
articles that have a value of “published”
for the field.

101

00:07:49,640  -->  00:07:54,840
If you want to perform so-called full-text
searches, you need to use the “text” data

102

00:07:54,840  -->  00:07:55,780
type instead.

103

00:07:57,200  -->  00:08:02,280
Full-text searches are basically searches
that do not require exact matches.

104

00:08:02,860  -->  00:08:08,080
For instance, we could search for news articles
containing one or more specific words within

105

00:08:08,080  -->  00:08:09,240
their contents.

106

00:08:10,140  -->  00:08:14,280
We will dive deeper into the difference between
the “text” and “keyword” data types

107

00:08:14,280  -->  00:08:15,580
in the next lecture.

108

00:08:16,060  -->  00:08:21,680
The takeaway for now is that the “keyword”
data type is used for sorting, filtering,

109

00:08:21,680  -->  00:08:22,820
and aggregations.

110

00:08:24,180  -->  00:08:28,460
That’s a quick overview of the most important
data types in Elasticsearch.

111

00:08:28,880  -->  00:08:34,060
Like I said, I encourage you to check out
the documentation to see which ones are available.
