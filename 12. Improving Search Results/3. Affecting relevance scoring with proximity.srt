1
00:00:02,540 --> 00:00:09,950
前回の講義で出てきた検索結果を見ながら､ 近接検索の文脈で関連スコアリングについて少しお話ししましょう｡

2
00:00:10,430 --> 00:00:17,600
spicyとsauceが正しい順序で隣り合っている文書が最も高いスコアを獲得していることに注目してください｡

3
00:00:18,020 --> 00:00:22,700
それは､ 用語が表示される近接度が関連スコアに影響するからです｡ 

4
00:00:22,910 --> 00:00:26,240
近ければ近いほど､ 関連スコアが高くなる｡ 

5
00:00:26,810 --> 00:00:31,370
別の言い方をすれば､ 編集距離が短いほど関連スコアが高くなる｡ 

6
00:00:31,670 --> 00:00:35,410
ご存知のように､ 関連スコアの算出方法はそれほど単純ではありません｡ 

7
00:00:35,420 --> 00:00:41,000
そのため､ 用語の近接度が最も低い文書が最も高得点になる保証はない｡

8
00:00:41,420 --> 00:00:49,400
それは､ 関連スコアを計算する際に､ 他の多くの関連性要因が考慮され､ 用語の近接性はその一つに過ぎないからです｡

9
00:00:49,730 --> 00:00:55,370
だから､ 影響はあるけれども､ 決してそれだけが得点の計算の材料ではない｡

10
00:00:55,370 --> 00:00:59,450
ですから､ スコアが必ずしも期間的な近さを反映しているとは思わないでください｡ 

11
00:01:00,160 --> 00:01:00,970
とにかく

12
00:01:00,970 --> 00:01:06,220
近接度が関連スコアに影響することはお分かりいただけたと思いますが､ 便利なトリックを紹介したいと思います｡ 

13
00:01:06,340 --> 00:01:11,380
技術的に見たことがないものはありませんが､ それにもかかわらず､ 非常に便利です｡ 

14
00:01:11,740 --> 00:01:15,850
そのため､ デフォルトでは､ マッチフレーズクエリでは､ すべての用語が存在することが要求されます｡ 

15
00:01:15,850 --> 00:01:21,790
そして､ 前回の講義で指定された順番で､ 条件の配置をより柔軟に､ より厳密でなくする方法を､

16
00:01:21,790 --> 00:01:25,740
スロットパラメータで確認しましたね｡

17
00:01:25,750 --> 00:01:34,180
しかし､ 関連スコアリングアルゴリズムは､ とにかくほとんどの用語が出現する文書を優先するので､ すべての用語が存在することを要求したくないのかもしれない｡

18
00:01:34,630 --> 00:01:38,200
これは､ コースの前半で見たように､ マッチクエリを使うことで実現できます｡ 

19
00:01:38,230 --> 00:01:39,760
何も目新しいことはありません｡ 

20
00:01:39,760 --> 00:01:46,750
しかし､ 同時に､ マッチフレーズクエリのような用語の近接性に基づいて文書をブーストしたい場合もある｡

21
00:01:47,230 --> 00:01:49,870
では､ どうすればいいのでしょうか？

22
00:01:49,870 --> 00:01:52,750
プルクエリ内で2つのクエリを結合することにより｡ 

23
00:01:52,900 --> 00:01:56,290
まず､ マッチクエリのみを含むプルクエリから始めてみましょう｡ 

24
00:01:56,710 --> 00:02:06,070
そこで､ これをコピーして､ 入力の手間を省くために調整し､ ここにプルクエリを入力し､ マスト配列を入力することにします｡

25
00:02:06,400 --> 00:02:13,900
そしてこの配列の中に､ まずマッチクエリー句を追加して､ タイトルフィールドを検索することにします｡

26
00:02:14,140 --> 00:02:21,610
オブジェクトに変更し､ クエリをスパイシーソースに指定します｡ 

27
00:02:22,000 --> 00:02:22,870
シンプルでいいじゃないですか｡ 

28
00:02:22,870 --> 00:02:24,130
とにかく走らせよう｡ 

29
00:02:24,700 --> 00:02:29,740
そこで､ マッチクエリに使われるデフォルトのブーリアン演算子はor soであることを思い出してください｡ 

30
00:02:29,740 --> 00:02:34,420
文書内に両方の用語が存在しなくても､ 一致とみなされます｡ 

31
00:02:34,840 --> 00:02:37,270
提示する用語が多いほど､ 関連スコアが高くなります｡ 

32
00:02:37,320 --> 00:02:45,640
また､ 最小アンダースコア一致パラメータで､ 存在すべき最小限の語数を指定できることも覚えておいてください｡

33
00:02:46,180 --> 00:02:47,650
結果を一目見ること｡ 

34
00:02:47,680 --> 00:02:52,480
上位にヒットする用語の中で､ spicyとsourceの間に距離があることに注目してください｡ 

35
00:02:52,720 --> 00:02:54,520
もっといいものができるはずだ｡ 

36
00:02:54,550 --> 00:03:02,290
マッチングにはマッチクエリが必要だが､ オプションでマッチフレーズクエリを検索オブジェクト内に配置することもできる｡

37
00:03:02,320 --> 00:03:03,340
そうしよう｡ 

38
00:03:03,760 --> 00:03:15,010
そこで､ マスタリングとは別に､ ここに擬似配列を追加し､ タイトルフィールドに再びマッチフレーズ型のクエリ句を追加してみます｡

39
00:03:15,760 --> 00:03:17,770
これもオブジェクトに変えてみる｡ 

40
00:03:17,800 --> 00:03:23,110
クエリを指定し､ この句にも同じクエリを指定します｡ 

41
00:03:23,740 --> 00:03:24,280
わかりました｡ 

42
00:03:24,280 --> 00:03:26,410
では､ この新しいクエリーは何を意味するのでしょうか｡ 

43
00:03:26,530 --> 00:03:28,780
マッチクエリはまだ一致する必要があります｡ 

44
00:03:28,780 --> 00:03:31,570
しかし､ マッチフレーズクエリの場合はそうではない｡ 

45
00:03:31,600 --> 00:03:37,000
このクエリは任意であるが､ マッチした場合､ マッチした文書の関連性スコアをブーストする｡ 

46
00:03:37,210 --> 00:03:39,820
クエリを実行すれば確認できるはずです｡ 

47
00:03:42,780 --> 00:03:49,020
このように､ 2つの用語が隣接している文書は､ 関連性が大きく向上していることがわかります｡

48
00:03:49,140 --> 00:03:52,710
この例では素晴らしいことですが､ 私たちはもっといいことができるはずです｡ 

49
00:03:53,220 --> 00:03:57,750
2つの用語が隣り合わせに表示される文書の関連性だけを高めているのです｡ 

50
00:03:57,750 --> 00:04:01,560
でも､ そのあたりはもう少し柔軟に対応したほうがいいかもしれませんね｡ 

51
00:04:02,040 --> 00:04:10,130
マッチフレーズキャリアは､ マッチの一致度合いに基づいてマッチをブーストするので､ スラブパラメータを指定することでその方法を既にご存知でしょう｡

52
00:04:10,140 --> 00:04:16,470
つまり､ 用語の近接度に基づいて文書をブーストしているので､ slabパラメータを指定しても､

53
00:04:16,470 --> 00:04:20,550
2つの用語が近接した文書が上位に表示されます｡

54
00:04:21,000 --> 00:04:27,660
用語の近接度を関連性のある要素として使い､ 2つの用語が接近している文書をブーストしているだけなのです｡

55
00:04:28,020 --> 00:04:30,030
5のスラブパラメータを追加してみよう｡ 

56
00:04:32,930 --> 00:04:33,710
そうそう｡ 

57
00:04:34,520 --> 00:04:35,930
もう一度､ クエリを実行してみましょう｡ 

58
00:04:36,880 --> 00:04:38,920
そして､ 何か違いがあるかどうかを見てください｡ 

59
00:04:39,490 --> 00:04:44,770
つまり､ 2つの用語が近接している文書に対して関連性を高めているのです｡ 

60
00:04:45,400 --> 00:04:50,020
マッチフレーズクエリを追加してもしなくても､ 同じ文書がマッチングされる｡ 

61
00:04:50,230 --> 00:04:57,130
追加することで､ 関連スコアに影響を与え､ 近接した範囲にある用語を含む文書を優遇しているだけです｡

62
00:04:58,000 --> 00:05:04,300
今回の講義では､ 特に新しいことは取り上げませんでしたが､ この旅が皆様のお役に立つかもしれませんので､ ご紹介させていただきます｡

63
00:05:04,900 --> 00:05:10,660
この講義を終える前に､ 関連するスコアを計算するためには､ さまざまな要素があることを思い出してほしい｡

64
00:05:10,660 --> 00:05:15,880
そのため､ この方法では､ 近接した文書が最も高いスコアを獲得することは保証されない｡ 

65
00:05:16,450 --> 00:05:26,050
これらの文書は関連性の高いブーストを得るが､ インデックスにある文書に本当に来る近接性によってマッチがソートされる保証はない｡

66
00:05:26,470 --> 00:05:33,820
ですから､ このアプローチは､ より大きな絵に収まり､ 他の関連性要素と一緒に機能する関連性要素であるとお考えください｡
