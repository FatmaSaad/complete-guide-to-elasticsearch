1
00:00:02,380 --> 00:00:08,410
同義語については､ コースの前半で少し触れましたが､ 具体的にはマッピングについてのセクションで説明しました｡ 

2
00:00:08,440 --> 00:00:11,530
しかし､ 私たちがしなかったのは､ それらを実際に活用することでした｡ 

3
00:00:11,530 --> 00:00:13,810
というわけで､ 今回の講義ではその辺をご紹介します｡ 

4
00:00:14,380 --> 00:00:20,530
説明フィールドのマッピングでsynonymsというインデックスを作成するクエリをあらかじめ追加しておきました｡

5
00:00:20,590 --> 00:00:29,590
このマッピングでは､ カスタムアナライザーを使用し､ カスタムトークンフィルターは､ 標準のトークンISOと小文字トークンフィルターとは別に使用される｡

6
00:00:30,040 --> 00:00:32,010
これって､ 全部見たことあるような話ですよね｡ 

7
00:00:32,020 --> 00:00:37,540
興味深いのは､ カスタムトークンフィルタで､ ここで同義語を定義することになるからです｡ 

8
00:00:37,900 --> 00:00:46,540
トークン・フィルタのタイプはsynonymで､ synonymsパラメータを追加して､ ここにsynonymsの配列を追加することにしました｡

9
00:00:46,540 --> 00:00:49,450
文字列の中で特別な構文を使う必要があります｡ 

10
00:00:49,450 --> 00:00:52,660
つまり､ ここでは文字列の配列を扱うことになります｡ 

11
00:00:53,170 --> 00:00:58,420
同義語を追加する方法は､ 他の用語に置き換えるべき用語を指定することである｡ 

12
00:00:58,450 --> 00:01:03,140
まず､ awfulという言葉はfulribleという言葉に置き換えるべきと定義することから始めましょう｡ 

13
00:01:03,160 --> 00:01:09,190
これらの用語は意味的には同じなので､ 文字列内の構文を同義語配列に入力するだけにして､

14
00:01:09,190 --> 00:01:12,280
その後に説明することにしよう｡

15
00:01:19,540 --> 00:01:19,990
なるほど｡ 

16
00:01:19,990 --> 00:01:26,410
つまり､ 左側に置き換えられる用語があり､ その後に等号と大なり記号である矢印が続いています｡

17
00:01:26,560 --> 00:01:30,190
そして､ 矢印の右側に置換が追加されます｡ 

18
00:01:30,550 --> 00:01:36,400
つまり､ この行は本質的に､ awfulという用語の出現箇所をawfulという用語に置き換えることを意味しているのです｡ 

19
00:01:36,820 --> 00:01:41,210
先に進む前に､ Elasticsearchで同義語がどのように機能するかについて触れておきます｡ 

20
00:01:41,230 --> 00:01:45,640
なぜ､ 「ある言葉が別の言葉に置き換わる」と言ったのか､ 不思議に思われたかもしれませんね｡ 

21
00:01:45,700 --> 00:01:50,830
では､ awfulをterribleに置き換えたら､ awfulを検索したらどうなるでしょうか｡ 

22
00:01:51,340 --> 00:01:56,740
2つの用語のいずれかを含む文書は､ 全く同じ分析プロセスを経るクエリを覚えているため､

23
00:01:56,740 --> 00:01:58,840
一致する｡

24
00:01:59,410 --> 00:02:06,430
そのため､ もしdescriptionフィールドに対してマッチクエリを実行すると､ そのクエリもカスタムアナライザで分析されることになります｡

25
00:02:07,090 --> 00:02:13,270
このため､ 実際には転置インデックス内で用語を置き換えていても､ 文書は一致する｡

26
00:02:13,360 --> 00:02:16,300
同義語がどのように格納されるかは､ また後ほど紹介します｡ 

27
00:02:16,840 --> 00:02:25,390
用語レベルのクエリは分析されないので､ 用語レベルのクエリと同義語を組み合わせないようにすることが重要です｡

28
00:02:25,750 --> 00:02:30,250
理論的には可能ですが､ おそらくそんなにうまくはいかないでしょう｡ 

29
00:02:30,790 --> 00:02:36,190
用語レベルのクエリでawfulという用語を検索しても､ awfulという用語はterribleという用語に置き換えられているため､

30
00:02:36,190 --> 00:02:41,980
転置インデックス内には格納されていないため､ 何もマッチしないのです｡

31
00:02:42,740 --> 00:02:44,250
さて､ ここまではいいのですが

32
00:02:44,260 --> 00:02:46,270
今､ 最初の同義語を定義しました｡ 

33
00:02:46,480 --> 00:02:50,260
もう一つ､ 今度は別の構文で追加してみましょう｡ 

34
00:02:50,590 --> 00:02:55,340
例えば､ awesomeという用語を1つではなく､ 2つの用語に置き換えたいとする｡ 

35
00:02:55,390 --> 00:02:59,500
そのためには､ 複数の項を矢印の右側で区切ればいいのです｡ 

36
00:02:59,710 --> 00:03:02,800
では､ もう一つ文字列を追加して構文を入力してみます｡ 

37
00:03:03,730 --> 00:03:04,840
とても素晴らしい｡ 

38
00:03:04,870 --> 00:03:11,470
矢印を置き換える用語であることは､ その後偉大なコンマスーパー｡ 

39
00:03:11,590 --> 00:03:14,050
だから､ コンマで用語を区切っているだけです｡ 

40
00:03:14,380 --> 00:03:20,140
つまりこれは､ 転置インデックスの中で､ awesomeがgreatとsuperの両方に置き換わることを意味する｡ 

41
00:03:20,620 --> 00:03:26,680
アナライザーの話をしたときに､ 用語の位置は転置インデックスの中に格納されていると言った｡

42
00:03:27,100 --> 00:03:33,130
近接検索での使い方はすでにご覧いただいたとおりですが､ 類義語でも使われます｡ 

43
00:03:33,490 --> 00:03:41,170
1つの用語に対して複数の置換を定義するとどうなるかというと､ 転置インデックス内の同じ位置に用語が格納されることになる｡

44
00:03:41,740 --> 00:03:48,080
例えば､ フィールドを解析したときに､ 5番目にawesomeという単語が現れる文書があったとする｡ 

45
00:03:48,100 --> 00:03:51,790
この言葉は､ グレートとスーパーの両方の言葉に置き換えられる｡ 

46
00:03:52,300 --> 00:03:58,060
これらの項は同じ位置に出現するので､ 事実上､ 5番目の位置に2つの項が存在することになる｡ 

47
00:03:58,600 --> 00:04:02,230
つまり､ 各ポジションには1つ以上の用語が含まれる可能性があります｡ 

48
00:04:02,620 --> 00:04:11,440
同義語に関してこのような動作をする理由は､ 同義語を利用した場合でも近接検索ができるようにしたいからです｡

49
00:04:11,830 --> 00:04:16,570
おおよその検索は､ スロットパラメータを持つマッチフレーズクエリであることを忘れないでください｡ 

50
00:04:16,690 --> 00:04:24,580
もしElasticsearchが転置インデックス内の新しい位置に同義語を挿入するだけなら､ フレーズクエリを効果的に混乱させることになります｡

51
00:04:25,090 --> 00:04:28,960
また､ 先ほどの構文と逆のことも可能です｡ 

52
00:04:28,990 --> 00:04:34,240
それは､ いくつかの用語を右ではなく､ 矢印の左でカンマで区切ることです｡ 

53
00:04:34,570 --> 00:04:39,220
これは､ 左側の項のいずれかを､ 右側に指定された項に置き換えるものである｡ 

54
00:04:39,400 --> 00:04:40,840
では､ そうしましょう｡ 

55
00:04:41,050 --> 00:04:49,960
そこで､ 私がやりたいことは､ Elasticsearchやlock､ stashやcabanaをyield keyという言葉に置き換えることです｡ 

56
00:04:50,650 --> 00:04:54,100
すべて小文字で挿入していることにお気づきですか？

57
00:04:54,610 --> 00:04:58,150
それには理由があるのですが､ それはまた後ほどご紹介します｡ 

58
00:04:58,660 --> 00:05:03,190
また､ カンマで区切られた用語のリストを指定する構文もある｡ 

59
00:05:03,220 --> 00:05:06,820
その一例を､ 奇妙でおかしな用語で見てみましょう｡ 

60
00:05:07,180 --> 00:05:09,970
だから､ 変なコンマを入力しちゃうんです｡ 

61
00:05:10,000 --> 00:05:10,990
不思議ですね｡ 

62
00:05:11,350 --> 00:05:18,190
この場合､ 2つの項が同じ位置に配置されるため､ この方法では置き換えは起こりません｡

63
00:05:18,730 --> 00:05:27,010
先に進む前に､ トークン・フィルターを定義する順番が重要であることを述べておきたい｡ なぜなら､ トークン・フィルターは指定された順番に実行されるからだ｡

64
00:05:27,340 --> 00:05:32,650
なぜこのような話をしたかというと､ 同義語をどのように定義すべきかに影響するからです｡ 

65
00:05:32,770 --> 00:05:36,820
同義語フィルタの前に小文字フィルタを追加していることに注目してください｡ 

66
00:05:37,330 --> 00:05:42,610
これは､ カスタムトークンフィルタが受け取るトークンがすべて小文字であることを意味します｡ 

67
00:05:42,730 --> 00:05:48,370
このため､ 置換する用語も小文字で定義する必要がある｡ そうしないと､ マッチングがkセンシティブになるため､

68
00:05:48,370 --> 00:05:51,820
マッチングされないからである｡

69
00:05:52,300 --> 00:05:58,210
2つのトークンフィルターを入れ替えていたら､ 大文字入力では同義語が機能しなくなりました｡ 

70
00:05:58,690 --> 00:06:04,480
その場合､ トークン・フィルタは大文字のトークンを受け取り､ 小文字のトークンと比較する可能性がありますが､

71
00:06:04,480 --> 00:06:06,280
これはマッチしません｡

72
00:06:06,850 --> 00:06:13,180
また､ 置換値も小文字で入力し､ 特にl kという用語は小文字で入力していることに注意してください｡ 

73
00:06:13,660 --> 00:06:17,890
それは､ 転置インデックス内の用語をすべて小文字にしたいからです｡ 

74
00:06:18,070 --> 00:06:24,040
あるいは､ 同義語フィルタの後に､ もう一度小文字フィルタを追加すればよかったかもしれませんね｡

75
00:06:24,430 --> 00:06:28,510
ポイントは､ 同義語フィルタを置き換える場所に注意することです｡ 

76
00:06:28,540 --> 00:06:34,720
文字のケーシングは､ これがうまくいかない場合の簡単な例に過ぎませんが､ 他の例としては､ ステミングが考えられます｡

77
00:06:35,080 --> 00:06:41,170
同義語フィルターは､ ステミングの前､ つまり配列のできるだけ初期に配置することをお勧めします｡ 

78
00:06:41,200 --> 00:06:43,630
小文字フィルタを除く｡ 

79
00:06:44,020 --> 00:06:48,370
そうでない場合は､ 同義語を定義する際に､ すべてのトークンフィルタを考慮する必要があります｡ 

80
00:06:48,370 --> 00:06:52,780
そして､ トークン・フィルターを追加したり削除したりすると､ すぐに維持が難しくなります｡ 

81
00:06:53,320 --> 00:06:58,870
それでは､ クエリを実行し､ その後､ 同義語を少し実験してみましょう｡ 

82
00:07:02,690 --> 00:07:03,830
すべてを試すために｡ 

83
00:07:03,830 --> 00:07:07,220
今回は､ 講座の最初に出てきたAnalyze APIを使ってみます｡ 

84
00:07:07,370 --> 00:07:10,580
まず､ 用語を解析するとどうなるかを確認したい｡ 

85
00:07:10,580 --> 00:07:11,270
すごい｡ 

86
00:07:12,360 --> 00:07:16,680
そこで､ 同義語インデックスに投稿リクエストを送信してみます｡ 

87
00:07:18,140 --> 00:07:29,030
そして､ アンダースコア解析APIと､ 上で入力したものと一致するmy underscore analyzerという名前のカスタムアナライザーを使用します｡

88
00:07:29,790 --> 00:07:34,830
そして､ awesomeという言葉であるテキストを指定してください｡ 

89
00:07:37,470 --> 00:07:45,270
粗製乱造を実行すると､ greatとsuperの両方に置き換えられ､ これら両方の項がゼロの位置に配置されることがわかる｡

90
00:07:46,020 --> 00:07:50,280
もう1つの同義語ルールを使って､ Elasticsearchという用語を分析してみましょう｡ 

91
00:07:50,460 --> 00:07:57,420
そこで､ 既存のクエリを残すために､ このコピーを作成し､ テキストをElasticsearchに変更します｡ 

92
00:08:00,550 --> 00:08:04,150
その結果､ 項l kに置き換わっていることがわかる｡ 

93
00:08:04,210 --> 00:08:08,150
大文字で書いたのに､ 用語が置き換わっていることに注目してください｡ 

94
00:08:08,170 --> 00:08:13,540
それは､ 先ほどの同義語フィルタの前に小文字フィルタが実行されるからです｡ 

95
00:08:14,200 --> 00:08:16,300
次は､ 「変」という言葉に挑戦してみましょう｡ 

96
00:08:16,420 --> 00:08:24,760
だから､ ここにスペースを作って､ クエリを貼り付けて､ テキストとしてweirdと書いておくんだ｡ 

97
00:08:26,850 --> 00:08:27,150
これです｡ 

98
00:08:27,150 --> 00:08:31,920
weirdとstrangeという用語が同じ位置に挿入されていることがわかる｡ 

99
00:08:31,950 --> 00:08:35,310
我々が定義したルールに従って置換される用語はない｡ 

100
00:08:35,940 --> 00:08:39,780
では､ 実際に文章を解析して､ どのような結果が得られるか試してみましょう｡ 

101
00:08:41,460 --> 00:08:44,940
というわけで､ 今回もクエリで貼り付けます｡ 

102
00:08:45,570 --> 00:08:47,660
では､ 文章を入力してみましょう｡ 

103
00:08:47,670 --> 00:08:48,750
と言ってみる｡ 

104
00:08:49,020 --> 00:08:56,130
Elasticsearchは素晴らしいものですが､ 時々奇妙に思えることもあります｡ 

105
00:08:59,650 --> 00:09:00,910
結果を見てみると

106
00:09:00,910 --> 00:09:05,560
Elasticsearchという用語は､ 2番目の位置でl kに置き換えられています｡ 

107
00:09:05,590 --> 00:09:09,670
awesomeという言葉に代わって､ greatとsuperという言葉があります｡ 

108
00:09:10,510 --> 00:09:16,240
下にスクロールしていくと､ 7番目にweirdとstrangeという用語が配置されていることがわかる｡

109
00:09:16,840 --> 00:09:21,250
これで､ 転置インデックスに同義語がどのように格納されるかを理解できたはずです｡ 

110
00:09:21,250 --> 00:09:24,760
では､ 先ほど分析した文章を含むドキュメントを追加してみましょう｡ 

111
00:09:24,970 --> 00:09:27,220
そこで､ この文章をコピーすることにします｡ 

112
00:09:28,350 --> 00:09:33,780
次に､ synonymsインデックスとデフォルトタイプへのポストクエリを書きます｡ 

113
00:09:38,450 --> 00:09:44,240
こんな感じで､ コピーした文章をdescriptionに設定します｡ 

114
00:09:45,020 --> 00:09:52,340
編集して､ インデックスに対していくつかの検索クエリを実行してみましょう｡ まず､ greatsという用語を探すマッチクエリから始めます｡

115
00:09:54,950 --> 00:09:55,940
わかりました｡ 

116
00:09:57,530 --> 00:10:00,260
だから同義語を用意する｡ 

117
00:10:00,950 --> 00:10:03,290
デフォルトタイプの検索APIと､

118
00:10:06,710 --> 00:10:11,110
説明フィールドのマッチングクエリ｡

119
00:10:11,120 --> 00:10:13,190
グレードを検索する｡ 

120
00:10:15,200 --> 00:10:21,650
Elasticsearchに送信したJSONにはgreatという単語が含まれていませんでしたが､ このクエリはドキュメントにマッチしています｡

121
00:10:21,980 --> 00:10:26,920
これはもちろん､ awesomeという言葉が､ greatやsuperという言葉に置き換わったからです｡ 

122
00:10:26,930 --> 00:10:30,500
そして､ クエリは転置インデックスを検索するので､ 一致するものが得られる｡ 

123
00:10:31,110 --> 00:10:34,810
さて､ 先ほどスゴイという言葉が置き換わったと言いましたが､ その通りです｡ 

124
00:10:34,820 --> 00:10:37,260
では､ スゴイを探すとどうなるのか？

125
00:10:37,280 --> 00:10:39,380
やはりドキュメントは一致させたい｡ 

126
00:10:39,410 --> 00:10:41,480
見てみよう､ どうなるか｡ 

127
00:10:41,930 --> 00:10:43,850
そこで､ このクエリをコピーすることにします｡ 

128
00:10:44,890 --> 00:10:46,150
この下にペーストしてください｡ 

129
00:10:47,390 --> 00:10:48,530
と検索してください｡ 

130
00:10:48,530 --> 00:10:49,280
すごい｡ 

131
00:10:52,610 --> 00:10:54,920
このクエリはまだドキュメントにマッチしています｡ 

132
00:10:54,950 --> 00:10:55,910
それは素晴らしいことです｡ 

133
00:10:55,910 --> 00:10:57,230
しかし､ それはなぜでしょうか？

134
00:10:57,530 --> 00:11:04,280
それは､ Elasticsearchにクエリを送信する際に､ この場合､ どのフィールドでdescriptionをカバーしているかをチェックするためです｡

135
00:11:04,550 --> 00:11:10,430
そして､ そのフィールドに定義されているアナライザー､ または定義されていない場合は標準のアナライザーを使用して､

136
00:11:10,430 --> 00:11:13,010
検索クエリーを分析します｡

137
00:11:13,340 --> 00:11:16,220
少なくとも全文検索の場合は､ ご存知のようにそうです｡ 

138
00:11:16,610 --> 00:11:21,450
つまり､ 検索クエリも文書と全く同じ解析プロセスを経ているのです｡ 

139
00:11:21,470 --> 00:11:25,920
そのため､ Elasticsearchは転置インデックス内でawesomeという単語を検索しません｡ 

140
00:11:25,940 --> 00:11:32,330
その代わり､ 用語を同義語に置き換えるという分析作業の結果を利用しています｡ 

141
00:11:32,630 --> 00:11:39,230
つまり､ 基本的に置換値がgreatとsuperの両方であることを転置インデックスで検索していることになる｡

142
00:11:39,590 --> 00:11:46,460
これは舞台裏で私たちのために起こることですが､ これはreplaceの条件と置換値の両方を一致させることができることを意味します｡

143
00:11:46,850 --> 00:11:51,800
これは､ Elasticsearchが転置インデックス内のすべての用語を保存する必要がなく､

144
00:11:51,800 --> 00:11:55,340
実際にスペースを節約できることを意味し､ 賢い方法です｡

145
00:11:55,970 --> 00:11:59,420
そして､ 同義語を使って検索クエリを改善する方法です｡ 

146
00:11:59,450 --> 00:12:09,860
これは非常に強力な機能で､ 同義語を使いたい場合の例として､ フラットとアパートという言葉が同じものであると定義することを競うのは非常に簡単なことです｡
