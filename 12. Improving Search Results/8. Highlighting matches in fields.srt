1
00:00:02,240 --> 00:00:07,130
検索エンジンの検索結果で､ クエリにマッチする部分が強調されていることにお気づきでしょうか？

2
00:00:07,550 --> 00:00:11,570
GoogleやBing､ あるいはあなたが使っている検索エンジンでこれを見たのでしょう｡ 

3
00:00:11,960 --> 00:00:15,800
Elasticsearchでも､ highlighterと呼ばれるものを使って､ これを行うことができます｡ 

4
00:00:16,310 --> 00:00:18,530
さっそく例を挙げてみましょう｡ 

5
00:00:18,920 --> 00:00:23,480
あらかじめ新しいインデックスにテスト文書を追加しておきましたので､ それをご覧ください｡ 

6
00:00:23,750 --> 00:00:27,590
説明のフィールドが入っているだけなので､ 特に何もありません｡ 

7
00:00:28,010 --> 00:00:34,430
そして､ descriptionフィールド内のElasticsearchのストーリーを検索するシンプルなマッチクエリをあらかじめ追加しておきました｡

8
00:00:35,000 --> 00:00:39,140
結果を見やすくするためだけに､ ソース文書を返すことはないのだ｡ 

9
00:00:39,830 --> 00:00:44,870
私たちができることは､ リクエストボディのトップレベルにハイライトオブジェクトを追加することです｡ 

10
00:00:45,020 --> 00:00:46,670
だから､ それをやってみよう｡ 

11
00:00:47,330 --> 00:00:49,940
だから､ オブジェであることを強調する｡ 

12
00:00:50,300 --> 00:00:56,120
このオブジェクトの中に､ ハイライト表示を有効にするフィールドを含むfieldsオブジェクトを追加する必要があります｡

13
00:00:56,630 --> 00:01:00,050
だから､ フィールドもオブジェクトである｡ 

14
00:01:00,560 --> 00:01:04,310
そして､ フィールドは1つだけなので､ これは説明フィールドになります｡ 

15
00:01:04,310 --> 00:01:06,440
そこで､ その名前のキーを追加することにします｡ 

16
00:01:06,680 --> 00:01:08,210
だから説明｡ 

17
00:01:09,510 --> 00:01:11,910
値を空のオブジェクトにしておきます｡ 

18
00:01:12,650 --> 00:01:17,510
このオブジェクトの中で､ ハイライトの設定を行うことができますが､ 今は行いません｡ 

19
00:01:17,630 --> 00:01:22,790
それは､ ハイライトはそれだけで大きなテーマであり､ 物事がかなり複雑になってくるからです｡ 

20
00:01:23,120 --> 00:01:27,800
ハイライターは数種類あり､ それぞれ異なる方法でハイライトを行うことができます｡ 

21
00:01:28,010 --> 00:01:34,520
特に指定しない限り､ 平面という名の蛍光ペンを使用しますので､ ほとんどの場合これで十分です｡ 

22
00:01:34,610 --> 00:01:37,700
ともかく､ クエリを実行して結果を見てみましょう｡ 

23
00:01:40,460 --> 00:01:42,650
履歴内の各試合について｡ 

24
00:01:42,650 --> 00:01:45,110
ハイライトという新しいキーができました｡ 

25
00:01:45,380 --> 00:01:49,940
これは､ リクエストでハイライトを要求したフィールドを含むアップデートです｡ 

26
00:01:49,970 --> 00:01:52,460
この場合､ 説明欄のみ｡ 

27
00:01:53,060 --> 00:01:57,350
説明のキーには､ クエリにマッチするフラグメントの配列が含まれます｡ 

28
00:01:57,590 --> 00:02:04,820
配列が返ってくるのは､ もちろん､ 説明フィールドの複数のパスや断片がクエリにマッチする可能性があるからです｡

29
00:02:05,300 --> 00:02:10,250
この例では､ Elasticsearchという用語がフィールドの先頭付近と末尾の両方に出現しているため､

30
00:02:10,250 --> 00:02:11,540
このようになります｡

31
00:02:11,870 --> 00:02:15,560
Elasticsearchはフィールドが非常に長くなる可能性があるため､ フラグメントを返します｡ 

32
00:02:15,890 --> 00:02:25,220
もしフィールドがこの文書のために5000語を保存していたらと想像してみると､ 5000語すべてを表示し､ 最初と最後に単語をハイライトすることは何の意味もないでしょう｡

33
00:02:25,520 --> 00:02:34,040
その代わりに､ Elasticsearchがマッチしたタームの前後にある単語を含むフラグメントを返すことで､ ユーザーにちょっとした文脈を与えていることに注目してください｡

34
00:02:34,610 --> 00:02:43,640
また､ もうお気づきかと思いますが､ ハイライトはMタグで囲まれており､ これはストーリーとElasticsearchの用語の両方に当てはまります｡

35
00:02:44,180 --> 00:02:52,610
これにより､ 何らかの処理を行いたい場合や､ フラグメントを直接ユーザーに表示したい場合に､ アプリケーションレベルで簡単にマッチングを見つけることができます｡

36
00:02:53,150 --> 00:02:57,410
しかし､ なぜマッチをIMテキストで包むためにElasticsearchまで必要なのでしょうか？

37
00:02:57,440 --> 00:03:02,990
私たちの便宜のため以外に､ アプリケーションのコード内で自分でこれを行うことはできないのでしょうか？

38
00:03:03,230 --> 00:03:04,640
いや､ そうでもないんです｡ 

39
00:03:05,000 --> 00:03:10,880
Elasticsearchはクエリを分析することを忘れないでください｡ 潜在的に同義語やステミングを扱うことになりますが､

40
00:03:10,880 --> 00:03:14,270
例えば､ 同義語を例に挙げてみましょう｡

41
00:03:14,300 --> 00:03:15,110
だから投稿してください｡ 

42
00:03:15,110 --> 00:03:20,990
happyという用語を含む文書をインデックス化し､ この用語の同義語であるdeliciousを追加したこと｡ 

43
00:03:21,380 --> 00:03:27,710
それを検索すると､ 以前の講義で見た､ happyという言葉を含む文書にマッチします｡

44
00:03:27,950 --> 00:03:29,750
しかし､ ハイライトはどうでしょうか？

45
00:03:30,260 --> 00:03:37,910
Elasticsearchは､ ソース文書内のその位置にあるオリジナルの用語をハイライトするため､ 自動的にこれを処理します｡

46
00:03:38,330 --> 00:03:44,630
何が起こるかというと､ 次のようになります｡ Elasticsearchは転置インデックス内で削除された用語の検索を実行し､

47
00:03:44,630 --> 00:03:49,760
説明フィールドが分析プロセスを通過したため､ 一致したものを見つけます｡

48
00:03:50,150 --> 00:03:55,940
その際､ 転置インデックス内でhappyという用語がdeletedという用語に置き換えられているため､

49
00:03:55,940 --> 00:03:57,110
一致するのである｡

50
00:03:57,680 --> 00:04:03,290
このクエリも同じように分析されるので､ 「happy」と検索してもマッチすることを思い出してください｡

51
00:04:03,800 --> 00:04:09,950
転置インデックスには､ 元の用語がソース文書内のどこに出現したかを示すオフセットが含まれていることを思い出してください｡

52
00:04:10,250 --> 00:04:16,190
つまり､ 削除された用語は転置インデックスに格納されますが､ Elasticsearchはソースドキュメント内の対応する用語のオフセットを格納し､

53
00:04:16,190 --> 00:04:20,150
その用語がハッピーであることを示します｡

54
00:04:20,630 --> 00:04:27,080
これにより､ 蛍光ペンは､ 全く別の用語であっても､ 元の用語をタグの中で包むことができます｡

55
00:04:27,530 --> 00:04:33,530
そのため､ deletedという言葉で検索しても､ happyという言葉が検索結果内で強調表示されます｡ 

56
00:04:33,560 --> 00:04:34,790
カッコイイでしょ？

57
00:04:35,210 --> 00:04:37,820
ステミングなども同様です｡ 

58
00:04:38,210 --> 00:04:45,140
要は､ エラスティックサーチがタグ内のマッチをどのようにラップするかは､ 単に文字列置換を行うよりも複雑なのです｡

59
00:04:45,140 --> 00:04:49,070
だから､ どんな理由であれ､ この動作を真似しようとしてはいけないというのが本音です｡ 

60
00:04:49,670 --> 00:04:53,840
ともあれ､ ちょっとした予備知識でしたので､ ご理解いただけたかと思います｡ 

61
00:04:53,990 --> 00:04:58,820
そうでない場合は､ 裏側を理解しなくても､ 蛍光ペンは全く問題なく使用できますので､

62
00:04:58,820 --> 00:05:00,170
ご心配なく｡

63
00:05:00,800 --> 00:05:05,750
もうひとつ､ この講義で紹介したいのは､ pre underscore textとpost underscore

64
00:05:05,750 --> 00:05:11,150
textというパラメータを使って､ マッチを別の手法でラップする方法です｡

65
00:05:11,720 --> 00:05:15,080
そこで､ この2つのパラメータをハイライトオブジェクト内に追加してみましょう｡ 

66
00:05:15,110 --> 00:05:17,900
まず､ アンダースコア前のテキストパラメータ｡ 

67
00:05:18,680 --> 00:05:20,540
配列に変えてみる｡ 

68
00:05:21,850 --> 00:05:23,530
文字列の配列であること｡ 

69
00:05:24,130 --> 00:05:31,840
そこで､ Mタグの代わりにstrongタグを使いたいとすると､ scoreタグのパラメータで投稿に同じことをすることができるのです｡

70
00:05:33,130 --> 00:05:36,430
だから､ ここではstrongタグを閉じるだけでいいんです｡ 

71
00:05:36,430 --> 00:05:42,490
そこで､ このクエリをもう一度実行すると､ マッチした部分がstrongタグの中に読み込まれるようになったことがわかります｡ 

72
00:05:43,150 --> 00:05:46,690
以上､ Elasticsearchのマッチングをハイライトする基本的な方法でした｡ 

73
00:05:46,840 --> 00:05:54,100
私が言ったように､ 多くの設定オプションと蛍光ペンが利用可能ですが､ このコースでカバーできるよりもはるかに多くあります｡

74
00:05:54,340 --> 00:06:00,830
もし､ この講義で取り上げた内容よりも具体的なことが必要であれば､ ドキュメントをチェックすることをお勧めします｡

75
00:06:00,850 --> 00:06:04,030
ご参考までに､ この講演のリンクを貼っておきます｡ 
