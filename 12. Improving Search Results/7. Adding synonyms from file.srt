1
00:00:02,440 --> 00:00:04,800
同義語の定義の仕方を見ただけでしょう｡ 

2
00:00:04,810 --> 00:00:09,310
しかし､ 同義語がたくさんあるとすぐに不便になる場合はどうしたらいいのでしょうか？

3
00:00:09,310 --> 00:00:17,830
インデックスを削除しないと同義語を変更できないため､ また､ インデックス定義に非常に大きな配列が含まれることになるためです｡

4
00:00:18,370 --> 00:00:24,910
このような問題を解決するには､ ファイル内で同義語を定義すればよいのですが､ 通常はそうしたいものです｡

5
00:00:25,000 --> 00:00:31,240
そのためには､ synonyms underscore pathというパラメータに､ ファイルへのパスを指定する｡ 

6
00:00:31,870 --> 00:00:36,580
ファイルは､ 前回の講義で見たのと同じ形式を含むテキストファイルでなければなりません｡ 

7
00:00:36,580 --> 00:00:45,790
ただ､ 1行に1つのルールで､ 引用符を付けずに､ 同義語ファイルのパスは､ 絶対パスか､ 競合ディレクトリからの相対パスである必要があります｡

8
00:00:46,300 --> 00:00:51,280
あらかじめ､ サンプルファイルを追加しておきましたので､ それを見てみましょう｡ 

9
00:00:52,290 --> 00:00:59,910
Dockerコンテナ内でElasticsearchクラスタを動かしているので､ 隔離されたコンテナに入るためにいくつかのコマンドを実行する必要があります｡

10
00:01:00,090 --> 00:01:07,350
これから紹介するコマンドはDockerに特化したものなので､ もしDockerを使ったことがなくても心配は要りません｡

11
00:01:07,590 --> 00:01:13,050
ElasticsearchをOSに直接インストールした場合は､ コマンドプロンプトやターミナル､

12
00:01:13,050 --> 00:01:20,820
あるいはエクスプローラやファインダなどのファイルエクスプローラでconfigディレクトリに移動するだけです｡

13
00:01:21,390 --> 00:01:25,710
とにかく､ いくつかのコマンドを入力して､ configディレクトリに移動してみます｡ 

14
00:01:38,140 --> 00:01:38,530
これです｡ 

15
00:01:38,530 --> 00:01:44,230
analysisというディレクトリを作成し､ その中にsynonyms to textというファイル名で保存しています｡ 

16
00:01:44,650 --> 00:01:47,020
このファイルの中身を見てみましょう｡ 

17
00:01:51,340 --> 00:01:58,580
見ての通り､ 形式は前回の講義で見たものと同じですが､ 配列ではなく､ 1行に1つのルールを追加しているだけです｡

18
00:01:58,600 --> 00:02:04,270
このファイルはGitHubのリポジトリで見ることができますので､ 詳しく見たい方､ 自分で使いたい方はご覧ください｡

19
00:02:04,780 --> 00:02:05,230
わかりました｡ 

20
00:02:05,230 --> 00:02:06,670
カバナに戻ろう｡ 

21
00:02:08,040 --> 00:02:12,570
前回の講義のクエリをあらかじめ修正しておいたことにお気づきでしょうか｡ 

22
00:02:12,600 --> 00:02:16,380
configディレクトリからの相対パスを指定したところです｡ 

23
00:02:16,560 --> 00:02:21,210
先ほども言ったように､ やろうと思えば絶対パスを指定することもできたのです｡ 

24
00:02:21,720 --> 00:02:27,030
Windowsの場合は､ フォワードスラッシュではなく､ バックスラッシュでパスを指定するようにしてください｡ 

25
00:02:27,510 --> 00:02:32,250
とにかく､ クエリを実行してみましょう｡ ただし､ その前にノートを再起動することを忘れないでください｡ 

26
00:02:32,370 --> 00:02:37,150
また､ 前回の講義の既存の索引をあらかじめ削除していることにもご注意ください｡ 

27
00:02:37,170 --> 00:02:38,700
一応､ フォローしておきます｡ 

28
00:02:42,030 --> 00:02:42,810
それをテストしてみましょう｡ 

29
00:02:42,810 --> 00:02:49,080
アナライザーは前回の講義と同じように動作し､ 同義語ファイルが実際に使用されていることを示すだけです｡

30
00:02:50,470 --> 00:02:54,580
そこで､ 同義語インデックスに解析済みAPIを使ってみることにする｡ 

31
00:02:58,860 --> 00:03:03,240
カスタムアナライザー､ マイアンダースコアアナライザーを指定します｡ 

32
00:03:04,740 --> 00:03:06,450
そして､ いくつかのテキスト｡ 

33
00:03:06,930 --> 00:03:08,880
さて､ Elasticsearchを書きます｡ 

34
00:03:10,710 --> 00:03:16,500
その結果､ 前回の講義で見たのと全く同じように､ 古典的な検索語がl kに置き換えられる｡ 

35
00:03:17,360 --> 00:03:17,750
なるほど｡ 

36
00:03:17,780 --> 00:03:19,910
そのため､ 現在はすべて以前と同じように動作しています｡ 

37
00:03:19,910 --> 00:03:23,360
ただ､ この講演を終える前に､ いくつか触れておきたいことがあります｡ 

38
00:03:23,600 --> 00:03:30,170
まず､ 同義語ファイルは､ インデックス用の文書を格納しているすべてのノードで､ アナライザーを使って利用できるようにする必要がある｡

39
00:03:30,710 --> 00:03:35,480
物事をシンプルにするために､ おそらく最も簡単な方法は､ すべてのノードにファイルを保存することです｡ 

40
00:03:36,140 --> 00:03:38,870
もうひとつ､ 大切なことがあります｡ 

41
00:03:39,230 --> 00:03:44,660
新しいシノニムをファイルに追加し､ ノードを再起動すれば､ すべてがうまくいくと思うかもしれません｡ 

42
00:03:44,990 --> 00:03:51,110
しかし､ 追加するシノニムを含むインデックス文書がすでに存在する可能性があります｡

43
00:03:51,320 --> 00:03:54,950
なぜそれが問題なのか､ 例を挙げて見てみましょう｡ 

44
00:03:55,430 --> 00:04:02,200
そこで､ ポストIは､ Elasticsearchという用語を含む文書をインデックスし､ その用語のl kの同義語を追加することにします｡

45
00:04:02,210 --> 00:04:07,100
その後､ 適切なノードを再起動し､ すべてがうまくいくことを期待します｡ 

46
00:04:07,640 --> 00:04:12,080
しかし､ Elasticsearchの検索クエリを実行しても､ 何もマッチしないのです｡ 

47
00:04:12,200 --> 00:04:18,200
その理由は､ ちょっとわかりにくいかもしれませんが､ 文書をインデックス化する時点では､ Elasticsearchという用語の同義語がないため､

48
00:04:18,200 --> 00:04:24,200
そのまま転置インデックスに追加しているのです｡

49
00:04:24,770 --> 00:04:27,620
後の時点で､ 同義語が追加されます｡ 

50
00:04:27,770 --> 00:04:35,360
そのシノニムはノードを再起動した直後から有効ですが､ 新しい文書のインデックス作成時や既存の文書の更新時にのみ有効です｡

51
00:04:35,690 --> 00:04:43,250
これは､ Elasticsearchがノードの再起動時に新しい同義語をピックアップするためですが､ 再起動時にドキュメントの再インデックス化を行うわけではありません｡

52
00:04:44,170 --> 00:04:44,560
なるほど｡ 

53
00:04:44,590 --> 00:04:50,350
つまり､ この時点で転置インデックスには､ 検索対象であるElasticsearchという用語が含まれていることになります｡

54
00:04:50,350 --> 00:04:52,480
では､ なぜ文書が一致しないのでしょうか？

55
00:04:52,690 --> 00:04:57,730
なぜなら､ 検索クエリは全文フィールドと同じ解析プロセスを経るからです｡ 

56
00:04:58,300 --> 00:05:00,880
その一環として､ 同義語を探すということがあります｡ 

57
00:05:00,880 --> 00:05:05,130
そのため､ 検索クエリを実行すると､ Elasticsearchは新しい同義語をピックアップしています｡ 

58
00:05:05,140 --> 00:05:10,530
つまり､ Elasticsearchを検索するのではなく､ 実はその裏でイルカイを検索しているのです｡ 

59
00:05:10,540 --> 00:05:16,090
また､ 転置インデックスにはElasticsearchという用語が含まれているため､ ドキュメントはマッチしない｡ 

60
00:05:16,720 --> 00:05:19,160
何が問題なのか､ ご理解いただけたでしょうか｡ 

61
00:05:19,180 --> 00:05:21,130
では､ その解決策とは？

62
00:05:21,520 --> 00:05:24,070
実は見たことがあるようなものなんです｡ 

63
00:05:24,160 --> 00:05:30,910
Query APIによる更新は､ 先ほどの講座で見たクエリを実行するだけで､ すべて完了します｡ 

64
00:05:31,450 --> 00:05:36,190
そうすると､ 文書が再インデックス化されるので､ クエリーは一致するはずです｡ 

65
00:05:36,190 --> 00:05:39,160
ということで､ 同義語についてはこの辺で｡ 
