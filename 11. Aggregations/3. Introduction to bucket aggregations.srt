1
00:00:02,420 --> 00:00:09,770
メトリックアグリゲーションについて見てきましたが､ 次は別のアグリゲーションのグループ､ すなわちバケットアグリゲーションについて見てみましょう｡

2
00:00:10,220 --> 00:00:21,020
バケット集計は､ メトリック集計よりも少し複雑ですが､ 非常に強力で､ 特にいくつかの講義で見るような本当にクールなことを行うことができます｡

3
00:00:21,680 --> 00:00:27,440
バケットアグリゲーションは､ フィールドのメトリクスを計算するのではなく､ ドキュメントのバケットを作成します｡ 

4
00:00:27,440 --> 00:00:29,870
つまり､ 基本的にドキュメントのセットです｡ 

5
00:00:30,550 --> 00:00:37,330
アグリゲーションには､ 単一のバケットを生成するもの､ 固定数のもの､ 複数のバケットを動的に生成するものなどがあります｡

6
00:00:37,810 --> 00:00:43,840
各バケツには､ 与えられた文書がそのバケツに入るかどうかを決定する基準があります｡ 

7
00:00:44,170 --> 00:00:51,250
少し複雑に聞こえますので､ 早送りして､ すべてを理解しやすくするための例を紹介しましょう｡

8
00:00:51,910 --> 00:01:01,000
ただ､ マトリックスバケット集計として知られているように､ 値を計算する代わりに､ 基本的に単なる文書の集合であるバケットを作成することに注意してください｡

9
00:01:01,870 --> 00:01:08,980
最初に利用するのは､ ユニークな値ごとにバケットを動的に構築する項集約である｡

10
00:01:09,520 --> 00:01:13,990
これを利用して､ ステータス・フィールドの値に基づいて他の人をグループ化することができるのです｡ 

11
00:01:13,990 --> 00:01:15,130
では､ そうしましょう｡ 

12
00:01:15,730 --> 00:01:18,940
ここにクエリの骨格がロードされているわけです｡ 

13
00:01:19,770 --> 00:01:24,270
そして､ スコア・タームにステータスという名のアグリゲーションを追加する｡ 

14
00:01:25,020 --> 00:01:27,330
見たことのあるような物体であること｡ 

15
00:01:28,170 --> 00:01:37,050
そして集約型は､ とりあえずサイズパラメータを取っ払って､ ステータスとなるフィールドを指定するだけの条件です｡

16
00:01:39,160 --> 00:01:40,630
そして､ 実行してみてください｡ 

17
00:01:40,930 --> 00:01:48,430
結果を見ると､ statusフィールドの一意な値ごとに､ bucketsキーの下にバケットが作成されていることがわかります｡

18
00:01:48,640 --> 00:01:56,260
値はkeyキーで返され､ docアンダースコアcountキーで各バケットに該当する文書数を指定する｡

19
00:01:56,890 --> 00:02:04,270
レスポンスには､ doc count error､ upper bound､ その他のdoc countsという2つのキーも含まれていることに注目してください｡

20
00:02:04,870 --> 00:02:10,090
最初のものについては､ 次回の講義で詳しく説明しますので､ 今は割愛します｡ 

21
00:02:10,570 --> 00:02:12,710
では､ 他のドクターの数はどうなっているのでしょうか？

22
00:02:12,730 --> 00:02:13,960
キーはどうなっているのですか？

23
00:02:14,440 --> 00:02:17,230
Elasticsearchは､ トップユニークタームに返します｡ 

24
00:02:17,230 --> 00:02:21,970
そのため､ さまざまな用語がある場合､ そのうちのいくつかは検索結果に表示されません｡ 

25
00:02:22,540 --> 00:02:24,190
他にもドックカウントがありますね｡ 

26
00:02:24,220 --> 00:02:29,020
キーは､ 回答に含まれなかった用語の文書数の一部です｡ 

27
00:02:29,350 --> 00:02:34,840
この例では､ statusフィールドに5種類の値しかないため､ 数値は0になります｡ 

28
00:02:34,960 --> 00:02:37,200
例えば50個あるとします｡ 

29
00:02:37,210 --> 00:02:40,780
その場合､ すべての用語がバケツとして表示されることはないでしょう｡ 

30
00:02:41,440 --> 00:02:47,350
doc count key の合計には､ レスポンスから取り残されたバケットの doc underscore count key

31
00:02:47,350 --> 00:02:49,240
の合計が含まれることになります｡

32
00:02:49,720 --> 00:02:55,810
様々な値を持つアンダースコアの合計金額フィールドに変更するとどうなるか見てみましょう｡

33
00:02:58,050 --> 00:02:59,490
そして､ もう一度実行する｡ 

34
00:03:01,590 --> 00:03:08,130
さて､ some underscore other underscore doc underscore countyは986という値になっているのでしょうか｡ 

35
00:03:08,610 --> 00:03:15,510
doc underscore countyとresponseを全て合計すると､ 1000文書あるので14となります｡

36
00:03:16,590 --> 00:03:21,270
この変更を元に戻して､ フィールドをステータスに戻すだけです｡ 

37
00:03:21,930 --> 00:03:26,310
ステータス・フィールドには5つのユニークな値しかないので､ 何の違いも見られません｡ 

38
00:03:26,310 --> 00:03:27,900
でも､ ポイントは押さえていますね｡ 

39
00:03:28,080 --> 00:03:33,450
しかし､ statusフィールドを全く含まない文書や､ 値がNullの文書があった場合はどうでしょうか？

40
00:03:33,870 --> 00:03:39,990
missingパラメータを追加することで､ そのような文書が置かれるバケットの名前を指定することができる｡

41
00:03:40,590 --> 00:03:45,920
そこで､ missingというパラメータを追加し､ その値をバケツの名前にすることにしましょう｡ 

42
00:03:45,930 --> 00:03:54,360
RNスラッシュa short for not availableに追加するだけで､ このクエリを実行しても､ 実際には何の違いも見られません｡

43
00:03:54,720 --> 00:03:59,700
それは､ statusフィールドを持たないか､ nullの値を含むオーダーがないからです｡ 

44
00:04:00,270 --> 00:04:03,060
それでもバケツは返してほしいかもしれませんね｡ 

45
00:04:03,090 --> 00:04:03,630
おそらく｡ 

46
00:04:03,630 --> 00:04:08,190
そのため､ アプリケーションのコードによっては､ それが存在するかどうかを条件付きで処理する必要があります｡ 

47
00:04:08,910 --> 00:04:15,720
そのためには､ min underscore doc underscore count というパラメータを追加して､

48
00:04:15,720 --> 00:04:20,070
バケツに含まれる文書の最小数を指定すればよい｡

49
00:04:20,960 --> 00:04:26,840
デフォルト値は1であるため､ このパラメータがない場合､ 結果的にバケットが生成されない｡ 

50
00:04:26,870 --> 00:04:30,350
パラメータをゼロにすると､ バケツが現れるはずだ｡ 

51
00:04:31,610 --> 00:04:36,620
そこで､ min underscore doc underscore countで､ 0にする｡ 

52
00:04:37,360 --> 00:04:39,010
そして､ また採石場を走らせる｡ 

53
00:04:39,370 --> 00:04:45,640
そして､ 案の定､ 結果の中にスラッシュaという名前のバケツがあり､ ドキュメント数が0になっていることがわかります｡ 

54
00:04:46,180 --> 00:04:50,850
さて､ 電卓の文書数はおおよその目安であることを簡単に申し上げておきます｡ 

55
00:04:50,860 --> 00:04:54,130
そのため､ シナリオによっては正確でない場合があります｡ 

56
00:04:54,160 --> 00:04:58,840
それについては､ 次回の講義でもっと詳しく説明しますので､ 今はこれ以上話しません｡ 

57
00:04:59,830 --> 00:05:07,420
また､ バケットの並び順は､ サブアグリゲーションなど､ さまざまな方法が可能ですが､ これはまだ調べていません｡

58
00:05:07,540 --> 00:05:12,240
そこで､ その代わりに､ バケットを用語の昇順で並べることにします｡ 

59
00:05:12,250 --> 00:05:18,520
そのためには､ アンダースコアのタームキーとオーダー方向を含むオーダーパラメータを追加すればよい｡ 

60
00:05:19,030 --> 00:05:25,960
アンダースコアの用語キーは､ バケツキーがステータスフィールドの値であることを参照できる特別なキーである｡

61
00:05:25,960 --> 00:05:27,520
では､ 実際に見てみましょう｡ 

62
00:05:28,880 --> 00:05:36,440
では､ オーラルパラメーターとスコアタームと昇順で､ どのように見えるか見てみましょう｡ 

63
00:05:37,070 --> 00:05:41,870
そして今､ バケツはステータス・フィールドに従って昇順で並べられたことがわかります｡ 

64
00:05:42,590 --> 00:05:43,130
わかりました｡ 

65
00:05:43,130 --> 00:05:51,320
実はこの集約は､ バケット集約の入門編として､ この講義で取り上げたい唯一の集約だったんです｡

66
00:05:51,890 --> 00:05:58,010
以下の講義では､ バケットアグリゲーションがどのように機能するかの基本がわかったところで､ さらにいくつかのバケットアグリゲーションについて説明します｡

67
00:05:58,370 --> 00:06:04,820
この講義の主な内容を要約すると､ バケット集計は､ ある基準に基づく文書の集合であるバケットを作成する､

68
00:06:04,820 --> 00:06:07,880
ということです｡

69
00:06:08,030 --> 00:06:12,170
その基準は､ 使用される特定のバケットアグリゲーションに依存する｡ 

70
00:06:12,740 --> 00:06:19,580
このレクチャーでは､ 与えられたフィールドのユニークな用語ごとにバケットを作成する､ 用語集計の動作をご覧いただきました｡

71
00:06:19,820 --> 00:06:24,500
バケットアグリゲーションによって､ 多くのクールなことができるようになります｡ 
