1
00:00:02,320 --> 00:00:10,210
先ほどは範囲集計を見たが､ これはどのバケツに文書を入れるかを決める範囲をいくつも指定できるようにしたものである｡

2
00:00:10,360 --> 00:00:14,560
しかし､ その際には､ あらかじめ範囲を明示的に定義しておく必要がありました｡ 

3
00:00:14,740 --> 00:00:19,060
注文金額に25の間隔を指定したい場合はどうすればよいのでしょうか｡ 

4
00:00:19,180 --> 00:00:22,520
そのためには､ 最低額と最高額を知ることが必要です｡ 

5
00:00:22,540 --> 00:00:26,890
注文を逃すことを許容できるなら別ですが､ たぶん無理でしょう｡ 

6
00:00:27,250 --> 00:00:30,730
それでも､ たくさんの範囲を明示的に追加する必要があります｡ 

7
00:00:30,790 --> 00:00:37,570
もちろん､ Elasticsearchにクエリを送信するアプリケーションの中でこれを自動化することもできますが､ 幸いなことに､ もっと良い方法があるのです｡

8
00:00:37,600 --> 00:00:39,910
ヒストグラムというものを使って｡ 

9
00:00:40,300 --> 00:00:46,270
ヒストグラムは､ 数値フィールドの値から､ 指定された間隔に基づいて動的にバケットを構築するものです｡ 

10
00:00:46,420 --> 00:00:48,870
例えば､ 合計金額のフィールドを考えてみましょう｡ 

11
00:00:48,880 --> 00:00:52,090
注文金額の分布が知りたいかもしれない｡ 

12
00:00:52,450 --> 00:01:05,470
ヒストグラム集計を利用することで､ 例えば25という間隔を指定することができ､ この場合､ Elasticsearchはフィールドの最小値と最大値の間の間隔の各ステップについて動的にバケットを作成します｡

13
00:01:05,860 --> 00:01:09,820
分かりにくかったようで申し訳ないので､ 例を挙げてみましょう｡ 

14
00:01:09,910 --> 00:01:20,080
仮に､ 金額が0～100の注文があり､ 区間を25に設定した可能性のある各値の文書があるとします｡

15
00:01:20,110 --> 00:01:23,200
Elasticsearchは5つのバケットを作成してくれます｡ 

16
00:01:23,290 --> 00:01:28,870
キーゼロの25､ 50､ 75､ 100のバケツ｡ 

17
00:01:29,380 --> 00:01:35,230
このバケツに文書が入りますが､ どのバケツに文書が入るかは､ 何が決めるのでしょうか？

18
00:01:35,410 --> 00:01:42,340
アンダースコア量フィールドの合計が各文書について評価され､ その値は最も近いバケットに切り捨てられる｡

19
00:01:42,520 --> 00:01:50,530
つまり､ 金額が60の文書があれば､ この数字は50に切り捨てられ､ 50のキーを持つバケツに入れられる｡

20
00:01:50,890 --> 00:01:55,810
これで理解していただけたと思いますが､ 先ほどの例を書くと､ ヒストグラムがどういうものなのか､

21
00:01:55,810 --> 00:01:58,810
より理解しやすくなります｡

22
00:01:59,320 --> 00:02:08,260
そこで､ 金額という名前の集計を追加し､ アンダースコア分布､ タイプをヒストグラムに設定してみましょう｡ 

23
00:02:08,890 --> 00:02:14,050
フィールドはtotal amounts､ 間隔は25になります｡ 

24
00:02:14,620 --> 00:02:16,060
さっそく実行してみましょう｡ 

25
00:02:17,950 --> 00:02:19,220
結果を見てみると

26
00:02:19,240 --> 00:02:22,810
25の間隔にバケツを置いていることに注目してください｡ 

27
00:02:22,960 --> 00:02:27,430
バケットをゼロにして､ 275までずっと｡ 

28
00:02:27,820 --> 00:02:39,970
バケツは最大値が281なのでそこで止まり､ そのドキュメントはその後､ 値が切り捨てられるので275のキーを持つバケツに落ちます｡

29
00:02:40,300 --> 00:02:49,840
これで､ デフォルトでは､ バケットに該当する文書があるかどうかにかかわらず､ フィールドの最小値と最大値の間の各間隔に対してバケットが作成されるようになりました｡

30
00:02:50,140 --> 00:02:54,220
そのため､ 文書数がゼロのバケットを目にすることがあるかもしれません｡ 

31
00:02:54,640 --> 00:03:00,430
テストデータ内の値はかなり均等に分布しており､ ドキュメントに何らフィルターをかけていないため､

32
00:03:00,430 --> 00:03:02,980
このような結果は見られません｡

33
00:03:03,160 --> 00:03:07,150
しかし､ そうでない場合､ バケツが空っぽになることがあります｡ 

34
00:03:07,420 --> 00:03:13,180
それが嫌なら､ min underscore doc underscore countsという便利なパラメータがある｡ 

35
00:03:13,510 --> 00:03:20,290
このパラメータは､ あるバケツに何件の文書が含まれるかを設定するためのものである｡

36
00:03:20,710 --> 00:03:26,720
つまり､ 単純に1という値を指定することで､ 結果内に空のバケットが返されないようにすることができるのです｡

37
00:03:26,740 --> 00:03:28,480
もちろん､ それが望みならね｡ 

38
00:03:28,840 --> 00:03:30,400
だから､ それをやってみよう｡ 

39
00:03:31,090 --> 00:03:35,050
だから､ min dotはカウントされるので､ 1にしておきます｡ 

40
00:03:36,380 --> 00:03:41,890
先ほど言ったように､ これは現在のクエリでは何の変化もありませんが､ 今度は別のものをお見せしたいと思います｡

41
00:03:41,900 --> 00:03:49,610
そのためには､ ドキュメントを少しフィルタリングする必要があるので､ 合計金額フィールドが少なくとも100の注文にのみマッチするクエリを追加してみます｡

42
00:03:49,970 --> 00:03:52,640
だから､ ここの集計の上でそうします｡ 

43
00:03:52,640 --> 00:03:53,630
だからクエリ｡ 

44
00:03:54,710 --> 00:03:58,250
そして､ 合計金額のフィールドをクエリでアレンジします｡ 

45
00:03:59,770 --> 00:04:02,320
かつ100以上であること｡ 

46
00:04:02,960 --> 00:04:04,360
よし､ 実行してみよう｡ 

47
00:04:05,920 --> 00:04:09,110
そして今､ 最初のバケツのキーが100であることが確認できます｡ 

48
00:04:09,130 --> 00:04:11,800
そこで､ 手持ちのバケツを取り外したところです｡ 

49
00:04:12,040 --> 00:04:17,650
ヒストグラム集計では､ 総量フィールドの値が100より小さい文書については何もわからないため､

50
00:04:17,650 --> 00:04:21,490
これらのバケットはもう結果の一部ではありません｡

51
00:04:22,060 --> 00:04:28,870
集計は､ 集計が実行されるコンテキスト内に存在する文書に基づくバケットを含む｡

52
00:04:29,080 --> 00:04:35,890
しかし､ 100以下のバケツに文書が含まれていなくても､ 結果の一部にしたいとしたらどうでしょう｡

53
00:04:35,980 --> 00:04:41,050
あるいは､ バケットに集約コンテキストに基づく文書が含まれるかどうかはわからない｡ おそらく､

54
00:04:41,050 --> 00:04:48,330
バケットが境界内に存在することを強制するために､ 前もってどの文書がメッシュ化されているかはわからないからだ｡

55
00:04:48,340 --> 00:04:51,910
extended underscore boundsというパラメータを使えばいい｡ 

56
00:04:52,150 --> 00:04:56,320
このパラメータは､ mean と max のキーを持つオブジェクトを含む必要がある｡ 

57
00:04:56,350 --> 00:05:02,290
そのオブジェクトを追加して､ 最小値と最大値としてそれぞれ0と500を指定してみましょう｡ 

58
00:05:02,590 --> 00:05:06,550
それではここで､ ヒストグラムオブジェクトに別のパラメータを追加してみましょう｡ 

59
00:05:06,820 --> 00:05:08,500
だからそれを伸ばす｡ 

60
00:05:08,530 --> 00:05:10,060
アンダースコア・バウンド

61
00:05:10,690 --> 00:05:18,760
資産のようなオブジェクトで､ 最小キーが0､ 最大値が500であること｡ 

62
00:05:19,090 --> 00:05:20,260
走らせてみよう｡ 

63
00:05:21,730 --> 00:05:27,490
これは､ 指定された間隔に従って､ 0から500までのバケットが作成されることを意味します｡ 

64
00:05:27,520 --> 00:05:34,060
平均暗数パラメータと比較して､ それらのバケットに該当する文書があるかどうかにかかわらず､ 拡張境界パラメータは､

65
00:05:34,090 --> 00:05:40,900
バケットの境界を拡張し､ 少なくとも設定された境界を強制する方法である｡

66
00:05:41,320 --> 00:05:43,090
では､ その結果を見てみましょう｡ 

67
00:05:43,150 --> 00:05:45,530
私たちは特に違いを感じていません｡ 

68
00:05:45,550 --> 00:05:51,310
これは､ mint doc count パラメータを 1 に設定しているため､ バケットがフィルタリングされるからです｡

69
00:05:51,490 --> 00:05:56,170
このパラメータをゼロにしてみると､ バケットが表示されるようになります｡ 

70
00:05:58,920 --> 00:06:00,060
そして､ もう一度実行してみましょう｡ 

71
00:06:02,590 --> 00:06:11,470
そして案の定､ 100より低い値を持つバケツが多数ある一方で､ 最高額である281より高い値を持つバケツも確認されました｡

72
00:06:12,750 --> 00:06:15,360
ヒストグラムの集計と非常によく似ています｡ 

73
00:06:15,360 --> 00:06:18,420
日付アンダースコアのヒストグラム集計があります｡ 

74
00:06:18,450 --> 00:06:23,730
日付の値だけで同じことができるのは､ おそらく驚くに値しないでしょう｡ 

75
00:06:23,820 --> 00:06:30,690
機能はほとんど同じですが､ 主な違いはintervalパラメータに式を使用することです｡

76
00:06:30,750 --> 00:06:39,690
具体的には､ 年､ 四半期､ 月､ 週､ 日､ 分､ 秒のいずれかの値を選択することができる｡

77
00:06:40,110 --> 00:06:44,610
各月の注文数を表示する日付ヒストグラムの例を書いてみましょう｡ 

78
00:06:44,880 --> 00:06:47,940
そこで､ 既存のクエリのコピーを作ってみることにします｡ 

79
00:06:51,700 --> 00:06:52,110
そうですね｡ 

80
00:06:52,110 --> 00:06:57,480
クエリをなくして､ 集計だけにしてみましょう｡ 

81
00:06:58,800 --> 00:07:06,180
その順序を時間軸で名付け､ 日付ヒストグラム型を使うことにします｡ 

82
00:07:06,390 --> 00:07:12,270
このパラメータを取り除き､ フィールドとインターバルのみを残して､

83
00:07:12,270 --> 00:07:17,530
フィールドは購入した広告､ インターバルは月とします｡

84
00:07:21,420 --> 00:07:25,390
文書がどのバケツに属するかの判断も同じルールで行われます｡ 

85
00:07:25,410 --> 00:07:30,840
結果のヒストグラム集計スコアリングと同様に､ 必要であれば各月のバケットを持つようになったことがわかりますので､

86
00:07:30,840 --> 00:07:37,800
formatsというパラメータに日付フォーマットを指定してキーフォーマットをカスタマイズすることができます｡

87
00:07:38,100 --> 00:07:47,220
最後になりましたが､ 万が一に備えて､ ヒストグラムとデータアンダースコアヒストグラムの両方の集計がオフセットパラメータをサポートしていることをお伝えしておきます｡

88
00:07:47,400 --> 00:07:53,570
このオフセットは､ ヒストグラムの集計のために､ 各バケツのキーから加算または減算したい場合に便利で､

89
00:07:53,580 --> 00:08:01,320
日付ヒストグラムの集計のためには､ 例えば1Dのような日付の数式を指定することになるでしょう｡
