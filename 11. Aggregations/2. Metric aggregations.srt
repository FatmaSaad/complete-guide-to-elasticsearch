1
00:00:02,270 --> 00:00:05,510
これで､ 最初のアグリゲーションを書き始める準備ができました｡ 

2
00:00:05,510 --> 00:00:12,950
まず､ 最も単純なものであるため､ メトリックアグリゲーションと呼ばれるアグリゲーションのグループから見ていくことにする｡

3
00:00:13,580 --> 00:00:19,580
実際､ リレーショナル・データベースに慣れている人なら､ そのほとんどに見覚えがあるのではないだろうか｡

4
00:00:20,210 --> 00:00:24,920
この集合体のグループは､ 2つのサブグループまたはカテゴリーに分けられる｡ 

5
00:00:25,070 --> 00:00:31,640
さて､ これらの名称を説明する前に､ ちょっとだけ､ 超高級な専門用語を覚悟しておいてください｡

6
00:00:31,670 --> 00:00:32,510
準備はいいですか？

7
00:00:33,020 --> 00:00:39,830
これらは､ 中心値数値メトリックス集計と多値数値メトリックス集計と呼ばれる｡ 

8
00:00:39,860 --> 00:00:41,720
かなり派手な感じでしょう？

9
00:00:42,170 --> 00:00:45,470
ご心配なく｡ 複雑なことは何もありません｡ 

10
00:00:46,040 --> 00:00:52,820
単一値集約は､ 単に数値の合計や平均値などの単一値を出力するものである｡

11
00:00:53,240 --> 00:00:59,060
当然のことながら､ 多値集約は単一の値だけでなく､ 複数の値を得ることができる｡ 

12
00:00:59,480 --> 00:01:03,070
この講義では､ 両方の種類の集計の例を見ていただきます｡ 

13
00:01:03,080 --> 00:01:04,460
では､ さっそく始めましょう｡ 

14
00:01:05,120 --> 00:01:10,070
まず､ 最も単純な集計である「和の集計」から始めましょう｡ 

15
00:01:10,310 --> 00:01:15,260
これは､ 与えられた数値フィールドを複数の文書について取り込み､ 数値を合計するだけである｡ 

16
00:01:15,530 --> 00:01:19,130
では､ 集計に使われるのはどの文書なのか､ 疑問に思うかもしれない｡ 

17
00:01:19,550 --> 00:01:24,550
まず始めに､ 検索クエリの結果を使って､ クエリオブジェクトの中を検索してみます｡ 

18
00:01:24,560 --> 00:01:27,710
このコースで見てきたような検索クエリですね｡ 

19
00:01:28,010 --> 00:01:33,470
とはいえ､ 全文書を集約するだけなら､ 明示的にクエリを追加する必要はない｡ 

20
00:01:34,130 --> 00:01:41,630
必要であれば､ match all クエリを定義することもできますが､ クエリオブジェクトを完全に省くこともできます｡

21
00:01:42,110 --> 00:01:48,140
そこで､ 以下のクエリでは､ オーダーインデックス内のすべてのドキュメントを集計に使用することにします｡ 

22
00:01:48,710 --> 00:01:54,230
もし､ 総量が50以下の文書だけを使いたい場合は､ 範囲指定クエリを追加すれば､

23
00:01:54,230 --> 00:01:58,190
このクエリにマッチしたものが集計に使われることになる｡

24
00:01:58,820 --> 00:02:00,200
ともあれ､ 話は尽きない｡ 

25
00:02:00,200 --> 00:02:02,840
では､ 集約を含むクエリを書いてみましょう｡ 

26
00:02:03,430 --> 00:02:10,600
というわけで､ ギフトと新しいオーダーインデックスデフォルト､ 検索APIはいつも通りです｡ 

27
00:02:11,050 --> 00:02:18,910
そして､ まず最初にsizeパラメータをゼロに設定します｡ なぜなら､ 私たちは集計にしか興味がなく､ クエリの結果には興味がないからです｡

28
00:02:19,180 --> 00:02:25,390
クエリオブジェクトを省略することで､ 暗黙のうちにすべてのドキュメントをマッチングしているので､ クエリオブジェクトを追加する必要がないことを覚えておいてほしい｡

29
00:02:25,930 --> 00:02:29,530
そこで､ 代わりに行うのは､ x個のオブジェクトを指定することです｡ 

30
00:02:29,560 --> 00:02:34,960
このオブジェクトは､ お好みでアグリゲーションという名前も付けられますが､ この講座ではXだけにしておきます｡ 

31
00:02:36,080 --> 00:02:39,560
そこで､ やりたいことは､ 合計金額を出すことです｡ 

32
00:02:39,740 --> 00:02:43,220
だから､ 私たちが手にするのは総売上高です｡ 

33
00:02:43,400 --> 00:02:45,500
そして､ これはあくまで集合体の名称である｡ 

34
00:02:45,500 --> 00:02:48,400
だから､ これは私が定義した任意の名前に過ぎないのです｡ 

35
00:02:48,410 --> 00:02:50,180
だから､ 何でもいいんです｡ 

36
00:02:50,910 --> 00:02:53,640
そして､ ここではアグリゲーションタイプを入力する必要があります｡ 

37
00:02:53,790 --> 00:02:58,440
数値の合計を出すので､ それなりになりますね｡ 

38
00:02:59,370 --> 00:03:04,200
そして､ このオブジェクトの中で､ パラメータを指定することで､ 合計の集計を設定することができます｡ 

39
00:03:04,680 --> 00:03:10,440
この場合､ 私がすべきことは､ 集約したいフィールドの名前を含むフィールド・パラメータを追加することだ｡

40
00:03:10,860 --> 00:03:13,740
この場合､ それは総量になりますね｡ 

41
00:03:14,430 --> 00:03:17,100
クエリを実行して､ どのようなレスポンスが返ってくるか見てみましょう｡ 

42
00:03:18,330 --> 00:03:25,710
ご覧のように､ クエリ内で指定した集約を持つオブジェクトを含むaggregationsというキーができました｡

43
00:03:26,190 --> 00:03:30,510
また､ sumの集計がaccordingというフィールドの中にネストされていることに注目してください｡ 

44
00:03:30,510 --> 00:03:35,580
この例では､ クエリの合計アンダースコアの売上高の中で指定した名前ですね｡ 

45
00:03:35,610 --> 00:03:36,870
簡単でしょう？

46
00:03:37,570 --> 00:03:46,630
エラーという単語のAvg shotというクエリに移りましょう｡ 想像できると思いますが､ これは与えられたフィールドの平均値を計算するものです｡

47
00:03:46,780 --> 00:03:48,790
アンダースコアの合計金額フィールドを使ってみます｡ 

48
00:03:48,790 --> 00:03:56,200
この集約のために全く新しいクエリを追加することもできますが､ ここでは､ 1つのクエリに複数の集約を簡単に追加する方法を紹介したいと思います｡

49
00:03:56,230 --> 00:03:59,920
それに､ 全文書の平均値も欲しい｡ 

50
00:04:00,870 --> 00:04:08,030
そこで､ ここに新しいアグリゲーションを追加して､ VG underscore saleという名前にします｡

51
00:04:08,610 --> 00:04:10,470
これもオブジェクトになります｡ 

52
00:04:10,860 --> 00:04:16,110
タイプはAVG､ フィールドはアンダースコアの合計金額となります｡ 

53
00:04:16,320 --> 00:04:21,120
クエリを実行すると､ sumの集計の他に､ 追加の集計が表示されます｡ 

54
00:04:21,510 --> 00:04:24,750
でもね､ 3つのアグリゲーションができるのに､ なぜ2つのアグリゲーションから始めるのか？

55
00:04:25,050 --> 00:04:28,770
さらにminとmaxの2つの型の集約を追加してみましょう｡ 

56
00:04:28,800 --> 00:04:33,940
これらの集約は､ 与えられたフィールドの最小値と最大値をそれぞれ返す｡ 

57
00:04:33,960 --> 00:04:36,450
つまり､ 最下位と最上位の金額です｡ 

58
00:04:37,020 --> 00:04:41,040
そこで､ 入力の手間を省くために､ これをコピーすることにします｡ 

59
00:04:41,460 --> 00:04:48,630
最初のものはmin underscore saleと名付け､ min sort for minimumという型に設定します｡ 

60
00:04:49,380 --> 00:04:51,960
フィールドはやはり総量になる｡ 

61
00:04:52,530 --> 00:04:57,090
次に､ この下に新しいアグリゲーションを貼り付けて､ 同じことをします｡ 

62
00:04:57,360 --> 00:05:02,700
つまり､ Maxアンダースコアの販売タイプはMaxで､ また､ 合計金額のフィールドです｡ 

63
00:05:04,620 --> 00:05:09,390
そして案の定､ 結果には最低額と最高額の注文が返されることが確認された｡ 

64
00:05:10,050 --> 00:05:12,390
さて､ これは手に負えなくなりつつあるのでは？

65
00:05:12,420 --> 00:05:14,580
1つのクエリで4つのアグリゲーションが可能です｡ 

66
00:05:14,760 --> 00:05:16,440
何も問題はないのです｡ 

67
00:05:16,440 --> 00:05:18,450
また､ 必要であればさらに追加することも可能です｡ 

68
00:05:18,600 --> 00:05:21,930
しかし､ すべてをきれいに短くして､ 新しいクエリーを書きましょう｡ 

69
00:05:22,440 --> 00:05:26,490
既存のqueryとmtgのアグリゲーションオブジェクトのコピーを作るだけです｡ 

70
00:05:29,300 --> 00:05:31,430
スペースを追加してみよう｡ 

71
00:05:32,230 --> 00:05:35,630
そして､ このように全部処分してしまうのです｡ 

72
00:05:36,410 --> 00:05:39,710
次に紹介するのは､ Cardinalityという名前のアグリゲーションです｡ 

73
00:05:39,740 --> 00:05:44,270
これは､ 基本的に､ あるフィールドの異なる値の数を数えるものです｡ 

74
00:05:44,480 --> 00:05:50,120
この集計を利用して､ ある注文に関連するセールスマンの人数を調べてみましょう｡ セールスマンオブジェクトのIDフィールドを使い､

75
00:05:50,120 --> 00:05:54,770
フィールドパスを指定します｡

76
00:05:55,310 --> 00:05:58,010
というわけで､ わかりにくいと思われた方は､ タイプしてみましょう｡ 

77
00:05:58,580 --> 00:06:06,220
つまり､ 集計の名前は､ いつものようにオブジェクトであるトータル・アンダースコア・セールスマンになります｡ 

78
00:06:06,230 --> 00:06:09,470
そして､ 集約のタイプはcardinalityになる予定です｡ 

79
00:06:09,950 --> 00:06:13,460
そして､ フィールドはセールスマンかIDになります｡ 

80
00:06:13,880 --> 00:06:16,670
つまり､ IDフィールドが集計対象なのです｡ 

81
00:06:17,150 --> 00:06:18,110
そして､ それだけです｡ 

82
00:06:18,140 --> 00:06:19,100
走らせてみよう｡ 

83
00:06:20,230 --> 00:06:24,910
その結果､ インデックス内のすべてのオーダーに対して､ 100人の異なるセールスマンが存在することがわかった｡ 

84
00:06:25,390 --> 00:06:30,760
重要なことは､ カーディナリティの集計はおおよその数値を出すということである｡ 

85
00:06:31,210 --> 00:06:40,210
この説明は非常に専門的になりますが､ 基本的には､ 正確な数値を出すとクラスタのリソースを多く消費してしまうということに尽きると思います｡

86
00:06:40,720 --> 00:06:45,340
そこで､ できるだけ正確に数字を出そうとするアルゴリズムが使われています｡ 

87
00:06:45,670 --> 00:06:50,320
Elasticsearchはかなり良くできているので､ 一般的にかなり正確な結果が得られるでしょう｡ 

88
00:06:50,470 --> 00:06:53,890
しかし､ 精度の高い数値が必要な場合は､ この点に留意する必要があります｡ 

89
00:06:54,280 --> 00:07:02,050
もしこれが重要であれば､ 精度を制御して性能を犠牲にすることもできます｡ その場合は､ ドキュメントをチェックすることをお勧めします｡

90
00:07:02,560 --> 00:07:07,450
とにかく､ 次の集計に移りましょう｡ これは､ スコアカウントに値という名前をつけたものです｡ 

91
00:07:07,750 --> 00:07:11,770
この集計は､ 集計の基となる値の数を数えるものである｡ 

92
00:07:12,280 --> 00:07:14,980
集計にはアンダースコア金額の合計フィールドを使うことにします｡ 

93
00:07:14,980 --> 00:07:21,250
つまり､ この例では､ インデックス内に1000の文書があり､ match allクエリが暗黙のうちに使用されているため､

94
00:07:21,250 --> 00:07:23,230
数字は1000となるのです｡

95
00:07:23,560 --> 00:07:25,570
でもとにかく､ 実際に見てみましょう｡ 

96
00:07:26,080 --> 00:07:31,960
そこで､ このクエリをコピーして､ 貼り付け､ スペースを追加します｡ 

97
00:07:34,100 --> 00:07:35,870
そして､ これを解消する｡ 

98
00:07:37,230 --> 00:07:39,750
そして､ スコアカウントの集計上の値を追加する｡ 

99
00:07:39,750 --> 00:07:42,300
これは名前であって､ 型ではないことを忘れないでください｡ 

100
00:07:42,630 --> 00:07:49,830
そして､ ここでは値の種類をアンダースコアのcountsに､ フィールドをアンダースコアのtotal amountsにすることにします｡

101
00:07:50,700 --> 00:07:51,630
走らせてみよう｡ 

102
00:07:52,550 --> 00:07:55,130
そして､ その結果は確かに1000を指定している｡ 

103
00:07:55,490 --> 00:08:01,670
つまり､ アンダースコア・アカウント・アグリゲーションは､ アグリゲーションが作業に使用した値の数を示しているのだ｡

104
00:08:02,000 --> 00:08:05,710
これは､ 他のアグリゲーションと組み合わせて使用すると便利なことが多いでしょう｡ 

105
00:08:05,720 --> 00:08:11,450
例えば､ AVG集計で平均注文金額を計算する場合､ その平均値が何件の注文に基づいているかを知るために､

106
00:08:11,450 --> 00:08:16,520
value underscore count集計を使用したい場合があります｡

107
00:08:17,240 --> 00:08:25,280
これは､ match all以外のクエリを使用する場合に特に有効で､ マッチの数が予測しにくくなるためです｡

108
00:08:25,700 --> 00:08:33,890
時には､ 複数の集約を指定するのではなく､ 同じフィールドに対して複数の集約を同時に使用する必要があるかもしれません｡

109
00:08:33,920 --> 00:08:38,600
Elasticsearchはstatsという便利な複数値のアグリゲーションを提供しています｡ 

110
00:08:39,200 --> 00:08:46,310
この集計は､ min max､ いくつかのavgおよびvalue count集計によって返される数値を計算する｡ 

111
00:08:46,640 --> 00:08:51,440
この集計を合計金額のフィールドに使って､ 結果がどのようになるか見てみましょう｡ 

112
00:08:51,980 --> 00:08:56,030
では､ もう一度､ クエリのコピーを貼り付けてみましょう｡ 

113
00:08:56,900 --> 00:08:59,120
すでに持っているものを処分する｡ 

114
00:09:00,070 --> 00:09:11,260
スコア統計にその金額の名前を付けるには､ いつも通り統計の種類と合計金額のフィールドを指定します｡ 

115
00:09:12,260 --> 00:09:13,400
そして実行する｡ 

116
00:09:14,470 --> 00:09:19,690
結果内にあるように､ 統計の集計では､ 以前見たのと同じ数字が返されます｡

117
00:09:19,690 --> 00:09:21,970
つまり､ あくまで便宜的な集計なんですね｡ 

118
00:09:22,790 --> 00:09:26,090
そして､ それが最後にお見せしたいメトリック・リグレッションでした｡ 

119
00:09:26,210 --> 00:09:30,620
他にもいくつかありますが､ これらは最も重要なもので､ 通常必要となるものです｡

120
00:09:30,620 --> 00:09:37,620
もし､ 非常に特殊なものが必要な場合や､ 単に興味がある場合は､ 必ずドキュメントをチェックしてください｡

121
00:09:37,640 --> 00:09:39,980
この講義に添付されているリンクをご覧ください｡ 
