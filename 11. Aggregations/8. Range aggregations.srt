1
00:00:01,170 --> 00:00:07,200
バケツに入れるべき文書を指定するもう一つの方法は､ 範囲集約を使うことである｡ 

2
00:00:07,380 --> 00:00:12,750
スコア範囲に名前付き範囲と名前付き日付の2つの範囲集計があります｡ 

3
00:00:13,110 --> 00:00:18,990
日付範囲集計が日付の値を扱うことに特化していることを除けば､ 基本的に同じである｡

4
00:00:19,170 --> 00:00:25,120
どちらも､ 範囲を定義して､ それぞれの範囲がドキュメントのバケットを表すという方法で動作します｡ 

5
00:00:25,140 --> 00:00:30,270
次に､ 文書を適切なバケツに入れるためにどのフィルターを使うかを指定する｡ 

6
00:00:30,870 --> 00:00:36,330
まずは範囲集計からですが､ これは講座の前半で見た範囲クエリに似ていますね｡

7
00:00:36,750 --> 00:00:39,990
おそらく､ 注文金額がどのように配分されているかを知りたいのでしょう｡ 

8
00:00:40,020 --> 00:00:48,810
具体的には､ 0～50個､ 50～100個､ 100個以上のオーダーは何個あるのか？

9
00:00:48,930 --> 00:00:51,510
それを実現する範囲集計を書いてみましょう｡ 

10
00:00:52,180 --> 00:00:59,800
そこで､ amount､ underscore distributionという名前をつけて､ typeをrangeに設定します｡ 

11
00:01:00,490 --> 00:01:10,510
フィールドはアンダースコアの合計金額となり､ このパラメータには配列が含まれるため､ rangesパラメータ内ではオブジェクトとして範囲を定義することができます｡

12
00:01:11,290 --> 00:01:15,060
まず気になるのは､ 0から50までの範囲です｡ 

13
00:01:15,070 --> 00:01:22,090
そこで､ このオブジェクトのfromキーを削除して､ 2つのキーを50に変更します｡ 

14
00:01:22,600 --> 00:01:26,350
なお､ 1つ目のキーは含まれ､ 2つ目のキーは除外されています｡ 

15
00:01:27,250 --> 00:01:36,580
そこで､ もう一つの範囲として､ keyから50までとkeyから100までの2つを設定したオブジェクトを追加してみましょう｡ 

16
00:01:38,020 --> 00:01:43,240
そして､ 最後の範囲には､ 値が100のファームキーが含まれるだけです｡ 

17
00:01:43,420 --> 00:01:49,450
つまり､ アンダースコアの合計金額のフィールドの値が100を超える文書は､ このバケツに入れられることになる｡

18
00:01:50,170 --> 00:01:52,450
では､ このクエリを実行してみましょう｡ 

19
00:01:52,960 --> 00:01:57,100
そのため､ 結果には指定した範囲ごとにバケツが含まれています｡ 

20
00:01:57,580 --> 00:02:07,270
各バケットには､ 他のバケット集計と同様に文書数が含まれるが､ そのバケット内に文書を配置するために使用されるfromとsoの値も含まれる｡

21
00:02:07,750 --> 00:02:13,060
最後に､ キーが含まれるが､ これはデフォルトでは単なる範囲のテキスト表現である｡ 

22
00:02:13,090 --> 00:02:17,500
これを変更することができますので､ 日付範囲の集計を見た後に紹介します｡ 

23
00:02:17,980 --> 00:02:24,010
つまり､ 日付のアンダースコアの範囲集計は､ 日付で動作することを除けば､ 概念的には同じことなのです｡

24
00:02:24,310 --> 00:02:31,090
したがって､ この集約によって､ コースの前半で見たような､ 日付マップの使用など､ 日付を特定したことができるようになります｡

25
00:02:31,690 --> 00:02:34,750
その仕組みは､ 先ほど見たものとまったく同じです｡ 

26
00:02:34,870 --> 00:02:41,230
また､ 単純に日付を指定することもできますが､ より面白くするために､ 日付の計算を少ししてみましょう｡

27
00:02:41,710 --> 00:02:48,940
やりたいことは､ 2016年の前半と後半の2つのバケットを作ることです｡

28
00:02:49,450 --> 00:02:52,840
そのために､ 購入したアンダースコアの追加フィールドを活用することにします｡ 

29
00:02:53,290 --> 00:03:00,310
そこで､ この既存のクエリをコピーして､ すでにあったこれらの範囲を取り除くことにします｡ 

30
00:03:02,310 --> 00:03:10,530
それから､ 集計の名前をスコア範囲で購入済みに変更して､ フィールドはスコア×で購入済みにし､

31
00:03:10,530 --> 00:03:17,400
集計タイプもスコア範囲で日付に変更する必要がありますね｡

32
00:03:18,310 --> 00:03:22,510
そのため､ rangesパラメータ内のオブジェクトもfromとturkeyを含む必要があります｡ 

33
00:03:22,510 --> 00:03:25,720
だからそこに違いはないが､ 数値は違うはずだ｡ 

34
00:03:26,170 --> 00:03:29,050
だから､ 2016年1月1日｡ 

35
00:03:29,770 --> 00:03:36,430
それから､ 2つのキーについては､ 日付の計算を使うので､ 上と同じ日付を取ることにします｡ 

36
00:03:36,730 --> 00:03:37,390
おっとっと｡ 

37
00:03:37,390 --> 00:03:39,970
2016 0101.

38
00:03:41,050 --> 00:03:47,140
そして､ 日付計算で2本のパイプを足して､ 半年分のプラス6mと書きます｡ 

39
00:03:47,650 --> 00:03:49,050
これがひとつのレンジなんですね｡ 

40
00:03:49,060 --> 00:03:51,190
では､ もう1つのほうに取りかかりましょう｡ 

41
00:03:52,300 --> 00:03:53,020
からです｡ 

42
00:03:53,170 --> 00:03:58,810
そして､ このキーには､ この日付マップ式を使うことができます｡ 

43
00:03:58,810 --> 00:04:01,900
そこで､ 2つのキーも追加してみましょう｡ 

44
00:04:02,350 --> 00:04:04,810
だから2016年ゼロイチ｡ 

45
00:04:04,810 --> 00:04:09,160
つまり､ 1月1日に2本のパイプに1年を加えたものです｡ 

46
00:04:09,850 --> 00:04:12,280
クエリを実行して､ 結果を見てみましょう｡ 

47
00:04:13,550 --> 00:04:21,680
エポックバックが一瞬で読みやすいキーに変更するので､ テキスト表現とミリ秒数の両方を得ることができます｡

48
00:04:21,680 --> 00:04:27,260
しかし､ まず最初に文字列からと文字列への値に注目してほしい｡ 

49
00:04:27,590 --> 00:04:34,010
最初のポケットの2つの文字列キーの値が､ 2016年7月1日であることに注目してください｡ 

50
00:04:34,730 --> 00:04:40,190
その代わりに6月30日になるはずではなかったのか､ 日付計算をするときに間違えたのかと思われるかもしれませんが､

51
00:04:40,190 --> 00:04:44,210
実はこの値は正しいのです｡

52
00:04:44,240 --> 00:04:48,680
異なる価値は含まれ､ 期間価値は除外されることを忘れないでください｡ 

53
00:04:48,710 --> 00:04:51,770
これは､ 日付範囲集計の場合も同様である｡ 

54
00:04:51,770 --> 00:04:59,540
そこで､ 基本的に最初のバケツの日付は2016年7月1日の午前0時以前であることを指定しました｡

55
00:04:59,750 --> 00:05:01,580
だから､ 日付は正しいのです｡ 

56
00:05:01,970 --> 00:05:05,480
もし､ 2つの価値が含まれていたら､ 話は別です｡ 

57
00:05:06,130 --> 00:05:11,270
なるほど､ フレームなどの値のテクスチャ表現は､ あまりきれいではありませんね｡ 

58
00:05:11,660 --> 00:05:19,160
アプリケーションで日付を渡すためにフィールドを使用する場合は問題ありませんが､ 時刻と一緒に日付を返したいだけかもしれません｡

59
00:05:19,250 --> 00:05:22,860
あるいは､ 日付を別のフォーマットで返したいだけかもしれません｡ 

60
00:05:22,880 --> 00:05:27,620
日付範囲の集計にformatパラメータを追加することで指定することができる｡ 

61
00:05:27,860 --> 00:05:31,400
では､ それをフィールド・パラメーターの下にやってみましょう｡ 

62
00:05:31,970 --> 00:05:34,280
さっき言ったように､ formatパラメータを追加します｡ 

63
00:05:34,670 --> 00:05:37,490
そして､ ここでは､ 日付のフォーマットを指定することができます｡ 

64
00:05:38,090 --> 00:05:43,700
まず年､ 次に月､ そして日が欲しいので､ これを廃止します｡ 

65
00:05:44,500 --> 00:05:51,550
クエリを更新してみましょう｡ キーと範囲のテキスト表現の両方が､ より読みやすくなっていることがわかります｡

66
00:05:52,210 --> 00:06:00,520
このフォーマットは､ アプリケーションで別のデータフォーマットを受け取る必要がある場合にのみ使用し､ エンドユーザー向けに日付をフォーマットする目的では使用しないことをお勧めします｡

67
00:06:00,550 --> 00:06:07,150
私の考えでは､ それはアプリケーションの中で行うべきことですが､ もちろん､ あなたが好むアプローチを自由に選択することができます｡

68
00:06:08,030 --> 00:06:11,990
それでは､ 各バケツに対して返されるキーをカスタマイズする方法を見てみましょう｡ 

69
00:06:12,020 --> 00:06:17,420
最初の方法は､ キー名の変更とは関係なく､ バケットの構造を変更する方法です｡ 

70
00:06:17,870 --> 00:06:22,880
試しに､ keyedという名前の新しいパラメータを値trueで追加して､ 何が起こるか見てみましょう｡ 

71
00:06:23,930 --> 00:06:24,770
だから

72
00:06:24,770 --> 00:06:27,740
キースとトゥルーで､ 走らせよう｡ 

73
00:06:28,580 --> 00:06:32,750
これで､ バケットが匿名オブジェクトではなく､ キーを持つようになったことが確認できます｡ 

74
00:06:32,900 --> 00:06:38,570
バケットオブジェクト内のキーキーは､ 代わりにオブジェクトのキーとして移動しました｡ 

75
00:06:38,840 --> 00:06:40,460
しかし､ キーの名前は同じです｡ 

76
00:06:40,460 --> 00:06:42,270
では､ どうすればそれを変えられるかを考えてみましょう｡ 

77
00:06:42,290 --> 00:06:46,340
それを単純に､ オブジェクトの各範囲にキーパラメータを追加することで実現しています｡ 

78
00:06:46,820 --> 00:06:49,310
では､ 最初の範囲についてそうしてみましょう｡ 

79
00:06:49,310 --> 00:06:49,970
最初に

80
00:06:50,480 --> 00:06:51,710
だから鍵｡ 

81
00:06:52,250 --> 00:06:53,600
まずこれを挙げる｡ 

82
00:06:53,600 --> 00:06:54,770
アンダースコア・ハーフ

83
00:06:55,580 --> 00:06:57,950
第2レンジも同じようにします｡ 

84
00:06:58,550 --> 00:07:02,480
もちろん､ 後半をキーに｡ 

85
00:07:04,880 --> 00:07:05,930
なるほど､ 素晴らしい｡ 

86
00:07:05,930 --> 00:07:09,680
でも､ 注文数を受け取るだけでは､ そんなに楽しくはない｡ 

87
00:07:10,070 --> 00:07:15,920
サブアグリゲーションとしてstatsアグリゲーションを追加して､ バケットの情報をもう少し取得してみましょう｡ 

88
00:07:16,190 --> 00:07:19,460
アンダースコアの合計金額のフィールドを統計に使ってみる｡ 

89
00:07:20,300 --> 00:07:20,570
なるほど｡ 

90
00:07:20,600 --> 00:07:23,870
では､ Xキーを追加してみましょう｡ 

91
00:07:25,520 --> 00:07:34,190
そして､ スコア統計の集計ポケットに名前を付け､ タイプを統計に､ フィールドをスコア金額の合計に設定します｡

92
00:07:35,390 --> 00:07:36,830
もちろん､ 実行も｡ 

93
00:07:37,960 --> 00:07:41,500
そして今度は､ それぞれのバケツの文脈で統計情報を得ることができます｡ 

94
00:07:41,530 --> 00:07:46,450
これは集計範囲に限ったことではなく､ 以前にも見たことがあると思いますが､

95
00:07:46,450 --> 00:07:51,820
とにかく本当にクールで強力な機能だと思うので､ もう一度紹介したいと思います｡

96
00:07:51,820 --> 00:07:54,010
以上､ レンジアグリゲーションの使い方でした｡ 
