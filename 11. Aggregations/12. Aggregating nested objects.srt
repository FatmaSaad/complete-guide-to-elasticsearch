1
00:00:02,290 --> 00:00:07,040
ネストされたデータ型にマッピングされたフィールドを照会するために使用するネストされたクエリを覚えていますか？

2
00:00:07,060 --> 00:00:13,600
それと同じように､ ネストした集計があったり､ 先ほどの部門別インデックスを再利用しているのは､

3
00:00:13,600 --> 00:00:18,490
すべての部門の従業員の中で一番低い年齢を探したいからです｡

4
00:00:18,490 --> 00:00:21,910
そのために､ 平均値の集計を利用することができる｡ 

5
00:00:22,150 --> 00:00:24,460
あらかじめ用意しておいたクエリーを考える｡ 

6
00:00:24,460 --> 00:00:26,950
それでいいのかと思われるかもしれませんが､ 実行してみましょう｡ 

7
00:00:29,070 --> 00:00:33,600
集計の結果､ 明らかに不正確なnullが生成されることに注意してください｡ 

8
00:00:33,720 --> 00:00:39,960
ネスト令と同様に､ ネストされたフィールドについても､ アグリゲーションに関して少し異なる取り扱いをする必要があります｡ 

9
00:00:40,050 --> 00:00:46,440
具体的には､ 入れ子状になった文書を集約することができる入れ子集約を利用する必要がある｡ 

10
00:00:46,860 --> 00:00:51,060
ネストされたクエリと同様に､ ネストされたオブジェクトのパスを指定する必要があります｡ 

11
00:00:51,980 --> 00:00:57,950
よし､ ではこの既存の集計を取り除き､ 新しい集計を追加してみましょう｡ 

12
00:00:57,950 --> 00:00:59,900
社員と名付ける｡ 

13
00:01:02,070 --> 00:01:03,960
しかも入れ子型｡ 

14
00:01:04,380 --> 00:01:09,410
つまり､ 先ほど見たように､ ネストされたクエリで､ オブジェクトへのパスが指定されています｡ 

15
00:01:09,420 --> 00:01:14,550
この場合､ オブジェクトの配列なので､ employeesになりますね｡ 

16
00:01:14,940 --> 00:01:23,850
15個の従業員オブジェクトを含む15個のドキュメントを含むバケットを取得することができます｡

17
00:01:24,090 --> 00:01:29,780
クエリと一致するものを指定しなかったため､ 両方の部門の社員がバケツに入れられました｡ 

18
00:01:29,790 --> 00:01:32,010
したがって､ すべてのクエリーは暗黙のうちに使用される｡ 

19
00:01:32,520 --> 00:01:36,900
このバケットを､ 今まで見てきたようなアグリゲーションと一緒に使うことができるようになりました｡ 

20
00:01:37,170 --> 00:01:43,080
特に､ 15人の従業員の中で最も年齢の低い人を見つけるために､ 主な集計を行いたいと思います｡ 

21
00:01:43,080 --> 00:01:46,290
それをサブアグリゲーションとして指定することで､ 実現しています｡ 

22
00:01:46,930 --> 00:01:55,930
ここでexキーにminimumという集約を追加してみましょう｡ hはmin型のメトリック集約で､

23
00:01:55,930 --> 00:02:07,510
フィールドは従業員､ hはネストされたクエリと同様に､ このクエリを実行しているオブジェクトへのパスを含むことが重要です｡

24
00:02:07,510 --> 00:02:10,750
最年少の社員は19歳であることがわかります｡ 

25
00:02:11,480 --> 00:02:15,860
そして､ これがネストされた集計とネストされたフィールド型の組み合わせの使い方です｡ 
