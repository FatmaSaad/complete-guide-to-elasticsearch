1
00:00:01,130 --> 00:00:07,820
先ほど､ Elasticsearchのアグリゲーションは非常に強力で､ 超クールなことができると述べました｡

2
00:00:08,060 --> 00:00:13,610
そろそろ謎を解き明かし､ Elasticsearchが持つトリックの数々をお見せしましょう｡ 

3
00:00:14,210 --> 00:00:17,780
今､ 棲み分けという言葉が出てきましたが､ これは完全な集合体です｡ 

4
00:00:17,870 --> 00:00:23,570
ご存知のように､ バケットアグリゲーションは､ バケットというドキュメントの集合の中にドキュメントを配置します｡ 

5
00:00:24,200 --> 00:00:30,140
これは､ 文書群の文書数を取得すること以外には､ それ自体あまり有用ではない｡ 

6
00:00:30,170 --> 00:00:38,690
しかし､ バケットアグリゲーションが素晴らしいのは､ サブアグリゲーションと呼ばれるネストしたアグリゲーションを持つことができる点です｡

7
00:00:39,380 --> 00:00:44,410
これは､ これまでとまったく同じように､ Xキーまたは集約キーを使用することで可能です｡ 

8
00:00:44,420 --> 00:00:46,640
つまり､ これは再帰的なものなんですね｡ 

9
00:00:47,060 --> 00:00:50,700
これは､ 単に値を生成するメトリクスのアグリゲーションとは異なります｡ 

10
00:00:50,720 --> 00:00:57,260
しかし､ バケット集計は文書のバケットを生成するので､ そのバケットを他の集計に利用することができる｡ 

11
00:00:57,290 --> 00:01:01,400
バケットアグリゲーションの中にバケットアグリゲーションを入れ子にすることもできます｡ 

12
00:01:01,550 --> 00:01:08,420
ただ､ シンプルにするために､ 最初はバケットアグリゲーションという用語の中にメトリックアグリゲーションを入れ子にしておきます｡ 

13
00:01:08,720 --> 00:01:10,190
ご理解いただけたでしょうか？

14
00:01:10,370 --> 00:01:16,790
今回は､ 統計の集計をネストしてみますが､ 例えば､ avg集計でもよかったのですが､

15
00:01:16,790 --> 00:01:22,520
詳細を説明する前に､ その仕組みを紹介します｡

16
00:01:22,520 --> 00:01:29,960
そこで､ 以前見たのと全く同じように､ ステータス・フィールドに条件集計を入れるだけのクエリをあらかじめ用意しておきました｡

17
00:01:30,320 --> 00:01:34,610
では､ 既存の集計科目の中にXというキーを追加してみます｡ 

18
00:01:35,120 --> 00:01:40,550
このキーは､ 他のアグリゲーションと全く同じ構造のオブジェクトを含むことになる｡ 

19
00:01:40,550 --> 00:01:42,920
その点では､ 何も目新しいことはありません｡ 

20
00:01:43,600 --> 00:01:51,130
そこで､ すでに持っているこの集約オブジェクトにXという新しいキーを追加して､

21
00:01:51,130 --> 00:01:59,980
サブ集約というかバケット集約に名前を付けてみましょう｡

22
00:02:00,310 --> 00:02:03,700
ということで､ こちらでお答えするのもアグリゲーションタイプです｡ 

23
00:02:03,730 --> 00:02:08,350
Statsとフィールドにはアンダースコアの合計金額が表示されます｡ 

24
00:02:09,110 --> 00:02:16,550
つまり､ 今追加した新しいアグリゲーションは､ 親アグリゲーションが作成したバケットのコンテキストで実行されるのです｡

25
00:02:17,060 --> 00:02:19,910
クエリを実行して､ 結果がどのようなものか見てみましょう｡ 

26
00:02:24,450 --> 00:02:27,270
これまでの講義と同じ結果が得られています｡ 

27
00:02:27,270 --> 00:02:33,000
しかし､ それとは別に､ ネストされたアグリゲーションにちなんだオブジェクトが各バケット内に追加されています｡ 

28
00:02:33,660 --> 00:02:37,320
これらのオブジェクトには､ ネストされた集約の出力が含まれる｡ 

29
00:02:37,350 --> 00:02:45,240
今回は多値のメトリクス集計を使用しましたが､ 例えば合計集計を使用していれば､ ここに数字が表示されるだけでした｡

30
00:02:45,750 --> 00:02:52,260
つまり､ ここで見る統計は､ そのバケツに特有のものであるということです｡

31
00:02:52,860 --> 00:02:57,150
つまり､ これでいくつかのエラーなどにたどり着いたことになります｡  を各ステータスに設定します｡ 

32
00:02:57,330 --> 00:03:08,730
つまり､ ステータスが処理済みで､ アンダースコアの合計金額フィールドが10の間にある注文が209件あることがわかります｡

33
00:03:08,730 --> 00:03:08,730
27と281である｡  77.

34
00:03:09,300 --> 00:03:14,580
以前､ statsの集計を使ったときは､ クエリにマッチするすべての文書について統計を取っていましたが､

35
00:03:14,580 --> 00:03:17,850
これは暗黙のうちにmatch allクエリになっていたのです｡

36
00:03:18,330 --> 00:03:22,200
今回の統計は､ ある用語に特化したものとなっています｡ 

37
00:03:22,680 --> 00:03:27,720
この仕組みは､ アグリゲーションがそのコンテクストに基づいて実行されるというものです｡ 

38
00:03:27,900 --> 00:03:36,150
この特定の例では､ 用語集計はトップレベルの集計なので､ クエリパラメータのコンテキストで実行されます｡

39
00:03:36,660 --> 00:03:42,990
この場合､ 明示的にクエリを追加していないので､ Elasticsearchは暗黙のうちにmatch allクエリを使用しています｡ 

40
00:03:43,200 --> 00:03:47,880
例えば､ 合計が100以上の注文にのみマッチするクエリを指定したとします｡ 

41
00:03:48,060 --> 00:03:54,150
その場合､ 用語集計はこのクエリが生成するマッチのコンテキストで実行されます｡ 

42
00:03:54,510 --> 00:03:58,980
そうすると､ 集計の中で文書数が減ってしまうのです｡ 

43
00:03:59,010 --> 00:04:02,670
私が嘘で塗り固めていないことを証明するためにも､ 早くそうしてください｡ 

44
00:04:03,240 --> 00:04:17,570
では､ クエリパラメータを追加して､ 合計金額フィールドのクエリをアレンジして､ 値が100以上であることを指定することにします｡

45
00:04:17,580 --> 00:04:18,810
そして､ クエリーを実行します｡ 

46
00:04:19,810 --> 00:04:27,370
そして案の定､ クエリのマッチングが1000件から489件になったため､ ドキュメント数が減少していることがわかります｡

47
00:04:27,910 --> 00:04:38,060
つまり､ 単語の集約はクエリのコンテキストで実行され､ 統計の集約はその親集約がバケットの集約であるコンテキストで実行されます｡

48
00:04:38,080 --> 00:04:42,220
つまり､ そのアグリゲーションで生成されたバケットに対して操作することになる｡ 

49
00:04:42,370 --> 00:04:43,810
ご理解いただけたでしょうか？

50
00:04:44,490 --> 00:04:50,910
つまり､ メトリックアグリゲーションは単純な結果を生成し､ サブアグリゲーションを含むことができない｡ 

51
00:04:51,150 --> 00:05:00,030
一方､ バケットアグリゲーションは､ 親バケットアグリゲーションが生成したバケットを操作するサブアグリゲーションを含むことができます｡

52
00:05:00,750 --> 00:05:04,350
集計は､ それらが定義されているコンテキストに基づいて実行されます｡ 

53
00:05:04,620 --> 00:05:10,290
ルートアグリゲーションオブジェクトのトップレベルで追加されたアグリゲーションは､ リクエストのコンテキストで実行され､

54
00:05:10,290 --> 00:05:15,420
クエリとサブアグリゲーションは､ その親アグリゲーションのコンテキストで実行されます｡

55
00:05:15,900 --> 00:05:23,160
バケットアグリゲーション内にメトリックアグリゲーションとバケットアグリゲーションの両方をリストアップすることができるので､ 両方のアグリゲーショングループを組み合わせることができます｡

56
00:05:23,930 --> 00:05:33,320
メトリックアグリゲーションはリーフレベルクエリに､ バケットアグリゲーションは複合クエリに相当すると考えていただければと思います｡

57
00:05:33,530 --> 00:05:44,690
これは､ 複合クエリが他の複合クエリやリーフレベルクエリを含むことができるのと同じように､ バケットアグリゲーションが他のバケットアグリゲーションやメトリックアグリゲーションを含むことができるからである｡

58
00:05:45,320 --> 00:05:52,040
今回の講義では､ 新しいアグリゲーションタイプは見ませんでしたが､ 引き続き､ バケットアグリゲーションについて説明します｡

59
00:05:52,220 --> 00:05:57,620
次の講義で使うことになるので､ 今､ 集約のネストの方法を紹介したいと思います｡ 
